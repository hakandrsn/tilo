This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.json
app/_layout.tsx
app/chapters.tsx
app/game/[chapterId]/[levelId].tsx
app/game/jigsaw/[chapterId]/[levelId].tsx
app/index.tsx
app/levels/[chapterId].tsx
assets/fonts/SpaceMono-Regular.ttf
assets/images/adaptive-icon.png
assets/images/favicon.png
assets/images/icon.png
assets/images/ios-dark.png
assets/images/ios-light.png
assets/images/ios-tinted.png
assets/images/splash-icon.png
build-1768664620944.apk
DEVELOPMENT.md
eas.json
firebaseConfig.js
metro.config.js
package.json
src/assets/animations/star.lottie
src/components/ChapterNativeAd.tsx
src/components/ConfirmModal.tsx
src/components/DevPanel.tsx
src/components/GameBannerAd.tsx
src/components/NetworkError.tsx
src/components/PuzzleBoard.tsx
src/components/Tile.tsx
src/components/WinModal.tsx
src/constants/colors.ts
src/constants/data.ts
src/constants/gameConfig.ts
src/constants/layout.ts
src/constants/uiText.ts
src/hooks/usePuzzleGame.ts
src/modules/jigsaw/JigsawBoard.tsx
src/modules/jigsaw/JigsawGroup.tsx
src/modules/jigsaw/jigsawStore.ts
src/modules/jigsaw/useJigsawLogic.ts
src/services/adManager.ts
src/services/authService.ts
src/services/dataService.ts
src/services/deviceService.ts
src/services/syncQueue.ts
src/store/adStore.ts
src/store/dataStore.ts
src/store/gameStore.ts
src/store/hintStore.ts
src/store/progressStore.ts
src/types/index.ts
src/utils/puzzleLogic.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/game/jigsaw/[chapterId]/[levelId].tsx">
import { Ionicons } from "@expo/vector-icons";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { useEffect, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  useWindowDimensions,
  View,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

// Stores & Hooks
import { COLORS } from "@/src/constants/gameConfig";
import { useJigsawStore } from "@/src/modules/jigsaw/jigsawStore";
import { useDataActions } from "@/src/store/dataStore";
import { Level } from "@/src/types";

// Components
import WinModal from "@/src/components/WinModal";
import JigsawBoard from "@/src/modules/jigsaw/JigsawBoard";
import { GestureHandlerRootView } from "react-native-gesture-handler";

export default function JigsawGameScreen() {
  const router = useRouter();
  const { width, height } = useWindowDimensions();
  const { chapterId, levelId } = useLocalSearchParams<{
    chapterId: string;
    levelId: string;
  }>();

  const { getChapterById, getLevelById, getChapters } = useDataActions();
  const resetGame = useJigsawStore((state) => state.actions.resetGame);
  const status = useJigsawStore((state) => state.status);

  const [level, setLevel] = useState<Level | undefined>();
  const [isLoading, setIsLoading] = useState(true);
  const [showWinModal, setShowWinModal] = useState(false);

  // Initialize Data
  useEffect(() => {
    const initData = async () => {
      await getChapters();
      const l = await getLevelById(Number(chapterId), Number(levelId));
      setLevel(l);
      setIsLoading(false);
    };
    initData();
  }, [chapterId, levelId]);

  // Clean on unmount
  useEffect(() => {
    return () => {
      resetGame();
    };
  }, []);

  // Win Logic
  useEffect(() => {
    if (status === "won") {
      const timer = setTimeout(() => {
        setShowWinModal(true);
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [status]);

  const handleBack = () => {
    router.back();
  };

  const handleNextLevel = () => {
    // Implement Next Level Navigation
    // For now, just go back or reload with next ID if calculated
    // Assuming simple linear progression for demo:
    const nextLevelId = Number(levelId) + 1;
    // Check if next level exists (mock check, ideally use store)
    // For now, just reset and reload current or go back
    router.replace(`/game/jigsaw/${chapterId}/${nextLevelId}`);
    setShowWinModal(false);
  };

  const handleReplay = () => {
    resetGame();
    setShowWinModal(false);
    // Force re-init by toggling something or relying on store reset triggering JigsawBoard effect?
    // JigsawBoard effect depends on 'gridSize', which hasn't changed.
    // We might need to explicitely re-initialize.
    // But JigsawBoard checks 'isInitialized'. Store reset sets it to false.
    // Then JigsawBoard effect runs? No, JigsawBoard returns null if !isInitialized.
    // But JigsawBoard useEffect [gridSize] calls init.
    // Ideally, we need to trigger init again.
    // Let's rely on JigsawBoard re-mounting or a specific init call here.
    if (level) {
      useJigsawStore.getState().actions.initializeLevel(level.gridSize);
    }
  };

  if (isLoading || !level) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  // Calculate Layout Portions
  const headerHeight = 60;
  const availableHeight = height - headerHeight;

  // Full Screen Board for Scattered Mode
  const boardHeight = availableHeight;

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaView style={styles.container} edges={["top"]}>
        <Stack.Screen options={{ headerShown: false }} />

        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={handleBack} style={styles.backBtn}>
            <Ionicons name="arrow-back" size={28} color={COLORS.textPrimary} />
          </TouchableOpacity>
          <Text style={styles.title}>Jigsaw Mode</Text>
          {/* Spacer for alignment */}
          <View style={{ width: 40 }} />
        </View>

        {/* Board Container */}
        <View style={styles.gameArea}>
          <JigsawBoard
            gridSize={level.gridSize}
            imageSource={level.imageSource}
            boardWidth={width}
            boardHeight={boardHeight}
          />
        </View>

        {/* Win Modal */}
        <WinModal
          visible={showWinModal}
          moves={0} // Jigsaw doesn't track moves yet
          stars={3} // Always 3 stars for now
          isLastLevel={false}
          onNextLevel={handleNextLevel}
          onReplay={handleReplay}
          onBackToLevels={handleBack}
        />
      </SafeAreaView>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: COLORS.background,
  },
  header: {
    height: 60,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.border,
    backgroundColor: COLORS.surface,
    zIndex: 100,
  },
  backBtn: {
    padding: 8,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    color: COLORS.textPrimary,
  },
  gameArea: {
    flex: 1,
    position: "relative",
    backgroundColor: "#1a1a1a",
  },
});
</file>

<file path="src/modules/jigsaw/JigsawBoard.tsx">
import { Image } from "expo-image";
import React, { useEffect, useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { GridSize, ImageSource } from "../../types";
import JigsawGroup from "./JigsawGroup";
import { JigsawPiece, useJigsawStore } from "./jigsawStore";

interface JigsawBoardProps {
  gridSize: GridSize;
  imageSource: ImageSource;
  boardWidth: number;
  boardHeight: number;
}

const JigsawBoard: React.FC<JigsawBoardProps> = ({
  gridSize,
  imageSource,
  boardWidth,
  boardHeight,
}) => {
  const pieces = useJigsawStore((state) => state.pieces);
  const initializeLevel = useJigsawStore(
    (state) => state.actions.initializeLevel,
  );
  const isInitialized = useJigsawStore((state) => state.isInitialized);

  // Calculate strict piece size for the grid
  const { pieceSize, totalGridHeight, topOffset } = useMemo(() => {
    const pSize = Math.floor(boardWidth / gridSize.cols);
    const tGridHeight = pSize * gridSize.rows;
    // Round offset to avoid subpixel jitter
    const tOffset = Math.floor(Math.max(0, (boardHeight - tGridHeight) / 2));
    return {
      pieceSize: pSize,
      totalGridHeight: tGridHeight,
      topOffset: tOffset,
    };
  }, [boardWidth, boardHeight, gridSize]);

  useEffect(() => {
    initializeLevel(gridSize);
  }, [gridSize]);

  // Group pieces by groupId to render JigsawGroup containers
  const groupedPieces = useMemo(() => {
    const groups: Record<string, JigsawPiece[]> = {};
    Object.values(pieces).forEach((p) => {
      if (!groups[p.groupId]) {
        groups[p.groupId] = [];
      }
      groups[p.groupId].push(p);
    });
    return groups;
  }, [pieces]);

  if (!isInitialized) {
    return <View style={styles.container} />;
  }

  // Tray starts below the board area.
  // Actually, JigsawBoard is passed `boardHeight`.
  // The Main Screen will handle the "Split".
  // `JigsawBoard` now covers the UNIVERSE (Board + Tray).
  // But Props say `boardHeight`... this is usually just the Game Area height.
  // We need `trayY` passed in? Or we assume Board Height IS the boundary?
  // Let's assume passed `boardHeight` is the "Grid Area".
  // The Tray is technically "below" it visually in the Screen composition.
  // BUT `JigsawGroup` needs absolute coordinates relative to `JigsawBoard` container.
  // Refactor: `JigsawBoard` should overlay the ENTIRE screen (Game + Tray) to allow drag between them.
  // So `boardHeight` prop should be TOTAL HEIGHT.

  // We will assume `boardHeight` passed here is the GRID area height (top).
  // The Tray is calculated as `boardHeight + 20`.

  const ghostImageStyles = {
    position: "absolute" as const,
    top: topOffset,
    left: 0,
    width: pieceSize * gridSize.cols,
    height: pieceSize * gridSize.rows,
    opacity: 0.15, // Ghost opacity
  };

  return (
    <View
      style={[
        styles.container,
        {
          width: boardWidth,
          height: boardHeight + 200, // Extend for Tray Area (safe assumption)
        },
      ]}
    >
      {/* Ghost Image on Board */}
      <View style={ghostImageStyles}>
        <Image
          source={imageSource}
          style={{ width: "100%", height: "100%" }}
          contentFit="cover"
        />
      </View>

      <View
        style={{
          marginTop: topOffset,
          width: boardWidth,
          height: totalGridHeight,
          position: "relative",
        }}
      >
        {/* Background Grid Lines to Guide User */}
        <View style={styles.gridBackground}>
          {/* Render Vertical Lines */}
          {Array.from({ length: gridSize.cols + 1 }).map((_, i) => (
            <View
              key={`v-${i}`}
              style={[
                styles.gridLineV,
                { left: i * pieceSize, height: totalGridHeight },
              ]}
            />
          ))}
          {/* Render Horizontal Lines */}
          {Array.from({ length: gridSize.rows + 1 }).map((_, i) => (
            <View
              key={`h-${i}`}
              style={[
                styles.gridLineH,
                { top: i * pieceSize, width: boardWidth },
              ]}
            />
          ))}
        </View>

        {/* Render Groups */}
        {Object.entries(groupedPieces).map(([groupId, groupPieces]) => (
          <JigsawGroup
            key={groupId}
            groupId={groupId}
            pieces={groupPieces}
            pieceSize={pieceSize}
            imageSource={imageSource}
            gridSize={gridSize}
            boardWidth={boardWidth}
          />
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: "transparent",
    overflow: "visible",
  },
  gridBackground: {
    ...StyleSheet.absoluteFillObject,
    // Slightly visible background for the play area
    // backgroundColor: "rgba(0,0,0,0.1)",
  },
  gridLineV: {
    position: "absolute",
    width: 1,
    backgroundColor: "rgba(255,255,255,0.1)",
  },
  gridLineH: {
    position: "absolute",
    height: 1,
    backgroundColor: "rgba(255,255,255,0.1)",
  },
});

export default JigsawBoard;
</file>

<file path="src/modules/jigsaw/JigsawGroup.tsx">
import { Image } from "expo-image";
import React, { useEffect, useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withSpring,
  withTiming,
} from "react-native-reanimated";
import { GridSize, ImageSource } from "../../types";
import { calculateImageOffset } from "../../utils/puzzleLogic";
import { JigsawPiece as JigsawPieceType, useJigsawStore } from "./jigsawStore";
import { useJigsawLogic } from "./useJigsawLogic";

interface JigsawGroupProps {
  groupId: string;
  pieces: JigsawPieceType[];
  pieceSize: number;
  imageSource: ImageSource;
  gridSize: GridSize;
  boardWidth: number;
}

const JigsawGroup: React.FC<JigsawGroupProps> = ({
  groupId,
  pieces,
  pieceSize,
  imageSource,
  gridSize,
  boardWidth,
}) => {
  const bringGroupToFront = useJigsawStore(
    (state) => state.actions.bringGroupToFront,
  );
  const status = useJigsawStore((state) => state.status);
  const { attemptDrop } = useJigsawLogic(pieceSize);

  // Group State
  const isLocked = pieces[0]?.isLocked ?? false;
  const isWon = status === "won";

  // Calculate Group Bounding Box
  const minCol = pieces.length
    ? Math.min(...pieces.map((p) => p.currentCol))
    : 0;
  const minRow = pieces.length
    ? Math.min(...pieces.map((p) => p.currentRow))
    : 0;

  // Initial Position Logic (Always on Grid now)
  const initialX = minCol * pieceSize;
  const initialY = minRow * pieceSize;

  const width = pieces.length
    ? (Math.max(...pieces.map((p) => p.currentCol)) - minCol + 1) * pieceSize
    : pieceSize;
  const height = pieces.length
    ? (Math.max(...pieces.map((p) => p.currentRow)) - minRow + 1) * pieceSize
    : pieceSize;

  // Shared Values
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const isDragging = useSharedValue(false);
  const scale = useSharedValue(1);
  const zIndexLocal = useSharedValue(pieces[0]?.zIndex ?? 1);
  const glowOpacity = useSharedValue(0);

  // Coordinate Compensation State
  const prevInitialPos = React.useRef({ x: initialX, y: initialY });

  // Sync with Store Updates (and compensate for jumps)
  useEffect(() => {
    if (!isDragging.value) {
      // Check for Coordinate Jump (e.g. Merge occurred, bounding box changed)
      const diffX = initialX - prevInitialPos.current.x;
      const diffY = initialY - prevInitialPos.current.y;

      // If there is a significant jump (due to bbox change from merge or push)
      // We compensate so the piece stays visually in place, then slides to new target.
      if (Math.abs(diffX) > 0.1 || Math.abs(diffY) > 0.1) {
        // Keep current visual position by reversing the data jump
        translateX.value = translateX.value + diffX;
        translateY.value = translateY.value + diffY;
      }

      // Animate to target (new data position) smoothly and quickly
      translateX.value = withTiming(initialX, { duration: 150 });
      translateY.value = withTiming(initialY, { duration: 150 });

      prevInitialPos.current = { x: initialX, y: initialY };

      if (!isLocked) {
        zIndexLocal.value = pieces[0]?.zIndex ?? 1;
      }
    }
  }, [initialX, initialY, pieces[0]?.zIndex, isLocked]);

  // Win Animation
  useEffect(() => {
    if (isWon) {
      glowOpacity.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 1000 }),
          withTiming(0.5, { duration: 1000 }),
        ),
        -1,
        true,
      );
    }
  }, [isWon]);

  // Robust Gesture with SharedValues
  const startX = useSharedValue(0);
  const startY = useSharedValue(0);

  const panGesture = useMemo(
    () =>
      Gesture.Pan()
        .enabled(!isLocked && !isWon)
        .onStart(() => {
          startX.value = translateX.value;
          startY.value = translateY.value;

          isDragging.value = true;
          scale.value = withSpring(1.05);
          zIndexLocal.value = 9999;

          // runOnJS fix
          runOnJS(bringGroupToFront)(groupId);
        })
        .onUpdate((event) => {
          translateX.value = startX.value + event.translationX;
          translateY.value = startY.value + event.translationY;
        })
        .onEnd((event) => {
          const finalX = startX.value + event.translationX;
          const finalY = startY.value + event.translationY;

          const anchor = pieces[0];
          const anchorRelX = (anchor.currentCol - minCol) * pieceSize;
          const anchorRelY = (anchor.currentRow - minRow) * pieceSize;

          runOnJS(attemptDrop)(
            anchor.id,
            finalX + anchorRelX,
            finalY + anchorRelY,
          );

          isDragging.value = false;
          scale.value = withSpring(1);
        }),
    [
      groupId,
      isLocked,
      isWon,
      minCol,
      minRow,
      pieces, // Added dependency
      pieceSize,
      attemptDrop,
      bringGroupToFront,
    ],
  );

  const groupStyle = useAnimatedStyle(() => ({
    position: "absolute",
    left: 0,
    top: 0,
    width: width,
    height: height,
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
    zIndex: zIndexLocal.value,
    elevation: zIndexLocal.value > 100 ? 50 : 0,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: isDragging.value ? 0.3 : 0,
    shadowRadius: 4,
  }));

  const glowStyle = useAnimatedStyle(() => ({
    position: "absolute",
    top: -4,
    left: -4,
    right: -4,
    bottom: -4,
    borderWidth: 4,
    borderColor: "#fbbf24", // Golden glow
    borderRadius: 8,
    opacity: glowOpacity.value,
  }));

  // Border Rendering Logic
  // Only show internal borders if NOT merged? No, showing borders helps see individual pieces.
  // But merged groups should look unified.
  // Let's keep the previous logic: render individual pieces, check neighbors for borders.
  const isMerged = pieces.length > 1;

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={groupStyle} pointerEvents="box-none">
        {/* Win Glow Overlay */}
        {isWon && <Animated.View style={glowStyle} />}

        {pieces.map((piece) => {
          const relLeft = (piece.currentCol - minCol) * pieceSize;
          const relTop = (piece.currentRow - minRow) * pieceSize;

          const { top, left } = calculateImageOffset(
            piece.id,
            gridSize,
            pieceSize,
          );

          // Neighbor Logic for Borders
          const hasTop = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow - 1 &&
              p.currentCol === piece.currentCol,
          );
          const hasBottom = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow + 1 &&
              p.currentCol === piece.currentCol,
          );
          const hasLeft = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow &&
              p.currentCol === piece.currentCol - 1,
          );
          const hasRight = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow &&
              p.currentCol === piece.currentCol + 1,
          );

          return (
            <View
              key={piece.id}
              style={{
                position: "absolute",
                left: relLeft,
                top: relTop,
                width: pieceSize,
                height: pieceSize,
                overflow: "hidden", // Clip image
              }}
            >
              <Image
                source={imageSource}
                style={{
                  width: gridSize.cols * pieceSize,
                  height: gridSize.rows * pieceSize,
                  transform: [{ translateX: left }, { translateY: top }],
                }}
              />

              {/* Highlight Locked Pieces (Magnet) */}
              {isLocked && !isWon && (
                <View
                  style={{
                    ...StyleSheet.absoluteFillObject,
                    backgroundColor: "rgba(251, 191, 36, 0.2)",
                  }}
                />
              )}

              {/* Borders */}
              {!isWon && (
                <>
                  {!hasTop && (
                    <View
                      style={[
                        styles.borderTop,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasBottom && (
                    <View
                      style={[
                        styles.borderBottom,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasLeft && (
                    <View
                      style={[
                        styles.borderLeft,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasRight && (
                    <View
                      style={[
                        styles.borderRight,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                </>
              )}
            </View>
          );
        })}
      </Animated.View>
    </GestureDetector>
  );
};

const styles = StyleSheet.create({
  borderTop: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderBottom: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderLeft: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    width: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderRight: {
    position: "absolute",
    top: 0,
    bottom: 0,
    right: 0,
    width: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderMerged: {
    backgroundColor: "#fbbf24",
    height: 2, // Thicker for external
    width: 2,
  },
});

export default JigsawGroup;
</file>

<file path="src/modules/jigsaw/jigsawStore.ts">
import { create } from "zustand";
import { GridSize } from "../../types";

export type JigsawPiece = {
  id: number;
  currentCol: number;
  currentRow: number;
  correctRow: number;
  correctCol: number;
  groupId: string;
  zIndex: number;
  isLocked: boolean;
};

export type GameStatus = "playing" | "won";

interface JigsawState {
  pieces: Record<number, JigsawPiece>;
  gridSize: GridSize;
  isInitialized: boolean;
  maxZIndex: number;
  status: GameStatus;
  isHapticEnabled: boolean;
}

interface JigsawActions {
  initializeLevel: (gridSize: GridSize) => void;
  moveGroupToGrid: (
    anchorId: number,
    targetRow: number,
    targetCol: number,
  ) => { merged: boolean };
  bringGroupToFront: (groupId: string) => void;
  resetGame: () => void;
}

interface JigsawStore extends JigsawState {
  actions: JigsawActions;
}

const initialState: JigsawState = {
  pieces: {},
  gridSize: { cols: 3, rows: 4 },
  isInitialized: false,
  maxZIndex: 1,
  status: "playing",
  isHapticEnabled: true,
};

// Helper: Shuffle an array
const shuffle = <T>(array: T[]): T[] => {
  return array.sort(() => Math.random() - 0.5);
};

// Helper: Find nearest valid shift for a group to avoid collision
const findNearestValidShiftForGroup = (
  group: JigsawPiece[],
  pieces: Record<number, JigsawPiece>,
  gridSize: GridSize,
  blockedSlots: Set<string>,
): { dr: number; dc: number } | null => {
  let radius = 1;
  const maxRadius = Math.max(gridSize.rows, gridSize.cols);

  while (radius <= maxRadius) {
    for (let dr = -radius; dr <= radius; dr++) {
      for (let dc = -radius; dc <= radius; dc++) {
        // Optimization: only check perimeter of current radius
        if (Math.abs(dr) !== radius && Math.abs(dc) !== radius) continue;

        let isValidShift = true;

        for (const p of group) {
          const nr = p.currentRow + dr;
          const nc = p.currentCol + dc;

          // Check Bounds
          if (nr < 0 || nr >= gridSize.rows || nc < 0 || nc >= gridSize.cols) {
            isValidShift = false;
            break;
          }

          // Check blocked slots (from incoming group)
          if (blockedSlots.has(`${nr},${nc}`)) {
            isValidShift = false;
            break;
          }

          // Check if slot is occupied by YET ANOTHER group (not the victim itself, nor the incoming one)
          const isOccupied = Object.values(pieces).some(
            (other) =>
              other.currentRow === nr &&
              other.currentCol === nc &&
              other.groupId !== group[0].groupId,
          );

          if (isOccupied) {
            isValidShift = false;
            break;
          }
        }

        if (isValidShift) {
          return { dr, dc };
        }
      }
    }
    radius++;
  }
  return null;
};

export const useJigsawStore = create<JigsawStore>((set, get) => ({
  ...initialState,

  actions: {
    initializeLevel: (gridSize) => {
      const totalPieces = gridSize.cols * gridSize.rows;
      const pieces: Record<number, JigsawPiece> = {};

      // 1. Generate all possible grid slots
      const allSlots: { row: number; col: number }[] = [];
      for (let r = 0; r < gridSize.rows; r++) {
        for (let c = 0; c < gridSize.cols; c++) {
          allSlots.push({ row: r, col: c });
        }
      }

      // 2. Shuffle slots to assign random initial positions
      const shuffledSlots = shuffle([...allSlots]);

      // 3. Create Pieces
      for (let i = 0; i < totalPieces; i++) {
        const correctRow = Math.floor(i / gridSize.cols);
        const correctCol = i % gridSize.cols;
        const initialPos = shuffledSlots[i];

        pieces[i] = {
          id: i,
          currentCol: initialPos.col,
          currentRow: initialPos.row,
          correctRow,
          correctCol,
          zIndex: 1,
          isLocked: false,
          groupId: `group-${i}`,
        };
      }

      // 4. Initial Auto-Merge (Recursive)
      // If pieces spawn next to their correct neighbors, merge them immediately.
      let mergedSomething = true;
      while (mergedSomething) {
        mergedSomething = false;
        const allPieces = Object.values(pieces);

        for (const p of allPieces) {
          const neighbors = [
            { r: p.currentRow - 1, c: p.currentCol },
            { r: p.currentRow + 1, c: p.currentCol },
            { r: p.currentRow, c: p.currentCol - 1 },
            { r: p.currentRow, c: p.currentCol + 1 },
          ];

          for (const n of neighbors) {
            const neighbor = allPieces.find(
              (np) =>
                np.currentRow === n.r &&
                np.currentCol === n.c &&
                np.groupId !== p.groupId,
            );

            if (neighbor) {
              const correctRowDiff = neighbor.correctRow - p.correctRow;
              const correctColDiff = neighbor.correctCol - p.correctCol;
              const actualRowDiff = neighbor.currentRow - p.currentRow;
              const actualColDiff = neighbor.currentCol - p.currentCol;

              if (
                correctRowDiff === actualRowDiff &&
                correctColDiff === actualColDiff
              ) {
                // Merge!
                const targetGroupId = neighbor.groupId;
                const sourceGroupId = p.groupId;
                // Merge source group INTO target group
                const sourceMembers = allPieces.filter(
                  (m) => m.groupId === sourceGroupId,
                );
                sourceMembers.forEach((m) => {
                  pieces[m.id].groupId = targetGroupId;
                });
                mergedSomething = true;
              }
            }
          }
        }
      }

      set({
        ...initialState,
        pieces,
        gridSize,
        isInitialized: true,
        maxZIndex: 1,
        status: "playing",
      });
    },

    moveGroupToGrid: (anchorId, targetRow, targetCol) => {
      const state = get();
      if (state.status === "won") return { merged: false };

      const pieces = { ...state.pieces };
      const anchorPiece = pieces[anchorId];
      if (!anchorPiece) return { merged: false };

      const draggedGroupId = anchorPiece.groupId;
      const groupPieces = Object.values(pieces).filter(
        (p) => p.groupId === draggedGroupId,
      );

      // 1. Calculate Full Footprint of the Moving Group
      const targetFootprint = groupPieces.map((p) => ({
        id: p.id,
        row: targetRow + (p.currentRow - anchorPiece.currentRow),
        col: targetCol + (p.currentCol - anchorPiece.currentCol),
      }));

      // Check Bounds
      const isOutOfBounds = targetFootprint.some(
        (m) =>
          m.row < 0 ||
          m.row >= state.gridSize.rows ||
          m.col < 0 ||
          m.col >= state.gridSize.cols,
      );

      if (isOutOfBounds) return { merged: false };

      // 2. Identify Victim Groups (Aggressive Scan)
      const victimGroupIds = new Set<string>();
      const incomingSlots = new Set(
        targetFootprint.map((f) => `${f.row},${f.col}`),
      );

      // Scan all pieces: Is anyone in my new territory?
      Object.values(pieces).forEach((p) => {
        if (
          p.groupId !== draggedGroupId &&
          incomingSlots.has(`${p.currentRow},${p.currentCol}`)
        ) {
          victimGroupIds.add(p.groupId); // This whole group must be pushed
        }
      });

      // 3. Move Active Group FIRST (Update State Optimistically)
      const newMaxZIndex = state.maxZIndex + 10;
      targetFootprint.forEach((m) => {
        pieces[m.id] = {
          ...pieces[m.id],
          currentRow: m.row,
          currentCol: m.col,
          zIndex: newMaxZIndex,
        };
      });

      // 4. Displace Victim Groups
      // 'occupiedSlots' must track both my new pos AND other pushed victims
      const occupiedSlots = new Set(
        targetFootprint.map((f) => `${f.row},${f.col}`),
      );

      victimGroupIds.forEach((vGroupId) => {
        const vGroup = Object.values(pieces).filter(
          (p) => p.groupId === vGroupId,
        );

        // Displace the group as a whole
        const shift = findNearestValidShiftForGroup(
          vGroup,
          pieces,
          state.gridSize,
          occupiedSlots,
        );

        if (shift) {
          vGroup.forEach((p) => {
            const nr = p.currentRow + shift.dr;
            const nc = p.currentCol + shift.dc;
            pieces[p.id] = {
              ...pieces[p.id],
              currentRow: nr,
              currentCol: nc,
              zIndex: state.maxZIndex + 1,
            };
            occupiedSlots.add(`${nr},${nc}`); // This slot is now taken
          });
        }
      });

      // 5. Merge Logic
      let didMerge = false;
      const currentGroupMembers = Object.values(pieces).filter(
        (p) => p.groupId === draggedGroupId,
      );

      for (const p of currentGroupMembers) {
        const neighbors = [
          { r: p.currentRow - 1, c: p.currentCol },
          { r: p.currentRow + 1, c: p.currentCol },
          { r: p.currentRow, c: p.currentCol - 1 },
          { r: p.currentRow, c: p.currentCol + 1 },
        ];

        for (const n of neighbors) {
          const neighborPiece = Object.values(pieces).find(
            (np) =>
              np.currentRow === n.r &&
              np.currentCol === n.c &&
              np.groupId !== draggedGroupId,
          );

          if (neighborPiece) {
            const correctRowDiff = neighborPiece.correctRow - p.correctRow;
            const correctColDiff = neighborPiece.correctCol - p.correctCol;
            const actualRowDiff = neighborPiece.currentRow - p.currentRow;
            const actualColDiff = neighborPiece.currentCol - p.currentCol;

            if (
              correctRowDiff === actualRowDiff &&
              correctColDiff === actualColDiff
            ) {
              // MERGE
              const targetToEatGroupId = neighborPiece.groupId;
              const victims = Object.values(pieces).filter(
                (v) => v.groupId === targetToEatGroupId,
              );
              victims.forEach((v) => {
                pieces[v.id] = {
                  ...pieces[v.id],
                  groupId: draggedGroupId,
                  zIndex: newMaxZIndex,
                };
              });
              didMerge = true;
            }
          }
        }
      }

      // 6. Win Condition Check
      const uniqueGroups = new Set(Object.values(pieces).map((p) => p.groupId));
      const status = uniqueGroups.size === 1 ? "won" : "playing";

      set({
        pieces,
        maxZIndex: newMaxZIndex,
        status,
      });

      return { merged: didMerge };
    },

    bringGroupToFront: (groupId) => {
      set((state) => {
        if (state.status === "won") return {};
        const newPieces = { ...state.pieces };
        Object.values(newPieces).forEach((p) => {
          if (p.groupId === groupId) {
            newPieces[p.id].zIndex = state.maxZIndex + 1;
          }
        });
        return { pieces: newPieces, maxZIndex: state.maxZIndex + 1 };
      });
    },

    resetGame: () => {
      set(initialState);
    },
  },
}));
</file>

<file path="src/modules/jigsaw/useJigsawLogic.ts">
import * as Haptics from "expo-haptics";
import { useCallback } from "react";
import { useJigsawStore } from "./jigsawStore";

/**
 * Hook to handle grid-based drops
 */
export const useJigsawLogic = (pieceSize: number) => {
  const moveGroupToGrid = useJigsawStore(
    (state) => state.actions.moveGroupToGrid,
  );
  const gridSize = useJigsawStore((state) => state.gridSize);

  /**
   * Called when a piece is dropped.
   * Calculates which grid cell (row, col) the piece falls into.
   */
  const attemptDrop = useCallback(
    (draggedPieceId: number, relativeDropX: number, relativeDropY: number) => {
      // Calculate target grid coordinates
      const targetCol = Math.round(relativeDropX / pieceSize);
      const targetRow = Math.round(relativeDropY / pieceSize);

      // Check if drop is within the Grid Board
      if (
        targetRow >= 0 &&
        targetRow < gridSize.rows &&
        targetCol >= 0 &&
        targetCol < gridSize.cols
      ) {
        // Valid Grid Drop
        const result = moveGroupToGrid(draggedPieceId, targetRow, targetCol);

        const isHapticEnabled = useJigsawStore.getState().isHapticEnabled;
        if (result.merged && isHapticEnabled) {
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        }
      } else {
        // Invalid Drop (Off-grid)
        // For scattered mode, we might want to snap it back to nearest valid slot?
        // Or just let it stay where it was (store won't update if we don't call move).
        // Since we are using SharedValues in JigsawGroup, the visual position resets onDragEnd
        // if store doesn't update.
        // The store `moveGroupToGrid` has logic to reject OOB moves anyway.
        // So we can technically try to move it, and if it fails, the component resets.
        // But here we explicitly check bounds.
        // If OOB, we do nothing. The component's `translateX/Y` will revert to `initialX/Y`
        // because `isDragging` becomes false and the store state hasn't changed.
      }
    },
    [pieceSize, gridSize, moveGroupToGrid],
  );

  return {
    attemptDrop,
  };
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# generated native folders
/ios
/android
</file>

<file path="DEVELOPMENT.md">
# Puzzle Game - GeliÅŸtirme DokÃ¼mantasyonu

## ğŸ“‹ Proje Ã–zeti

React Native (Expo) ile geliÅŸtirilmiÅŸ, chapter-level bazlÄ± bir **Sliding Tile Puzzle** oyunu. Virtual splitting tekniÄŸi kullanÄ±larak gÃ¶rseller fiziksel olarak bÃ¶lÃ¼nmeden puzzle parÃ§alarÄ± oluÅŸturulur.

## ğŸ¯ Temel Ã–zellikler

### Oyun MekaniÄŸi
- **Virtual Splitting**: GÃ¶rseller fiziksel olarak bÃ¶lÃ¼nmez, tek gÃ¶rsel Ã¼zerinden maskeleme yapÄ±lÄ±r
- **Ã‡Ã¶zÃ¼lebilir Shuffle**: Her zaman Ã§Ã¶zÃ¼lebilir puzzle garantisi (geriye doÄŸru hamle simÃ¼lasyonu)
- **Progresif Zorluk**: 
  - Seviye 1-8: 3Ã—3 grid (50 shuffle hamlesi)
  - Seviye 9-16: 4Ã—4 grid (100 shuffle hamlesi)
  - Seviye 17-24: 5Ã—5 grid (150 shuffle hamlesi)

### Ä°Ã§erik
- **20 Kategori** Ã— **24 Seviye** = **480 Toplam Seviye**
- Her kategori farklÄ± tema ve renk paleti
- Her seviye iÃ§in unique gÃ¶rsel

### Ä°lerleme Sistemi
- YÄ±ldÄ±z sistemi (1-3 yÄ±ldÄ±z, performansa gÃ¶re)
- Chapter unlock sistemi
- Level unlock sistemi (sÄ±ralÄ± aÃ§Ä±lma)
- Son oynanan level kaydÄ±

### Hamle Sistemi
- VarsayÄ±lan: **10 hamle hakkÄ±**
- Her chapter bitiminde: **+5 bonus hamle**
- Rewarded reklam izleyerek: **+3 hamle hakkÄ±**

### Reklam Sistemi (AdMob)
- **Interstitial**: Level geÃ§iÅŸlerinde gÃ¶sterilir
- **Rewarded**: Hamle almak iÃ§in izlenir
- Test ID'leri ile geliÅŸtirme desteÄŸi
- Expo Go'da conditional loading (native modÃ¼l yoksa no-op)

## ğŸ—ï¸ Mimari YapÄ±

### Dizin YapÄ±sÄ±

```
puzzle-game/
â”œâ”€â”€ app/                          # Expo Router ekranlarÄ±
â”‚   â”œâ”€â”€ _layout.tsx              # Root layout (splash, device ID, ads init)
â”‚   â”œâ”€â”€ index.tsx                # Start ekranÄ± (Devam Et + BÃ¶lÃ¼mler)
â”‚   â”œâ”€â”€ chapters.tsx             # Kategori listesi
â”‚   â”œâ”€â”€ levels/[chapterId].tsx   # Seviye listesi
â”‚   â””â”€â”€ game/[chapterId]/[levelId].tsx  # Oyun ekranÄ±
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Tile.tsx             # Puzzle parÃ§asÄ± (virtual splitting)
â”‚   â”‚   â”œâ”€â”€ PuzzleBoard.tsx      # Oyun tahtasÄ±
â”‚   â”‚   â”œâ”€â”€ WinModal.tsx         # Kazanma modalÄ±
â”‚   â”‚   â””â”€â”€ DevPanel.tsx         # Development paneli
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ usePuzzleGame.ts     # Oyun mantÄ±ÄŸÄ± hook'u
â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”œâ”€â”€ gameStore.ts         # Aktif oyun state'i (Zustand)
â”‚   â”‚   â”œâ”€â”€ progressStore.ts     # Ä°lerleme state'i (Zustand + AsyncStorage)
â”‚   â”‚   â””â”€â”€ hintStore.ts         # Hamle hakkÄ± state'i (Zustand + AsyncStorage)
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ deviceService.ts     # Device ID alma
â”‚   â”‚   â””â”€â”€ adManager.ts         # AdMob yÃ¶netimi (conditional)
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ puzzleLogic.ts       # Puzzle algoritmalarÄ±
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts             # TypeScript tipleri
â”‚   â””â”€â”€ constants/
â”‚       â””â”€â”€ gameConfig.ts         # Oyun konfigÃ¼rasyonu
â”œâ”€â”€ app.json                      # Expo config
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

## ğŸ¨ UI/UX TasarÄ±m

### Renk Paleti (Minimalist Dark Theme)

```typescript
background: '#0a0a0f'      // Ana arka plan
surface: '#12121a'         // Kart arka planÄ±
surfaceLight: '#1e1e2d'    // Hover/active durumlar
primary: '#8b5cf6'         // Mor (ana renk)
accent: '#06b6d4'          // Cyan (vurgu)
```

### Responsive TasarÄ±m

- **Phone** (<768px): 2 sÃ¼tun grid, 360px max board
- **Tablet** (â‰¥768px): 3 sÃ¼tun grid, 480px max board
- **Desktop** (â‰¥1024px): 4 sÃ¼tun grid, 480px max board

### Animasyonlar

- Tile hareketleri: `withTiming` (120ms, bounce yok)
- Modal aÃ§Ä±lÄ±ÅŸlarÄ±: `FadeIn` + `SlideInDown`
- Sayfa geÃ§iÅŸleri: Expo Router slide animation

## ğŸ”§ Teknik Detaylar

### State Management (Zustand)

#### gameStore
- Aktif oyun durumu
- Grid state, boÅŸ slot, hamle sayÄ±sÄ±
- Ã‡Ã¶zÃ¼m kontrolÃ¼

#### progressStore
- KullanÄ±cÄ± ilerlemesi (AsyncStorage ile persist)
- Unlocked chapters/levels
- Tamamlanan level'ler ve yÄ±ldÄ±zlar
- Son oynanan level

#### hintStore
- Hamle hakkÄ± sayÄ±sÄ± (AsyncStorage ile persist)
- Chapter bonus sistemi
- Reklam reward sistemi

### Virtual Splitting TekniÄŸi

```typescript
// Her tile iÃ§in gÃ¶rsel offset hesaplama
const imageOffset = {
  top: -(rowIndex * tileSize),
  left: -(colIndex * tileSize),
};

// Container overflow: hidden ile maskeleme
<View style={{ overflow: 'hidden' }}>
  <Image style={{ position: 'absolute', ...imageOffset }} />
</View>
```

### Shuffle AlgoritmasÄ±

1. Ã‡Ã¶zÃ¼lmÃ¼ÅŸ grid ile baÅŸla: `[0, 1, 2, ..., n-1]`
2. X adet geÃ§erli rastgele hamle simÃ¼le et
3. Bu yÃ¶ntem her zaman Ã§Ã¶zÃ¼lebilir puzzle garantiler

### Device ID Sistemi

- `expo-application` ile unique device ID
- Android: `getAndroidId()`
- iOS: `getIosIdForVendorAsync()`
- Web: Fallback ID
- Ä°lk aÃ§Ä±lÄ±ÅŸta loglanÄ±r

### AdMob Entegrasyonu

#### Conditional Loading
- Expo Go'da native modÃ¼l yoksa no-op fonksiyonlar
- Try-catch ile gÃ¼venli yÃ¼kleme
- Production build'de normal Ã§alÄ±ÅŸÄ±r

#### Reklam Tipleri
- **Interstitial**: Level geÃ§iÅŸlerinde
- **Rewarded**: Hamle almak iÃ§in
- Test ID'leri: `TestIds.INTERSTITIAL`, `TestIds.REWARDED`

## ğŸ“± Ekranlar

### 1. Start Screen (`app/index.tsx`)
- Logo ve baÅŸlÄ±k
- **Devam Et** butonu (son kaldÄ±ÄŸÄ± level)
- **BÃ¶lÃ¼mler** butonu
- YÄ±ldÄ±z ve hamle hakkÄ± gÃ¶stergesi
- Ä°lerleme barÄ±

### 2. Chapters Screen (`app/chapters.tsx`)
- Grid layout (responsive)
- Her chapter iÃ§in:
  - Thumbnail gÃ¶rsel
  - Chapter numarasÄ± badge
  - Ä°lerleme barÄ±
  - YÄ±ldÄ±z sayÄ±sÄ±
- Lock overlay (unlocked deÄŸilse)

### 3. Levels Screen (`app/levels/[chapterId].tsx`)
- Chapter header (thumbnail + istatistikler)
- Level grid (responsive)
- Her level iÃ§in:
  - Level numarasÄ±
  - Grid boyutu
  - YÄ±ldÄ±zlar (tamamlandÄ±ysa)
- Lock icon (unlocked deÄŸilse)

### 4. Game Screen (`app/game/[chapterId]/[levelId].tsx`)
- Header:
  - Hedef gÃ¶rsel (kÃ¼Ã§Ã¼k preview)
  - Hamle sayÄ±sÄ±
  - Level badge
- Puzzle board (responsive)
- Alt butonlar:
  - Yeniden BaÅŸlat
  - Hamle Al (reklam ile)
- Win Modal (Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nde)

## ğŸ› ï¸ Development Tools

### Dev Panel
- SaÄŸ altta kÄ±rmÄ±zÄ± ğŸ›  butonu
- Level'e git (bÃ¶lÃ¼m + level seÃ§imi)
- Puzzle'Ä± Ã§Ã¶z (instant win)
- +10 hamle hakkÄ± ekle

**Aktif/Pasif**: `app/_layout.tsx` iÃ§inde `__DEV_MODE__` deÄŸiÅŸkeni

## ğŸ“¦ BaÄŸÄ±mlÄ±lÄ±klar

### Core
- `expo`: ~54.0.31
- `expo-router`: ~6.0.21
- `react-native`: 0.81.5
- `react`: 19.1.0

### State & Storage
- `zustand`: ^5.0.10
- `@react-native-async-storage/async-storage`: 2.2.0

### Animasyon
- `react-native-reanimated`: ~4.1.1

### GÃ¶rsel
- `expo-image`: ~3.0.11

### Reklam
- `react-native-google-mobile-ads`: (conditional)

### Utility
- `expo-application`: Device ID iÃ§in
- `expo-splash-screen`: Splash screen kontrolÃ¼

## ğŸ” Storage Keys

```typescript
USER_PROGRESS: '@puzzle_game_progress'
HINT_COUNT: '@puzzle_game_hints'
LAST_PLAYED: '@puzzle_game_last_played'
DEVICE_ID: '@puzzle_game_device_id'
```

## ğŸ® Oyun AkÄ±ÅŸÄ±

1. **Uygulama AÃ§Ä±lÄ±ÅŸÄ±**
   - Device ID al ve logla
   - Progress ve hints yÃ¼kle
   - AdMob initialize (varsa)

2. **Start Screen**
   - Devam Et â†’ Son oynanan level
   - BÃ¶lÃ¼mler â†’ Chapter listesi

3. **Chapter Selection**
   - Unlocked chapter'lar seÃ§ilebilir
   - Her chapter iÃ§in progress gÃ¶sterilir

4. **Level Selection**
   - SÄ±ralÄ± unlock (Ã¶nceki level tamamlanmalÄ±)
   - Tamamlanan level'ler yÄ±ldÄ±zlÄ± gÃ¶sterilir

5. **Oyun**
   - Tile'lara dokunarak hareket ettir
   - Hamle sayÄ±sÄ± takip edilir
   - Ã‡Ã¶zÃ¼ldÃ¼ÄŸÃ¼nde:
     - YÄ±ldÄ±z hesaplanÄ±r
     - Progress kaydedilir
     - Interstitial reklam gÃ¶sterilir
     - Chapter bonus verilir (son level ise)

6. **Hamle Al**
   - Rewarded reklam izle
   - +3 hamle hakkÄ± kazan

## ğŸš€ Ã‡alÄ±ÅŸtÄ±rma

### Development
```bash
npm start
# veya
npx expo start
```

### Platform Specific
```bash
npm run android
npm run ios
npm run web
```

### Cache Temizleme
```bash
npm run reset
# veya
npx expo start --clear
```

## âš ï¸ Ã–nemli Notlar

### Expo Go Limitation
- AdMob native modÃ¼lÃ¼ Expo Go'da Ã§alÄ±ÅŸmaz
- Conditional loading ile uygulama Ã§alÄ±ÅŸÄ±r ama reklamlar gÃ¶sterilmez
- Production build iÃ§in `npx expo prebuild` gerekir (kullanÄ±cÄ± istemiyor)

### Production Build
- AdMob iÃ§in native build gerekli
- `app.json` iÃ§inde AdMob App ID'leri yapÄ±landÄ±rÄ±lmalÄ±
- Test ID'leri production'da deÄŸiÅŸtirilmeli

### Performance
- Tile animasyonlarÄ± optimize edildi (memo, withTiming)
- Board boyutu responsive (tablet/phone)
- Image lazy loading (expo-image)

## ğŸ“ Gelecek GeliÅŸtirmeler

- [ ] Backend entegrasyonu (device ID ile kullanÄ±cÄ± takibi)
- [ ] Leaderboard sistemi
- [ ] Daily challenges
- [ ] Power-ups (shuffle, hint, etc.)
- [ ] Custom image upload
- [ ] Social sharing
- [ ] Achievement sistemi

## ğŸ› Bilinen Sorunlar

- Expo Go'da AdMob Ã§alÄ±ÅŸmaz (beklenen davranÄ±ÅŸ)
- Web platform'da bazÄ± native Ã¶zellikler sÄ±nÄ±rlÄ±

## ğŸ“„ Lisans

MIT

---

**Son GÃ¼ncelleme**: 2024
**Versiyon**: 1.0.0
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.28.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="firebaseConfig.js">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { initializeApp } from "firebase/app";
import { getReactNativePersistence, initializeAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDbw35GvHjcXVdt4x__MCVo6IeaERVuOV4",
  authDomain: "puzzle-game-a5b2a.firebaseapp.com",
  projectId: "puzzle-game-a5b2a",
  storageBucket: "puzzle-game-a5b2a.firebasestorage.app",
  messagingSenderId: "167040071688",
  appId: "1:167040071688:web:9877039f99e61702e579bd",
  measurementId: "G-3SQGX6R0R4"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Initialize Auth with AsyncStorage persistence
const auth = initializeAuth(app, {
  persistence: getReactNativePersistence(AsyncStorage),
});

export { auth, db };
export default app;
</file>

<file path="src/components/ChapterNativeAd.tsx">
import React from "react";
import { Platform, StyleSheet, View } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("ğŸ“º AdMob not available for native ads");
  isAdMobAvailable = false;
}

// ==========================================
// NATIVE AD COMPONENT (Using Medium Rectangle Banner)
// ==========================================

interface ChapterNativeAdProps {
  index: number;
}

const ChapterNativeAd: React.FC<ChapterNativeAdProps> = ({ index }) => {
  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    // Fallback: Show nothing if AdMob not available
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  return (
    <View style={styles.adWrapper}>
      <BannerAd
        unitId={getBannerId()}
        size={BannerAdSize.MEDIUM_RECTANGLE}
        requestOptions={{
          requestNonPersonalizedAdsOnly: false,
        }}
        onAdLoaded={() => {
          console.log("ğŸ“º Chapter ad loaded");
        }}
        onAdFailedToLoad={(error: any) => {
          console.log("ğŸ“º Chapter ad failed:", error);
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  adWrapper: {
    width: "100%",
    alignItems: "center",
    marginVertical: 8,
  },
});

export default ChapterNativeAd;
</file>

<file path="src/components/ConfirmModal.tsx">
import React from "react";
import { Modal, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, { FadeInUp } from "react-native-reanimated";
import { COLORS } from "../constants/gameConfig";

interface ConfirmModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void; // Made optional
  confirmText?: string;
  cancelText?: string;
  isDestructive?: boolean;
}

export default function ConfirmModal({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  confirmText = "Onayla",
  cancelText = "VazgeÃ§",
  isDestructive = false,
}: ConfirmModalProps) {
  if (!visible) return null;

  return (
    <Modal visible={visible} transparent animationType="fade">
      <View style={styles.overlay}>
        <Animated.View entering={FadeInUp.springify()} style={styles.container}>
          <Text style={styles.title}>{title}</Text>
          <Text style={styles.message}>{message}</Text>

          <View style={styles.buttonRow}>
            {onCancel && (
              <TouchableOpacity style={styles.cancelButton} onPress={onCancel}>
                <Text style={styles.cancelText}>{cancelText}</Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={[
                styles.confirmButton,
                isDestructive && styles.destructiveButton,
              ]}
              onPress={onConfirm}
            >
              <Text style={styles.confirmText}>{confirmText}</Text>
            </TouchableOpacity>
          </View>
        </Animated.View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.8)",
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  container: {
    width: "100%",
    maxWidth: 320,
    backgroundColor: COLORS.surface,
    borderRadius: 24,
    padding: 24,
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.5,
    shadowRadius: 20,
    elevation: 10,
  },
  title: {
    fontSize: 20,
    fontWeight: "800",
    color: COLORS.textPrimary,
    marginBottom: 8,
    textAlign: "center",
  },
  message: {
    fontSize: 15,
    color: COLORS.textSecondary,
    textAlign: "center",
    lineHeight: 22,
    marginBottom: 24,
  },
  buttonRow: {
    flexDirection: "row",
    gap: 12,
    width: "100%",
  },
  cancelButton: {
    flex: 1,
    height: 48,
    borderRadius: 12,
    backgroundColor: COLORS.surfaceLight,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  confirmButton: {
    flex: 1,
    height: 48,
    borderRadius: 12,
    backgroundColor: COLORS.accent,
    justifyContent: "center",
    alignItems: "center",
  },
  destructiveButton: {
    backgroundColor: "#FF453A", // iOS system red or a defined error color
  },
  cancelText: {
    color: COLORS.textSecondary,
    fontWeight: "700",
    fontSize: 15,
  },
  confirmText: {
    color: "#000",
    fontWeight: "700",
    fontSize: 15,
  },
});
</file>

<file path="src/components/GameBannerAd.tsx">
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, View } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";
import { useAdActions, useIsBannerReady } from "../store/adStore";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("ğŸ“º AdMob not available for banner");
  isAdMobAvailable = false;
}

// ==========================================
// BANNER AD COMPONENT
// ==========================================

interface GameBannerAdProps {
  onAdLoaded?: () => void;
  onAdFailedToLoad?: () => void;
}

const GameBannerAd: React.FC<GameBannerAdProps> = ({
  onAdLoaded,
  onAdFailedToLoad,
}) => {
  const adActions = useAdActions();
  const isBannerReady = useIsBannerReady();
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (isAdMobAvailable) {
      setIsVisible(true);
    }
  }, []);

  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  const handleAdLoaded = () => {
    console.log("ğŸ“º Banner ad loaded");
    adActions.setBannerReady(true);
    onAdLoaded?.();
  };

  const handleAdFailedToLoad = (error: any) => {
    console.log("ğŸ“º Banner ad failed to load:", error);
    adActions.setBannerReady(false);
    onAdFailedToLoad?.();
  };

  if (!isVisible) return null;

  return (
    <View style={styles.bannerContainer}>
      <BannerAd
        unitId={getBannerId()}
        size={BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
        requestOptions={{
          requestNonPersonalizedAdsOnly: false,
        }}
        onAdLoaded={handleAdLoaded}
        onAdFailedToLoad={handleAdFailedToLoad}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  bannerContainer: {
    width: "100%",
    alignItems: "center",
    backgroundColor: "#000",
  },
});

export default GameBannerAd;
</file>

<file path="src/components/NetworkError.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { COLORS } from "../constants/gameConfig";

interface NetworkErrorProps {
  onRetry: () => void;
  message?: string;
}

export const NetworkError: React.FC<NetworkErrorProps> = ({
  onRetry,
  message = "Veri yÃ¼klenemedi. LÃ¼tfen internet baÄŸlantÄ±nÄ±zÄ± kontrol edip tekrar deneyin.",
}) => {
  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Text style={styles.icon}>ğŸ“¡</Text>
      </View>
      <Text style={styles.title}>BaÄŸlantÄ± HatasÄ±</Text>
      <Text style={styles.message}>{message}</Text>
      <TouchableOpacity
        style={styles.retryButton}
        onPress={onRetry}
        activeOpacity={0.8}
      >
        <Text style={styles.retryText}>Tekrar Dene</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: COLORS.background,
    paddingHorizontal: 24,
  },
  iconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: COLORS.surface,
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 24,
    borderWidth: 1,
    borderColor: COLORS.error,
  },
  icon: {
    fontSize: 32,
  },
  title: {
    fontSize: 24,
    fontWeight: "800",
    color: COLORS.textPrimary,
    marginBottom: 12,
  },
  message: {
    fontSize: 16,
    color: COLORS.textSecondary,
    textAlign: "center",
    marginBottom: 32,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: COLORS.surface,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: COLORS.primary,
  },
  retryText: {
    color: COLORS.textPrimary,
    fontWeight: "700",
    fontSize: 16,
  },
});
</file>

<file path="src/constants/colors.ts">
export const COLORS = {
  // Base colors
  background: "#0a0a0a",
  surface: "#1a1a1a",
  surfaceLight: "#2a2a2a",

  // Text colors
  textPrimary: "#fafafa",
  textSecondary: "#a0a0a0",
  textMuted: "#666666",

  // Accent colors
  primary: "#6366f1",
  accent: "#8b5cf6",

  // Game-specific
  starFilled: "#fbbf24",
  starEmpty: "#4a4a4a",
  border: "#333333",
  overlay: "rgba(0, 0, 0, 0.85)",

  // Functional colors
  success: "#10b981",
  error: "#ef4444",
  warning: "#f59e0b",
};
</file>

<file path="src/constants/data.ts">
const chapters = [
  // --- BAÅLANGIÃ‡: Net Objeler & CanlÄ± Renkler ---
  {
    id: 1,
    name: "Sevimli Dostlar", // Eski: Hayvanlar (Daha sÄ±cak bir isim)
    description: "Kedi, kÃ¶pek ve tÃ¼ylÃ¼ dostlarÄ±n en tatlÄ± halleri",
    color: "#f472b6", // Pembe/SÄ±cak
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?w=400&q=80",
    }, // Kedi
  },
  {
    id: 2,
    name: "Lezzet DuraÄŸÄ±", // Yeni: Yemek/TatlÄ± (Renkler canlÄ±, parÃ§a birleÅŸimi kolay)
    description: "Ä°ÅŸtah kabartan tatlÄ±lar ve meyveler",
    color: "#fb923c", // Turuncu
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1563729784474-d77dbb933a9e?w=400&q=80",
    }, // Cake
  },
  {
    id: 3,
    name: "Retro Objeler", // Yeni: Vintage (Kamera, daktilo vb. net ÅŸekiller)
    description: "Nostaljik eÅŸyalar ve antika detaylar",
    color: "#78716c", // Kahve/Gri
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1550259114-ad7188f0a967?w=400&q=80",
    }, // Retro Car/Camera
  },
  {
    id: 4,
    name: "Renkli Kanatlar", // Eski: KuÅŸlar (Daha spesifik)
    description: "Egzotik kuÅŸlarÄ±n muhteÅŸem tÃ¼yleri",
    color: "#0ea5e9", // GÃ¶kyÃ¼zÃ¼ Mavisi
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1552728089-57bdde30ebd1?w=400&q=80",
    }, // Parrot
  },
  {
    id: 5,
    name: "Botanik BahÃ§e", // Eski: Ã‡iÃ§ekler (Daha makro Ã§ekimler)
    description: "DoÄŸanÄ±n en canlÄ± renk paletleri",
    color: "#22c55e", // YeÅŸil
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1470506028280-a011fb34b6f7?w=400&q=80",
    }, // Flower field
  },

  // --- KEÅÄ°F: Manzaralar & Mimari ---
  {
    id: 6,
    name: "Tropik KaÃ§Ä±ÅŸ", // Eski: Yaz/Plaj
    description: "Turkuaz sular ve palmiye gÃ¶lgeleri",
    color: "#06b6d4", // Cyan
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1596895111956-bf1cf0599ce5?w=400&q=80",
    }, // Maldives
  },
  {
    id: 7,
    name: "Antik Gizemler", // Eski: Antik/Tarihi
    description: "UnutulmuÅŸ tapÄ±naklar ve harabeler",
    color: "#d97706", // AltÄ±n/Toprak
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1564507592333-c60657eea523?w=400&q=80",
    }, // Taj Mahal/Pyramid
  },
  {
    id: 8,
    name: "Neon Sokaklar", // Yeni: Cyberpunk/Tokyo geceleri
    description: "Gece Ä±ÅŸÄ±klarÄ± ve ÅŸehir yansÄ±malarÄ±",
    color: "#8b5cf6", // Mor
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1555680202-c86f0e12f086?w=400&q=80",
    }, // Neon City
  },
  {
    id: 9,
    name: "Sokak SanatÄ±", // Yeni: Graffiti (KarmaÅŸÄ±k ama renkli)
    description: "Duvarlardaki renkli isyan",
    color: "#ec4899", // Hot Pink
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1517713982677-4b6633299833?w=400&q=80",
    }, // Graffiti
  },
  {
    id: 10,
    name: "Masal KÃ¶yleri", // Eski: KÃ¶yler
    description: "Tablo gibi gÃ¶rÃ¼nen ÅŸirin kasabalar",
    color: "#84cc16", // Lime
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1518730518541-d0843268c287?w=400&q=80",
    }, // Hallstatt/Cinque Terre
  },

  // --- ATMOSFER: Doku & Zor Renkler ---
  {
    id: 11,
    name: "Derin Mavi", // Eski: Deniz/Okyanus (SualtÄ± aÄŸÄ±rlÄ±klÄ±)
    description: "Okyanusun altÄ±ndaki sessiz dÃ¼nya",
    color: "#1e40af", // Koyu Mavi
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1582967788606-a171f1080ca8?w=400&q=80",
    }, // Jellyfish/Coral
  },
  {
    id: 12,
    name: "Sonbahar Yolu", // Eski: Sonbahar
    description: "KÄ±zÄ±l yapraklar ve orman patikalarÄ±",
    color: "#ea580c", // YanÄ±k Turuncu
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1507783548227-544c3b8bc210?w=400&q=80",
    }, // Autumn Road
  },
  {
    id: 13,
    name: "Buz KrallÄ±ÄŸÄ±", // Eski: KÄ±ÅŸ (Beyaz aÄŸÄ±rlÄ±klÄ± olduÄŸu iÃ§in zordur)
    description: "Kar taneleri ve buzlu zirveler",
    color: "#cbd5e1", // AÃ§Ä±k Gri/Buz
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1483664852095-d6cc6870705d?w=400&q=80",
    }, // Snow
  },
  {
    id: 14,
    name: "AltÄ±n Saatler", // Eski: GÃ¼n BatÄ±mÄ±
    description: "GÃ¼neÅŸin batarken bÄ±raktÄ±ÄŸÄ± silÃ¼etler",
    color: "#f59e0b", // Amber
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1472120435266-531128262475?w=400&q=80",
    }, // Sunset
  },
  {
    id: 15,
    name: "Makro Evren", // Yeni: BÃ¶cek/GÃ¶z/Doku detaylarÄ±
    description: "GÃ¶zle gÃ¶rÃ¼lmeyen detaylarÄ±n dÃ¼nyasÄ±",
    color: "#10b981", // Emerald
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1550684848-fac1c5b4e853?w=400&q=80",
    }, // Macro Eye/Insect
  },

  // --- SOYUT & FÄ°NAL: En Zor ve En Etkileyici ---
  {
    id: 16,
    name: "Kristal MaÄŸara", // Yeni: TaÅŸlar/Mineraller (KÄ±rÄ±k Ã§izgiler zordur)
    description: "DeÄŸerli taÅŸlar ve Ä±ÅŸÄ±k kÄ±rÄ±lmalarÄ±",
    color: "#6366f1", // Indigo
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1515516089376-88db1e26e9c0?w=400&q=80",
    }, // Crystals
  },
  {
    id: 17,
    name: "Gotik Mimari", // Eski: Mimari (Ama daha karanlÄ±k ve detaylÄ±)
    description: "Katedraller, vitraylar ve detaylar",
    color: "#111827", // Ã‡ok koyu gri
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1548625361-9877039f99e6?w=400&q=80",
    }, // Gothic
  },
  {
    id: 18,
    name: "Soyut RÃ¼ya", // Eski: Sanat (YaÄŸlÄ± boya / Abstract)
    description: "Renklerin ve ÅŸekillerin dansÄ±",
    color: "#db2777", // Koyu Pembe
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1541701494587-cb58502866ab?w=400&q=80",
    }, // Abstract Paint
  },
  {
    id: 19,
    name: "Kuzey IÅŸÄ±klarÄ±", // Yeni: Aurora Borealis (GeÃ§iÅŸli renkler Ã§ok zordur)
    description: "GÃ¶kyÃ¼zÃ¼ndeki bÃ¼yÃ¼lÃ¼ Ä±ÅŸÄ±k dansÄ±",
    color: "#34d399", // YeÅŸil/Mavi karÄ±ÅŸÄ±mÄ±
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1531366936337-7c912a4589a7?w=400&q=80",
    }, // Aurora
  },
  {
    id: 20,
    name: "Sonsuz Uzay", // Eski: Uzay (En zor, siyah boÅŸluklar Ã§ok)
    description: "Galaksiler, nebulalar ve bilinmeyen",
    color: "#4c1d95", // Deep Purple
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1462331940025-496dfbfc7564?w=400&q=80",
    }, // Nebula
  },
];

export default chapters;
</file>

<file path="src/constants/layout.ts">
export const LAYOUT = {
  // Board
  boardPadding: 16,

  // Controls
  controlButtonSize: 70,
  controlButtonRadius: 35,
  controlsBottomOffset: 40,
  controlsGap: 50,

  // Badges
  badgeSize: 20,
  badgeOffset: -4,

  // Buttons
  backButtonSize: 44,
  resetButtonSize: 44,
  previewButtonSize: 48,

  // Header
  levelLabelSize: 24,

  // Stars
  starSize: 24,
  bigStarSize: 44,

  // Moves
  movesSize: 48,

  // Modal
  modalPadding: 24,
  modalMaxWidth: 340,
  modalBorderRadius: 24,

  // Preview
  previewThumbSize: 48,
  previewThumbRadius: 10,

  // Chapter Badge
  chapterBadgeSize: 60,
  chapterBadgeRadius: 30,
};
</file>

<file path="src/constants/uiText.ts">
export const UI_TEXT = {
  winModal: {
    title: "Tebrikler!",
    subtitle: "BulmacayÄ± TamamladÄ±n",
    moves: "Hamle",
    nextLevel: "Sonraki Seviye",
    replay: "Tekrar Oyna",
    backToLevels: "Seviyelere DÃ¶n",
  },
  confirmModals: {
    reset: {
      title: "Yeniden BaÅŸlat",
      message: "BÃ¶lÃ¼m ilerlemeniz sÄ±fÄ±rlanacak. Emin misiniz?",
      confirm: "SÄ±fÄ±rla",
      cancel: "VazgeÃ§",
    },
    watchAd: {
      title: "Hamle Al",
      messageTemplate: "Reklam izleyerek {count} hamle hakkÄ± kazan!",
      confirm: "Reklam Ä°zle",
      cancel: "Ä°ptal",
    },
    alreadySolved: {
      title: "Zaten Ã‡Ã¶zÃ¼ldÃ¼",
      message: "TÃ¼m parÃ§alar doÄŸru yerinde!",
      confirm: "Tamam",
    },
    adSuccess: {
      title: "Tebrikler!",
      messageTemplate: "{count} hamle hakkÄ± kazandÄ±n!",
      confirm: "Harika",
    },
  },
  previewModal: {
    close: "GÄ°ZLE",
  },
  errors: {
    chapterNotFound: "Kategori bulunamadÄ±",
  },
  levels: {
    levelCount: "{completed} / {total} SEVÄ°YE",
  },
};
</file>

<file path="src/services/authService.ts">
import {
  createUserWithEmailAndPassword,
  onAuthStateChanged,
  signInWithEmailAndPassword,
  User,
} from "firebase/auth";
import { auth } from "../../firebaseConfig";
import { getDeviceId } from "./deviceService";

export const loginWithDevice = async (): Promise<User | null> => {
  const deviceId = await getDeviceId();
  const email = `${deviceId}@puzzle.game`;
  const password = `pass_${deviceId.slice(0, 8)}!`; // Cihaza Ã¶zel sabit ÅŸifre

  try {
    // GiriÅŸ yapmayÄ± dene
    const userCredential = await signInWithEmailAndPassword(
      auth,
      email,
      password
    );
    console.log("ğŸ” Firebase: GiriÅŸ baÅŸarÄ±lÄ±", userCredential.user.uid);
    return userCredential.user;
  } catch (error: any) {
    // EÄŸer kullanÄ±cÄ± yoksa yeni oluÅŸtur
    if (
      error.code === "auth/user-not-found" ||
      error.code === "auth/invalid-credential"
    ) {
      try {
        const userCredential = await createUserWithEmailAndPassword(
          auth,
          email,
          password
        );
        console.log(
          "ğŸ” Firebase: Yeni kullanÄ±cÄ± oluÅŸturuldu",
          userCredential.user.uid
        );
        return userCredential.user;
      } catch (createError) {
        console.error("ğŸ” Firebase: KayÄ±t hatasÄ±", createError);
        return null;
      }
    }
    console.error("ğŸ” Firebase: Auth hatasÄ±", error);
    return null;
  }
};

export const getCurrentUser = (): User | null => auth.currentUser;

export const subscribeToAuthChanges = (
  callback: (user: User | null) => void
) => {
  return onAuthStateChanged(auth, callback);
};
</file>

<file path="src/services/dataService.ts">
import {
  collection,
  doc,
  getDoc,
  getDocs,
  orderBy,
  query,
} from "firebase/firestore";
import { db } from "../../firebaseConfig";
import { Chapter, Level } from "../types";

export const fetchChapters = async (): Promise<Chapter[]> => {
  try {
    const chaptersCol = collection(db, "chapters");
    const q = query(chaptersCol, orderBy("id", "asc"));
    const snapshot = await getDocs(q);

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
        } as Chapter)
    );
  } catch (error) {
    console.error("BÃ¶lÃ¼mler Ã§ekilirken hata oluÅŸtu:", error);
    return [];
  }
};

export const fetchLevels = async (chapterId: number): Promise<Level[]> => {
  try {
    const levelsCol = collection(
      db,
      "chapters",
      chapterId.toString(),
      "levels"
    );
    const q = query(levelsCol, orderBy("id", "asc"));
    const snapshot = await getDocs(q);

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
        } as Level)
    );
  } catch (error) {
    console.error("Seviyeler Ã§ekilirken hata oluÅŸtu:", error);
    return [];
  }
};

export const fetchLevelDetails = async (
  chapterId: number,
  levelId: number
): Promise<Level | null> => {
  try {
    const levelDoc = await getDoc(
      doc(db, "chapters", chapterId.toString(), "levels", levelId.toString())
    );
    if (levelDoc.exists()) {
      return levelDoc.data() as Level;
    }
    return null;
  } catch (error) {
    console.error("Seviye detayÄ± Ã§ekilirken hata oluÅŸtu:", error);
    return null;
  }
};
</file>

<file path="src/services/deviceService.ts">
import * as Application from 'expo-application';
import { Platform } from 'react-native';

let cachedDeviceId: string | null = null;

export const getDeviceId = async (): Promise<string> => {
  if (cachedDeviceId) return cachedDeviceId;

  try {
    if (Platform.OS === 'android') {
      cachedDeviceId = Application.getAndroidId() || 'unknown-android';
    } else if (Platform.OS === 'ios') {
      cachedDeviceId = await Application.getIosIdForVendorAsync() || 'unknown-ios';
    } else {
      // Web fallback
      cachedDeviceId = `web-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
  } catch (error) {
    cachedDeviceId = `fallback-${Date.now()}`;
  }

  console.log('ğŸ“± Device ID:', cachedDeviceId);
  return cachedDeviceId;
};

export const getAppInfo = () => {
  return {
    name: Application.applicationName,
    version: Application.nativeApplicationVersion,
    buildVersion: Application.nativeBuildVersion,
  };
};
</file>

<file path="src/services/syncQueue.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import NetInfo from "@react-native-community/netinfo";
import { doc, getDoc, setDoc } from "firebase/firestore";
import { auth, db } from "../../firebaseConfig";

const SYNC_QUEUE_KEY = "@puzzle_sync_queue";

interface QueuedProgress {
  chapterId: number;
  levelId: number;
  moves: number;
  stars: number;
  timestamp: number;
}

/**
 * Add progress to offline sync queue
 */
export const queueProgressUpdate = async (
  chapterId: number,
  levelId: number,
  moves: number,
  stars: number
): Promise<void> => {
  try {
    const queueData = await AsyncStorage.getItem(SYNC_QUEUE_KEY);
    const queue: QueuedProgress[] = queueData ? JSON.parse(queueData) : [];

    const levelKey = `${chapterId}-${levelId}`;

    // Update or add to queue
    const existingIndex = queue.findIndex(
      (item) => `${item.chapterId}-${item.levelId}` === levelKey
    );

    const newItem: QueuedProgress = {
      chapterId,
      levelId,
      moves,
      stars,
      timestamp: Date.now(),
    };

    if (existingIndex >= 0) {
      // Update existing: keep best performance
      const existing = queue[existingIndex];
      queue[existingIndex] = {
        ...newItem,
        stars: Math.max(existing.stars, stars),
        moves: existing.moves === 0 ? moves : Math.min(existing.moves, moves),
      };
    } else {
      queue.push(newItem);
    }

    await AsyncStorage.setItem(SYNC_QUEUE_KEY, JSON.stringify(queue));
    console.log("ğŸ“¦ Queued progress:", levelKey, newItem);
  } catch (error) {
    console.error("Error queueing progress:", error);
  }
};

/**
 * Process sync queue when online
 */
export const processSyncQueue = async (): Promise<void> => {
  try {
    const user = auth.currentUser;
    if (!user) {
      console.log("âš ï¸ No user, skipping sync");
      return;
    }

    const netState = await NetInfo.fetch();
    if (!netState.isConnected) {
      console.log("âš ï¸ Offline, skipping sync");
      return;
    }

    const queueData = await AsyncStorage.getItem(SYNC_QUEUE_KEY);
    if (!queueData) {
      console.log("âœ… No queued progress to sync");
      return;
    }

    const queue: QueuedProgress[] = JSON.parse(queueData);
    if (queue.length === 0) {
      console.log("âœ… Queue empty");
      return;
    }

    console.log(`ğŸ”„ Syncing ${queue.length} queued progress items...`);

    // Get current cloud progress
    const userDoc = await getDoc(doc(db, "users", user.uid));
    const cloudData = userDoc.exists() ? userDoc.data() : {};
    const cloudProgress = cloudData.progress || {
      completedLevels: {},
      totalStars: 0,
      unlockedChapters: [1],
    };

    let totalStarsDiff = 0;
    const updates: any = {};

    // Merge queue with cloud
    for (const item of queue) {
      const levelKey = `${item.chapterId}-${item.levelId}`;
      const cloudLevel = cloudProgress.completedLevels[levelKey];

      let finalStars = item.stars;
      let finalMoves = item.moves;

      if (cloudLevel) {
        // Merge: take max stars, min moves
        finalStars = Math.max(cloudLevel.stars || 0, item.stars);
        finalMoves =
          cloudLevel.bestMoves === 0
            ? item.moves
            : Math.min(cloudLevel.bestMoves, item.moves);

        totalStarsDiff += finalStars - (cloudLevel.stars || 0);
      } else {
        totalStarsDiff += finalStars;
      }

      updates[levelKey] = {
        completed: true,
        stars: finalStars,
        bestMoves: finalMoves,
      };
    }

    // Update Firestore with merged data
    const firestoreUpdate = {
      progress: {
        completedLevels: {
          ...cloudProgress.completedLevels,
          ...updates,
        },
        totalStars: (cloudProgress.totalStars || 0) + totalStarsDiff,
        unlockedChapters: cloudProgress.unlockedChapters || [1],
      },
      lastUpdated: new Date().toISOString(),
    };

    await setDoc(doc(db, "users", user.uid), firestoreUpdate, { merge: true });

    // Clear queue
    await AsyncStorage.removeItem(SYNC_QUEUE_KEY);
    console.log(`âœ… Synced ${queue.length} items, cleared queue`);
  } catch (error) {
    console.error("âŒ Sync queue error:", error);
  }
};

/**
 * Setup network listener to auto-sync when online
 */
export const setupSyncListener = (): (() => void) => {
  const unsubscribe = NetInfo.addEventListener((state) => {
    if (state.isConnected) {
      console.log("ğŸŒ Network connected, processing sync queue...");
      processSyncQueue();
    }
  });

  // Process immediately if online
  NetInfo.fetch().then((state) => {
    if (state.isConnected) {
      processSyncQueue();
    }
  });

  return unsubscribe;
};
</file>

<file path="src/store/adStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";

// ==========================================
// AD CONFIGURATION
// ==========================================

export const AD_RULES = {
  // Interstitial rules
  interstitial: {
    excludedLevels: [
      { chapterId: 1, levelId: 1 },
      { chapterId: 1, levelId: 2 },
      { chapterId: 1, levelId: 3 },
      { chapterId: 1, levelId: 4 },
    ],
    minTimeBetweenAds: 300000, // 5 minutes between interstitial ads
    showOnLevelEntry: true, // Show when entering a level (not on completion)
  },

  // Rewarded rules
  rewarded: {
    enabled: true, // Rewarded ads for hints
  },

  // Banner rules
  banner: {
    showInGame: true, // Show banner at top of game screen
    showInChapters: false, // Don't show banner in chapters (use native ads instead)
  },

  // Native ads rules
  native: {
    showInChapters: true, // Show native ad in chapters screen
    showEveryNChapters: 4, // Show ad after every 4 chapters
  },
};

// ==========================================
// AD STATE INTERFACE
// ==========================================

interface AdState {
  // Last shown timestamps
  lastInterstitialShown: number;
  lastRewardedShown: number;

  // Ad readiness
  isInterstitialReady: boolean;
  isRewardedReady: boolean;
  isBannerReady: boolean;

  // Statistics
  totalInterstitialsShown: number;
  totalRewardedsShown: number;
  totalBannersShown: number;
}

interface AdActions {
  // Interstitial
  canShowInterstitial: (chapterId: number, levelId: number) => boolean;
  markInterstitialShown: () => void;
  setInterstitialReady: (ready: boolean) => void;

  // Rewarded
  canShowRewarded: () => boolean;
  markRewardedShown: () => void;
  setRewardedReady: (ready: boolean) => void;

  // Banner
  canShowBanner: () => boolean;
  setBannerReady: (ready: boolean) => void;

  // Native
  shouldShowNativeAdAtIndex: (index: number) => boolean;

  // Persistence
  loadAdState: () => Promise<void>;
  saveAdState: () => Promise<void>;
}

interface AdStore extends AdState {
  actions: AdActions;
}

// ==========================================
// STORAGE KEY
// ==========================================

const AD_STATE_KEY = "@puzzle_game_ad_state";

// ==========================================
// INITIAL STATE
// ==========================================

const initialState: AdState = {
  lastInterstitialShown: 0,
  lastRewardedShown: 0,
  isInterstitialReady: false,
  isRewardedReady: false,
  isBannerReady: false,
  totalInterstitialsShown: 0,
  totalRewardedsShown: 0,
  totalBannersShown: 0,
};

// ==========================================
// AD STORE
// ==========================================

export const useAdStore = create<AdStore>((set, get) => ({
  ...initialState,

  actions: {
    // ==========================================
    // INTERSTITIAL ADS
    // ==========================================

    canShowInterstitial: (chapterId: number, levelId: number) => {
      const state = get();

      // Check if this level is excluded
      const isExcluded = AD_RULES.interstitial.excludedLevels.some(
        (excluded) =>
          excluded.chapterId === chapterId && excluded.levelId === levelId,
      );

      if (isExcluded) {
        console.log(`ğŸ“º Level ${chapterId}-${levelId} is excluded from ads`);
        return false;
      }

      // Check if enough time has passed
      const now = Date.now();
      const timeSinceLastAd = now - state.lastInterstitialShown;
      if (timeSinceLastAd < AD_RULES.interstitial.minTimeBetweenAds) {
        const remainingSeconds = Math.ceil(
          (AD_RULES.interstitial.minTimeBetweenAds - timeSinceLastAd) / 1000,
        );
        console.log(`ğŸ“º Too soon for ad, wait ${remainingSeconds}s`);
        return false;
      }

      // Check if ad is ready
      if (!state.isInterstitialReady) {
        console.log("ğŸ“º Interstitial not ready");
        return false;
      }

      return true;
    },

    markInterstitialShown: () => {
      const now = Date.now();
      set((state) => ({
        lastInterstitialShown: now,
        totalInterstitialsShown: state.totalInterstitialsShown + 1,
        isInterstitialReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setInterstitialReady: (ready: boolean) => {
      set({ isInterstitialReady: ready });
    },

    // ==========================================
    // REWARDED ADS
    // ==========================================

    canShowRewarded: () => {
      const state = get();

      if (!AD_RULES.rewarded.enabled) {
        console.log("ğŸ Rewarded ads disabled");
        return false;
      }

      if (!state.isRewardedReady) {
        console.log("ğŸ Rewarded not ready");
        return false;
      }

      return true;
    },

    markRewardedShown: () => {
      const now = Date.now();
      set((state) => ({
        lastRewardedShown: now,
        totalRewardedsShown: state.totalRewardedsShown + 1,
        isRewardedReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setRewardedReady: (ready: boolean) => {
      set({ isRewardedReady: ready });
    },

    // ==========================================
    // BANNER ADS
    // ==========================================

    canShowBanner: () => {
      const state = get();
      return AD_RULES.banner.showInGame && state.isBannerReady;
    },

    setBannerReady: (ready: boolean) => {
      set({ isBannerReady: ready });
    },

    // ==========================================
    // NATIVE ADS
    // ==========================================

    shouldShowNativeAdAtIndex: (index: number) => {
      if (!AD_RULES.native.showInChapters) return false;

      // Show ad every N chapters (e.g., after chapter 4, 8, 12, etc.)
      // Index is 0-based, so we add 1
      const chapterNumber = index + 1;
      return chapterNumber % AD_RULES.native.showEveryNChapters === 0;
    },

    // ==========================================
    // PERSISTENCE
    // ==========================================

    loadAdState: async () => {
      try {
        const stored = await AsyncStorage.getItem(AD_STATE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          set({
            lastInterstitialShown: parsed.lastInterstitialShown || 0,
            lastRewardedShown: parsed.lastRewardedShown || 0,
            totalInterstitialsShown: parsed.totalInterstitialsShown || 0,
            totalRewardedsShown: parsed.totalRewardedsShown || 0,
            totalBannersShown: parsed.totalBannersShown || 0,
          });
          console.log("ğŸ“º Ad state loaded from storage");
        }
      } catch (error) {
        console.error("ğŸ“º Failed to load ad state:", error);
      }
    },

    saveAdState: async () => {
      try {
        const state = get();
        const toSave = {
          lastInterstitialShown: state.lastInterstitialShown,
          lastRewardedShown: state.lastRewardedShown,
          totalInterstitialsShown: state.totalInterstitialsShown,
          totalRewardedsShown: state.totalRewardedsShown,
          totalBannersShown: state.totalBannersShown,
        };
        await AsyncStorage.setItem(AD_STATE_KEY, JSON.stringify(toSave));
      } catch (error) {
        console.error("ğŸ“º Failed to save ad state:", error);
      }
    },
  },
}));

// ==========================================
// HOOKS
// ==========================================

export const useAdActions = () => useAdStore((state) => state.actions);
export const useIsInterstitialReady = () =>
  useAdStore((state) => state.isInterstitialReady);
export const useIsRewardedReady = () =>
  useAdStore((state) => state.isRewardedReady);
export const useIsBannerReady = () =>
  useAdStore((state) => state.isBannerReady);
</file>

<file path="src/store/hintStore.ts">
import { create } from 'zustand';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { STORAGE_KEYS, HINT_CONFIG } from '../constants/gameConfig';

interface HintState {
  hintCount: number;
  isLoaded: boolean;
}

interface HintActions {
  loadHints: () => Promise<void>;
  saveHints: () => Promise<void>;
  useHint: () => boolean;
  addHints: (amount: number) => void;
  addChapterBonus: () => void;
  resetHints: () => void;
}

interface HintStore extends HintState {
  actions: HintActions;
}

export const useHintStore = create<HintStore>((set, get) => ({
  hintCount: HINT_CONFIG.defaultHints,
  isLoaded: false,

  actions: {
    loadHints: async () => {
      try {
        const stored = await AsyncStorage.getItem(STORAGE_KEYS.HINT_COUNT);
        if (stored) {
          set({ hintCount: parseInt(stored, 10), isLoaded: true });
        } else {
          set({ isLoaded: true });
        }
      } catch {
        set({ isLoaded: true });
      }
    },

    saveHints: async () => {
      try {
        const { hintCount } = get();
        await AsyncStorage.setItem(STORAGE_KEYS.HINT_COUNT, hintCount.toString());
      } catch {}
    },

    useHint: () => {
      const { hintCount } = get();
      if (hintCount <= 0) return false;

      set({ hintCount: hintCount - 1 });
      get().actions.saveHints();
      return true;
    },

    addHints: (amount: number) => {
      const { hintCount } = get();
      set({ hintCount: hintCount + amount });
      get().actions.saveHints();
    },

    addChapterBonus: () => {
      get().actions.addHints(HINT_CONFIG.chapterBonus);
    },

    resetHints: () => {
      set({ hintCount: HINT_CONFIG.defaultHints });
      get().actions.saveHints();
    },
  },
}));

export const useHintCount = () => useHintStore((state) => state.hintCount);
export const useHintActions = () => useHintStore((state) => state.actions);
</file>

<file path="src/store/progressStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { doc, getDoc, setDoc } from "firebase/firestore";
import { create } from "zustand";
import { auth, db } from "../../firebaseConfig";
import {
  calculateStars,
  LEVELS_PER_CHAPTER,
  STORAGE_KEYS,
} from "../constants/gameConfig";
import { GridSize, LevelProgress, UserProgress } from "../types";

interface ProgressState {
  progress: UserProgress;
  isLoaded: boolean;
}

interface ProgressActions {
  loadProgress: () => Promise<void>;
  saveProgress: () => Promise<void>;
  completeLevel: (
    chapterId: number,
    levelId: number,
    moves: number,
    gridSize: GridSize
  ) => void;
  setLastPlayed: (chapterId: number, levelId: number) => void;
  isLevelUnlocked: (chapterId: number, levelId: number) => boolean;
  isChapterUnlocked: (chapterId: number) => boolean;
  getLevelProgress: (
    chapterId: number,
    levelId: number
  ) => LevelProgress | null;
  getChapterProgress: (chapterId: number) => {
    completed: number;
    total: number;
    stars: number;
  };
  getLastPlayed: () => { chapterId: number; levelId: number } | null;
}

interface ProgressStore extends ProgressState {
  actions: ProgressActions;
}

const createInitialProgress = (): UserProgress => ({
  unlockedChapters: [1],
  completedLevels: {},
  totalStars: 0,
  lastPlayed: undefined,
});

const getLevelKey = (chapterId: number, levelId: number): string =>
  `${chapterId}-${levelId}`;

export const useProgressStore = create<ProgressStore>((set, get) => ({
  progress: createInitialProgress(),
  isLoaded: false,

  actions: {
    loadProgress: async () => {
      try {
        const stored = await AsyncStorage.getItem(STORAGE_KEYS.USER_PROGRESS);
        if (stored) {
          set({ progress: JSON.parse(stored), isLoaded: true });
        }

        const currentUser = auth?.currentUser;
        if (currentUser) {
          console.log("ğŸ” Loading progress for user:", currentUser.uid);
          const userDoc = await getDoc(doc(db, "users", currentUser.uid));
          if (userDoc.exists()) {
            const cloudData = userDoc.data();
            console.log(
              "â˜ï¸ Raw cloud data:",
              JSON.stringify(cloudData, null, 2)
            );

            // Convert flat Firestore structure to nested object
            // Firestore stores: "progress.completedLevels.1-2": {...}
            // We need: { progress: { completedLevels: { "1-2": {...} } } }
            const convertFlatToNested = (flatData: any): any => {
              const result: any = {};

              for (const key in flatData) {
                if (key.startsWith("progress.")) {
                  const parts = key.split(".");
                  let current = result;

                  for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    if (!current[part]) {
                      current[part] = {};
                    }
                    current = current[part];
                  }

                  current[parts[parts.length - 1]] = flatData[key];
                } else if (key !== "lastUpdated") {
                  result[key] = flatData[key];
                }
              }

              return result;
            };

            const nestedData = convertFlatToNested(cloudData);
            console.log(
              "ğŸ”„ Converted to nested:",
              JSON.stringify(nestedData, null, 2)
            );

            // Ensure we have all required fields with defaults
            const cloudProgress: UserProgress = {
              completedLevels: nestedData?.progress?.completedLevels || {},
              totalStars: nestedData?.progress?.totalStars || 0,
              unlockedChapters: nestedData?.progress?.unlockedChapters || [1],
              lastPlayed: nestedData?.progress?.lastPlayed,
            };

            console.log("ğŸ“Š Parsed cloudProgress:", {
              completedLevelsCount: Object.keys(
                cloudProgress.completedLevels || {}
              ).length,
              totalStars: cloudProgress.totalStars,
              unlockedChapters: cloudProgress.unlockedChapters,
            });

            // Basic validation to ensure we don't wipe local state with empty cloud state if cloud is empty
            // But here we trust cloud if it has data.
            // Check if cloud has meaningful data (e.g. at least one level unlocked/completed)
            if (
              cloudProgress.completedLevels &&
              Object.keys(cloudProgress.completedLevels).length > 0
            ) {
              console.log("âœ… Setting cloud progress to state");
              set({ progress: cloudProgress, isLoaded: true });
              await AsyncStorage.setItem(
                STORAGE_KEYS.USER_PROGRESS,
                JSON.stringify(cloudProgress)
              );
            } else {
              console.log("âš ï¸ Cloud progress empty, keeping local data");
            }
          } else {
            console.log("âŒ User document does not exist");
          }
        } else {
          console.log("âŒ No current user");
        }
        set({ isLoaded: true });
      } catch (error) {
        console.error("Progress yÃ¼kleme hatasÄ±:", error);
        set({ isLoaded: true });
      }
    },

    // saveProgress removed - dangerous as it overwrites entire object

    completeLevel: async (
      chapterId: number,
      levelId: number,
      moves: number,
      gridSize: GridSize
    ) => {
      const { progress } = get();
      const levelKey = getLevelKey(chapterId, levelId);
      const stars = calculateStars(moves, gridSize);
      const existingProgress = progress.completedLevels[levelKey];

      const newLevelProgress: LevelProgress = {
        completed: true,
        bestMoves: existingProgress
          ? Math.min(existingProgress.bestMoves, moves)
          : moves,
        stars: existingProgress
          ? Math.max(existingProgress.stars, stars)
          : stars,
      };

      const starDiff = newLevelProgress.stars - (existingProgress?.stars || 0);

      let newChapterUnlocked = false;
      let nextChapterId = chapterId + 1;

      let newProgress = {
        ...progress,
        completedLevels: {
          ...progress.completedLevels,
          [levelKey]: newLevelProgress,
        },
        totalStars: progress.totalStars + starDiff,
      };

      if (
        levelId === LEVELS_PER_CHAPTER &&
        !progress.unlockedChapters.includes(nextChapterId)
      ) {
        newProgress.unlockedChapters = [
          ...newProgress.unlockedChapters,
          nextChapterId,
        ].sort((a, b) => a - b);
        newChapterUnlocked = true;
      }

      // Update Local State
      set({ progress: newProgress });
      // Update Local Storage
      await AsyncStorage.setItem(
        STORAGE_KEYS.USER_PROGRESS,
        JSON.stringify(newProgress)
      );

      // Update Cloud with proper nested structure
      const user = auth.currentUser;
      if (user) {
        try {
          // Build proper nested structure instead of dot notation
          const cloudUpdate = {
            progress: {
              completedLevels: {
                [levelKey]: newLevelProgress,
              },
              totalStars: newProgress.totalStars,
              unlockedChapters: newProgress.unlockedChapters,
            },
            lastUpdated: new Date().toISOString(),
          };

          console.log("ğŸ’¾ Saving to cloud:", levelKey, newLevelProgress);

          // Use setDoc with merge to update nested fields properly
          await setDoc(doc(db, "users", user.uid), cloudUpdate, {
            merge: true,
          });
        } catch (e) {
          console.error("Cloud level save error:", e);
          // Queue for offline sync
          const { queueProgressUpdate } = await import("../services/syncQueue");
          await queueProgressUpdate(
            chapterId,
            levelId,
            newLevelProgress.bestMoves,
            newLevelProgress.stars
          );
        }
      }
    },

    setLastPlayed: async (chapterId: number, levelId: number) => {
      const { progress } = get();
      const lastPlayed = { chapterId, levelId };
      const newProgress = { ...progress, lastPlayed };

      set({ progress: newProgress });
      await AsyncStorage.setItem(
        STORAGE_KEYS.USER_PROGRESS,
        JSON.stringify(newProgress)
      );

      const user = auth.currentUser;
      if (user) {
        try {
          await setDoc(
            doc(db, "users", user.uid),
            {
              progress: {
                lastPlayed: lastPlayed,
              },
              lastUpdated: new Date().toISOString(),
            },
            { merge: true }
          );
        } catch (e) {
          console.error("Last played save error:", e);
        }
      }
    },

    isLevelUnlocked: (chapterId: number, levelId: number) => {
      const { progress } = get();
      if (!progress.unlockedChapters.includes(chapterId)) return false;
      if (levelId === 1) return true;
      const prevLevelKey = getLevelKey(chapterId, levelId - 1);
      return progress.completedLevels[prevLevelKey]?.completed ?? false;
    },

    isChapterUnlocked: (chapterId: number) => {
      return get().progress.unlockedChapters.includes(chapterId);
    },

    getLevelProgress: (chapterId: number, levelId: number) => {
      return (
        get().progress.completedLevels[getLevelKey(chapterId, levelId)] ?? null
      );
    },

    getChapterProgress: (chapterId: number) => {
      const { progress } = get();
      let completed = 0;
      let stars = 0;

      for (let i = 1; i <= LEVELS_PER_CHAPTER; i++) {
        const levelProgress =
          progress.completedLevels[getLevelKey(chapterId, i)];
        if (levelProgress?.completed) {
          completed++;
          stars += levelProgress.stars;
        }
      }

      return { completed, total: LEVELS_PER_CHAPTER, stars };
    },

    getLastPlayed: () => {
      const { progress } = get();
      return progress.lastPlayed ?? null;
    },

    // Kept for interface compatibility but warns
    saveProgress: async () => {
      console.warn(
        "Generic saveProgress is deprecated to prevent data loss. Use granular actions."
      );
    },
  },
}));

export const useProgressActions = () =>
  useProgressStore((state) => state.actions);
export const useTotalStars = () =>
  useProgressStore((state) => state.progress.totalStars);
export const useLastPlayed = () =>
  useProgressStore((state) => state.progress.lastPlayed);
</file>

<file path="src/utils/puzzleLogic.ts">
import { GridSize, TilePosition } from "../types";

export const createSolvedGrid = (gridSize: GridSize): number[] => {
  const totalTiles = gridSize.cols * gridSize.rows;
  return Array.from({ length: totalTiles }, (_, i) => i);
};

export const indexToPosition = (
  index: number,
  gridSize: GridSize
): TilePosition => ({
  row: Math.floor(index / gridSize.cols),
  col: index % gridSize.cols,
});

export const positionToIndex = (
  position: TilePosition,
  gridSize: GridSize
): number => {
  return position.row * gridSize.cols + position.col;
};

export const getAdjacentIndices = (
  index: number,
  gridSize: GridSize
): number[] => {
  const { row, col } = indexToPosition(index, gridSize);
  const adjacent: number[] = [];

  if (row > 0) adjacent.push(positionToIndex({ row: row - 1, col }, gridSize));
  if (row < gridSize.rows - 1)
    adjacent.push(positionToIndex({ row: row + 1, col }, gridSize));
  if (col > 0) adjacent.push(positionToIndex({ row, col: col - 1 }, gridSize));
  if (col < gridSize.cols - 1)
    adjacent.push(positionToIndex({ row, col: col + 1 }, gridSize));

  return adjacent;
};

export const canMoveTile = (
  tileIndex: number,
  emptyIndex: number,
  gridSize: GridSize
): boolean => {
  return getAdjacentIndices(emptyIndex, gridSize).includes(tileIndex);
};

export const swapTiles = (
  grid: number[],
  index1: number,
  index2: number
): number[] => {
  const newGrid = [...grid];
  [newGrid[index1], newGrid[index2]] = [newGrid[index2], newGrid[index1]];
  return newGrid;
};

export const performMove = (
  grid: number[],
  tileIndex: number,
  emptyIndex: number,
  gridSize: GridSize
): { grid: number[]; emptyIndex: number; moved: boolean } => {
  if (!canMoveTile(tileIndex, emptyIndex, gridSize)) {
    return { grid, emptyIndex, moved: false };
  }
  const newGrid = swapTiles(grid, tileIndex, emptyIndex);
  return { grid: newGrid, emptyIndex: tileIndex, moved: true };
};

export const shuffleGrid = (
  gridSize: GridSize
): { grid: number[]; emptyIndex: number } => {
  let grid = createSolvedGrid(gridSize);
  const totalTiles = gridSize.cols * gridSize.rows;
  let emptyIndex = totalTiles - 1;
  const moves = totalTiles * 5; // Dynamic shuffle count
  let lastMove = -1;

  for (let i = 0; i < moves; i++) {
    const adjacent = getAdjacentIndices(emptyIndex, gridSize);
    const validMoves = adjacent.filter((idx) => idx !== lastMove);
    const randomIndex = Math.floor(Math.random() * validMoves.length);
    const tileToMove = validMoves[randomIndex];
    lastMove = emptyIndex;
    grid = swapTiles(grid, tileToMove, emptyIndex);
    emptyIndex = tileToMove;
  }

  return { grid, emptyIndex };
};

export const isSolved = (grid: number[]): boolean => {
  for (let i = 0; i < grid.length; i++) {
    if (grid[i] !== i) return false;
  }
  return true;
};

export const getProgressPercentage = (grid: number[]): number => {
  let correct = 0;
  for (let i = 0; i < grid.length; i++) {
    if (grid[i] === i) correct++;
  }
  return Math.round((correct / grid.length) * 100);
};

export const calculateTilePosition = (
  index: number,
  gridSize: GridSize,
  tileSize: number,
  gap: number
): { x: number; y: number } => {
  const { row, col } = indexToPosition(index, gridSize);
  return {
    x: col * (tileSize + gap),
    y: row * (tileSize + gap),
  };
};

export const calculateImageOffset = (
  tileValue: number,
  gridSize: GridSize,
  tileSize: number
): { top: number; left: number } => {
  const { row, col } = indexToPosition(tileValue, gridSize);
  return {
    top: -(row * tileSize),
    left: -(col * tileSize),
  };
};
</file>

<file path="app/chapters.tsx">
import { Image } from "expo-image";
import { Stack, useRouter } from "expo-router";
import React from "react";
import {
  ActivityIndicator,
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, { FadeInDown } from "react-native-reanimated";
import ChapterNativeAd from "../src/components/ChapterNativeAd";
import {
  BOARD_PADDING,
  COLORS,
  getGridColumns,
} from "../src/constants/gameConfig";
import { useAdActions } from "../src/store/adStore";
import {
  useChapters,
  useDataActions,
  useIsDataLoading,
} from "../src/store/dataStore";
import { useProgressActions, useTotalStars } from "../src/store/progressStore";
import { Chapter } from "../src/types";

interface ChapterCardProps {
  chapter: Chapter;
  index: number;
  isUnlocked: boolean;
  progress: { completed: number; total: number; stars: number };
  cardWidth: number;
  onPress: () => void;
}

const ChapterCard: React.FC<ChapterCardProps> = ({
  chapter,
  index,
  isUnlocked,
  progress,
  cardWidth,
  onPress,
}) => {
  const progressPercent = (progress.completed / progress.total) * 100;

  return (
    <Animated.View
      entering={FadeInDown.delay(index * 40).springify()}
      style={{ width: cardWidth }}
    >
      <TouchableOpacity
        style={[styles.card, !isUnlocked && styles.cardLocked]}
        onPress={onPress}
        disabled={!isUnlocked}
        activeOpacity={0.7}
      >
        {/* Thumbnail Section */}
        <View style={styles.thumbnailArea}>
          <Image
            source={chapter.thumbnail}
            style={styles.thumbnail}
            contentFit="cover"
          />
          <View style={styles.overlay} />
          <View style={styles.idBadge}>
            <Text style={styles.idBadgeTxt}>{chapter.id}</Text>
          </View>
          {!isUnlocked && (
            <View style={styles.lockedArea}>
              <Text style={styles.lockIc}>ğŸ”’</Text>
            </View>
          )}
        </View>

        {/* Content Section */}
        <View style={styles.infoArea}>
          <Text style={styles.name} numberOfLines={1}>
            {chapter.name}
          </Text>
          <View style={styles.progressRow}>
            <View style={styles.barBg}>
              <View
                style={[styles.barFill, { width: `${progressPercent}%` }]}
              />
            </View>
            <Text style={styles.progressStats}>
              {progress.completed}/{progress.total}
            </Text>
          </View>
          <View style={styles.starInfo}>
            <Text style={styles.starIc}>â˜…</Text>
            <Text style={styles.starVal}>{progress.stars}</Text>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

export default function ChaptersScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const totalStars = useTotalStars();
  const progressActions = useProgressActions();
  const chapters = useChapters();
  const { getChapters } = useDataActions();
  const isLoading = useIsDataLoading();
  const adActions = useAdActions();

  React.useEffect(() => {
    getChapters();
  }, []);

  const numColumns = getGridColumns(width);
  const padding = BOARD_PADDING;
  const gap = 15;
  const cardWidth = (width - padding * 2 - gap * (numColumns - 1)) / numColumns;

  // Create rows of chapters with ads inserted at appropriate positions
  const listData = React.useMemo(() => {
    const rows: Array<{ type: "row" | "ad"; items?: Chapter[]; id: string }> =
      [];
    let currentRow: Chapter[] = [];

    chapters.forEach((chapter, index) => {
      currentRow.push(chapter);

      // When row is full or it's the last chapter
      if (currentRow.length === numColumns || index === chapters.length - 1) {
        rows.push({
          type: "row",
          items: [...currentRow],
          id: `row-${rows.length}`,
        });
        currentRow = [];
      }

      // Add ad after every 4th chapter
      if (adActions.shouldShowNativeAdAtIndex(index)) {
        rows.push({
          type: "ad",
          id: `ad-${index}`,
        });
      }
    });

    return rows;
  }, [chapters, numColumns, adActions]);

  if (isLoading && chapters.length === 0) {
    return (
      <View style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: "BÃ¶lÃ¼mler",
          headerStyle: { backgroundColor: COLORS.background },
          headerTintColor: COLORS.textPrimary,
          headerShadowVisible: false,
          headerRight: () => (
            <View style={styles.headerStars}>
              <Text style={styles.headerStarIcon}>â˜…</Text>
              <Text style={styles.headerStarText}>{totalStars}</Text>
            </View>
          ),
        }}
      />

      <FlatList
        data={listData}
        renderItem={({ item }) => {
          if (item.type === "ad") {
            return <ChapterNativeAd index={parseInt(item.id.split("-")[1])} />;
          }

          // Render row of chapters
          return (
            <View style={[styles.chapterRow, { gap }]}>
              {item.items?.map((chapter, idx) => (
                <ChapterCard
                  key={chapter.id}
                  chapter={chapter}
                  index={chapters.indexOf(chapter)}
                  isUnlocked={progressActions.isChapterUnlocked(chapter.id)}
                  progress={progressActions.getChapterProgress(chapter.id)}
                  cardWidth={cardWidth}
                  onPress={() => router.push(`/levels/${chapter.id}`)}
                />
              ))}
            </View>
          );
        }}
        keyExtractor={(item) => item.id}
        contentContainerStyle={[styles.listContent, { padding }]}
        ItemSeparatorComponent={() => <View style={{ height: gap }} />}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background },
  centered: { justifyContent: "center", alignItems: "center" },
  chapterRow: {
    flexDirection: "row",
    justifyContent: "flex-start",
  },
  headerStars: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.surface,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  headerStarIcon: { fontSize: 16, color: COLORS.starFilled },
  headerStarText: {
    fontSize: 15,
    fontWeight: "800",
    color: COLORS.textPrimary,
  },
  listContent: { paddingBottom: 40 },
  card: {
    backgroundColor: COLORS.surface,
    borderRadius: 20,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  cardLocked: { opacity: 0.6 },
  thumbnailArea: { aspectRatio: 1.5, position: "relative" },
  thumbnail: { width: "100%", height: "100%" },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.2)",
  },
  idBadge: {
    position: "absolute",
    top: 10,
    left: 10,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: COLORS.background,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: COLORS.border,
  },
  idBadgeTxt: { color: COLORS.textPrimary, fontWeight: "900", fontSize: 13 },
  lockedArea: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
  },
  lockIc: { fontSize: 32 },
  infoArea: { padding: 15, gap: 10 },
  name: { fontSize: 18, fontWeight: "800", color: COLORS.textPrimary },
  progressRow: { flexDirection: "row", alignItems: "center", gap: 10 },
  barBg: {
    flex: 1,
    height: 6,
    backgroundColor: COLORS.surfaceLight,
    borderRadius: 3,
    overflow: "hidden",
  },
  barFill: { height: "100%", backgroundColor: COLORS.accent },
  progressStats: {
    fontSize: 11,
    color: COLORS.textSecondary,
    fontWeight: "700",
  },
  starInfo: { flexDirection: "row", alignItems: "center", gap: 5 },
  starIc: { fontSize: 14, color: COLORS.starFilled },
  starVal: { fontSize: 14, color: COLORS.textPrimary, fontWeight: "700" },
});
</file>

<file path="app/index.tsx">
import { Stack, useRouter } from "expo-router";
import React from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, { FadeInDown, FadeInUp } from "react-native-reanimated";
import { SafeAreaView } from "react-native-safe-area-context";
import {
  BOARD_PADDING,
  COLORS,
  HINT_CONFIG,
  LEVELS_PER_CHAPTER,
  getResponsiveValue,
} from "../src/constants/gameConfig";
import { showRewarded } from "../src/services/adManager";
import {
  useChapters,
  useDataActions,
  useIsDataLoading,
} from "../src/store/dataStore";
import { useHintActions, useHintCount } from "../src/store/hintStore";
import { useLastPlayed, useTotalStars } from "../src/store/progressStore";

export default function StartScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const totalStars = useTotalStars();
  const lastPlayed = useLastPlayed();
  const hintCount = useHintCount();
  const hintActions = useHintActions();
  const chapters = useChapters();
  const { getChapters, getChapterById } = useDataActions();
  const isLoading = useIsDataLoading();

  React.useEffect(() => {
    getChapters();
  }, []);

  const totalChapterCount = chapters.length || 20; // Fallback
  const maxStars = totalChapterCount * LEVELS_PER_CHAPTER * 3;

  const buttonWidth = getResponsiveValue(width, {
    phone: "85%",
    tablet: 320 as any,
  });

  const handleContinue = () => {
    if (lastPlayed) {
      router.push(`/game/${lastPlayed.chapterId}/${lastPlayed.levelId}`);
    } else {
      router.push("/game/1/1");
    }
  };

  const handleChapters = () => {
    router.push("/chapters");
  };

  const handleGetHints = async () => {
    const success = await showRewarded();
    if (success) {
      hintActions.addHints(HINT_CONFIG.rewardedAdHints);
    }
  };

  const lastChapter = lastPlayed ? getChapterById(lastPlayed.chapterId) : null;

  return (
    <SafeAreaView style={styles.container}>
      <Stack.Screen
        options={{
          headerShown: true,
          title: "",
          headerStyle: { backgroundColor: COLORS.background },
          headerShadowVisible: false,
          headerRight: () => (
            <TouchableOpacity
              style={styles.hintButton}
              onPress={handleGetHints}
              activeOpacity={0.7}
            >
              <Text style={styles.hintIcon}>ğŸ’¡</Text>
              <View style={styles.hintBadge}>
                <Text style={styles.hintBadgeText}>{hintCount}</Text>
              </View>
            </TouchableOpacity>
          ),
        }}
      />

      <View style={styles.content}>
        {/* Logo */}
        <Animated.View
          entering={FadeInDown.delay(100).springify()}
          style={styles.logoContainer}
        >
          <View style={styles.logoIcon}>
            <View style={styles.logoGrid}>
              {[...Array(9)].map((_, i) => (
                <View
                  key={i}
                  style={[
                    styles.logoTile,
                    i === 8 ? styles.logoTileEmpty : null,
                  ]}
                />
              ))}
            </View>
          </View>
          <Text style={styles.title}>PUZZLE</Text>
        </Animated.View>

        {/* Stats Row */}
        <Animated.View
          entering={FadeInDown.delay(200).springify()}
          style={styles.statsRow}
        >
          <View style={styles.statBadge}>
            <Text style={styles.statIcon}>â˜…</Text>
            <Text style={styles.statValue}>{totalStars}</Text>
          </View>
          <View style={styles.statBadge}>
            <Text style={styles.statIcon}>ğŸ’¡</Text>
            <Text style={styles.statValue}>{hintCount}</Text>
          </View>
        </Animated.View>

        {/* Buttons */}
        <Animated.View
          entering={FadeInUp.delay(300).springify()}
          style={[styles.buttonsContainer, { width: buttonWidth as any }]}
        >
          {/* Continue Button */}
          <TouchableOpacity
            style={styles.continueButton}
            onPress={handleContinue}
            activeOpacity={0.8}
          >
            <View style={styles.continueContent}>
              <Text style={styles.continueTitle}>Devam Et</Text>
              {lastPlayed && lastChapter && (
                <Text style={styles.continueSubtitle}>
                  {lastChapter.name} â€¢ Seviye {lastPlayed.levelId}
                </Text>
              )}
              {!lastPlayed && (
                <Text style={styles.continueSubtitle}>Yeni Oyun BaÅŸlat</Text>
              )}
            </View>
            <Text style={styles.continueArrow}>â†’</Text>
          </TouchableOpacity>

          {/* Chapters Button */}
          <TouchableOpacity
            style={styles.chaptersButton}
            onPress={handleChapters}
            activeOpacity={0.8}
          >
            <Text style={styles.chaptersButtonText}>BÃ¶lÃ¼mler</Text>
            {isLoading ? (
              <ActivityIndicator size="small" color={COLORS.textSecondary} />
            ) : (
              <Text style={styles.chaptersCount}>{totalChapterCount}</Text>
            )}
          </TouchableOpacity>
        </Animated.View>

        {/* Progress */}
        <Animated.View
          entering={FadeInUp.delay(400)}
          style={styles.progressContainer}
        >
          <View style={styles.progressBar}>
            <View
              style={[
                styles.progressFill,
                { width: `${(totalStars / maxStars) * 100}%` },
              ]}
            />
          </View>
          <Text style={styles.progressText}>
            {totalStars} / {maxStars} yÄ±ldÄ±z
          </Text>
        </Animated.View>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  content: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: BOARD_PADDING,
  },
  logoContainer: {
    alignItems: "center",
    marginBottom: 32,
  },
  logoIcon: {
    width: 88,
    height: 88,
    backgroundColor: COLORS.surface,
    borderRadius: 20,
    padding: 12,
    marginBottom: 20,
    borderWidth: 2,
    borderColor: COLORS.primary,
  },
  logoGrid: {
    flex: 1,
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 4,
  },
  logoTile: {
    width: "30%",
    aspectRatio: 1,
    backgroundColor: COLORS.primary,
    borderRadius: 4,
  },
  logoTileEmpty: {
    backgroundColor: "transparent",
  },
  title: {
    fontSize: 42,
    fontWeight: "800",
    color: COLORS.textPrimary,
    letterSpacing: 6,
  },
  statsRow: {
    flexDirection: "row",
    gap: 16,
    marginBottom: 48,
  },
  statBadge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.surface,
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 24,
    gap: 8,
  },
  statIcon: {
    fontSize: 18,
  },
  statValue: {
    fontSize: 18,
    fontWeight: "700",
    color: COLORS.textPrimary,
  },
  buttonsContainer: {
    gap: 12,
    marginBottom: 48,
  },
  continueButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 18,
    paddingHorizontal: 24,
    borderRadius: 16,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  continueContent: {
    flex: 1,
  },
  continueTitle: {
    color: COLORS.textPrimary,
    fontSize: 18,
    fontWeight: "700",
  },
  continueSubtitle: {
    color: COLORS.textPrimary,
    fontSize: 13,
    opacity: 0.8,
    marginTop: 2,
  },
  continueArrow: {
    color: COLORS.textPrimary,
    fontSize: 24,
    fontWeight: "300",
  },
  chaptersButton: {
    backgroundColor: COLORS.surface,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 16,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  chaptersButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  chaptersCount: {
    color: COLORS.textSecondary,
    fontSize: 14,
    backgroundColor: COLORS.surfaceLight,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
  },
  progressContainer: {
    alignItems: "center",
    width: "60%",
  },
  progressBar: {
    width: "100%",
    height: 4,
    backgroundColor: COLORS.surface,
    borderRadius: 2,
    overflow: "hidden",
    marginBottom: 8,
  },
  progressFill: {
    height: "100%",
    backgroundColor: COLORS.starFilled,
    borderRadius: 2,
  },
  progressText: {
    color: COLORS.textMuted,
    fontSize: 12,
  },
  hintButton: {
    marginRight: 12,
    position: "relative",
  },
  hintIcon: {
    fontSize: 28,
  },
  hintBadge: {
    position: "absolute",
    top: -4,
    right: -4,
    backgroundColor: COLORS.accent,
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 4,
  },
  hintBadgeText: {
    color: COLORS.textPrimary,
    fontSize: 11,
    fontWeight: "900",
  },
});
</file>

<file path="metro.config.js">
const { getDefaultConfig } = require("expo/metro-config");

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

config.resolver.sourceExts.push("mjs");
config.resolver.assetExts.push("lottie"); // Add .lottie support

module.exports = config;
</file>

<file path="src/components/DevPanel.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { doc, writeBatch } from "firebase/firestore";
import { getDownloadURL, getStorage, ref } from "firebase/storage";
import React, { useState } from "react";
import {
  Alert,
  Modal,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { db } from "../../firebaseConfig";
import { COLORS, getGridSizeForLevel } from "../constants/gameConfig";
import { useGameStore } from "../store/gameStore";
import { useHintActions } from "../store/hintStore";
import { useProgressActions } from "../store/progressStore";
import { createSolvedGrid } from "../utils/puzzleLogic";

const uploadLevelsToFirebase = async (targetChapterId: string) => {
  const storage = getStorage();
  const batch = writeBatch(db);

  const FILE_EXTENSION = ".jpg";
  const FOLDER_NAME = `chapter-${targetChapterId}-levels`; // Dynamic folder name

  try {
    console.log(
      `â³ Level yÃ¼klemesi baÅŸlÄ±yor... Chapter: ${targetChapterId}, Folder: ${FOLDER_NAME}`,
    );

    const promises = Array.from({ length: 24 }, (_, i) => i + 1).map(
      async (levelId) => {
        // 1. Storage path: "chapter-1-levels/level-1.jpg"
        const fileName = `level-${levelId}${FILE_EXTENSION}`;
        const storageRef = ref(storage, `${FOLDER_NAME}/${fileName}`);

        let downloadUrl = "";
        try {
          downloadUrl = await getDownloadURL(storageRef);
          console.log(`âœ… Level ${levelId} resmi bulundu`);
        } catch (err) {
          console.error(`âŒ Level ${levelId} resmi YOK: ${fileName}`);
          downloadUrl = "https://via.placeholder.com/500";
        }

        // 2. Prepare Data
        const gridSize = getGridSizeForLevel(levelId);
        const levelData = {
          id: levelId,
          chapterId: Number(targetChapterId),
          gridSize: gridSize,
          imageSource: { uri: downloadUrl },
          moves: 0, // Reset logic or default
          stars: 0,
        };

        // 3. Firestore Ref: chapters/{id}/levels/{levelId}
        const levelDocRef = doc(
          db,
          "chapters",
          targetChapterId,
          "levels",
          levelId.toString(),
        );
        batch.set(levelDocRef, levelData, { merge: true });
      },
    );

    // Wait for all
    await Promise.all(promises);

    // Commit batch
    await batch.commit();

    alert(`Chapter ${targetChapterId} iÃ§in 24 level yÃ¼klendi! ğŸš€`);
  } catch (error) {
    console.error("Level Upload HatasÄ±:", error);
    alert("Hata oluÅŸtu, konsola bak.");
  }
};

const DevPanel: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [chapterId, setChapterId] = useState("1");
  const [levelId, setLevelId] = useState("1");
  const router = useRouter();
  const gameStore = useGameStore();
  const hintActions = useHintActions();
  const progressActions = useProgressActions();

  const goToLevel = () => {
    const cId = parseInt(chapterId) || 1;
    const lId = parseInt(levelId) || 1;
    router.push(`/game/${cId}/${lId}`);
    setIsOpen(false);
  };

  const solveGame = () => {
    const { gridSize } = gameStore;
    if (gridSize && gridSize.cols > 0 && gridSize.rows > 0) {
      const solvedGrid = createSolvedGrid(gridSize);
      const emptyIndex = gridSize.cols * gridSize.rows - 1;
      useGameStore.setState({
        currentGrid: solvedGrid,
        emptySlotIndex: emptyIndex,
        isSolved: true,
      });

      // Reset isSolved after win modal triggers to prevent ghost wins
      setTimeout(() => {
        useGameStore.setState({ isSolved: false });
      }, 100);
    }
    setIsOpen(false);
  };

  const addHints = () => {
    hintActions.addHints(1000);
    setIsOpen(false);
  };

  const clearStorage = async () => {
    Alert.alert(
      "TÃ¼m Veriyi Sil",
      "AsyncStorage'daki TÃœM veriler silinecek (progress, hints, level states). Emin misiniz?",
      [
        { text: "Ä°ptal", style: "cancel" },
        {
          text: "Sil",
          style: "destructive",
          onPress: async () => {
            try {
              await AsyncStorage.clear();
              Alert.alert(
                "BaÅŸarÄ±lÄ±",
                "TÃ¼m veriler silindi. Uygulama yeniden baÅŸlatÄ±lÄ±yor...",
              );
              setIsOpen(false);
              // Reload app
              setTimeout(() => {
                router.replace("/");
              }, 500);
            } catch (error) {
              Alert.alert("Hata", "Veri silinirken hata oluÅŸtu: " + error);
            }
          },
        },
      ],
    );
  };

  return (
    <>
      <TouchableOpacity
        style={styles.floatingButton}
        onPress={() => setIsOpen(true)}
        activeOpacity={0.8}
      >
        <Text style={styles.floatingButtonText}>ğŸ› </Text>
      </TouchableOpacity>

      <Modal visible={isOpen} transparent animationType="fade">
        <View style={styles.overlay}>
          <View style={styles.panel}>
            <Text style={styles.title}>Dev Panel</Text>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Level'e Git</Text>
              <View style={styles.inputRow}>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>BÃ¶lÃ¼m</Text>
                  <TextInput
                    style={styles.input}
                    value={chapterId}
                    onChangeText={setChapterId}
                    keyboardType="number-pad"
                    placeholder="1-20"
                    placeholderTextColor={COLORS.textMuted}
                  />
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>Level</Text>
                  <TextInput
                    style={styles.input}
                    value={levelId}
                    onChangeText={setLevelId}
                    keyboardType="number-pad"
                    placeholder="1-24"
                    placeholderTextColor={COLORS.textMuted}
                  />
                </View>
              </View>
              <TouchableOpacity
                style={styles.button}
                onPress={goToLevel}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>Git</Text>
              </TouchableOpacity>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>HÄ±zlÄ± Aksiyonlar</Text>
              <TouchableOpacity
                style={[styles.button, styles.solveButton]}
                onPress={solveGame}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ¯ Puzzle'Ä± Ã‡Ã¶z</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.hintButton]}
                onPress={addHints}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ’¡ +10 Hamle HakkÄ±</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.clearButton]}
                onPress={clearStorage}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ—‘ï¸ Storage Temizle</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.clearButton]}
                onPress={() => uploadLevelsToFirebase(chapterId)}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>Firebase'a YÃ¼kle (Levels)</Text>
              </TouchableOpacity>
            </View>

            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setIsOpen(false)}
              activeOpacity={0.8}
            >
              <Text style={styles.closeButtonText}>Kapat</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </>
  );
};

const styles = StyleSheet.create({
  floatingButton: {
    position: "absolute",
    bottom: 100,
    right: 16,
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: "#ef4444",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 9999,
    elevation: 10,
  },
  floatingButtonText: { fontSize: 20 },
  overlay: {
    flex: 1,
    backgroundColor: COLORS.overlay,
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  panel: {
    backgroundColor: COLORS.surface,
    borderRadius: 16,
    padding: 24,
    width: "100%",
    maxWidth: 320,
    borderWidth: 2,
    borderColor: "#ef4444",
  },
  title: {
    fontSize: 20,
    fontWeight: "700",
    color: "#ef4444",
    textAlign: "center",
    marginBottom: 20,
  },
  section: { marginBottom: 20, gap: 10 },
  sectionTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: COLORS.textSecondary,
    marginBottom: 8,
  },
  inputRow: { flexDirection: "row", gap: 12 },
  inputGroup: { flex: 1 },
  inputLabel: { fontSize: 12, color: COLORS.textMuted, marginBottom: 4 },
  input: {
    backgroundColor: COLORS.background,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    color: COLORS.textPrimary,
    fontSize: 16,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  button: {
    backgroundColor: COLORS.primary,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: "center",
  },
  solveButton: { backgroundColor: "#22c55e" },
  hintButton: { backgroundColor: COLORS.accent },
  clearButton: { backgroundColor: "#ef4444" },
  migrateButton: { backgroundColor: "#6366f1" },
  buttonText: { color: COLORS.textPrimary, fontSize: 14, fontWeight: "600" },
  closeButton: { paddingVertical: 12, alignItems: "center" },
  closeButtonText: { color: COLORS.textMuted, fontSize: 14 },
});

export default DevPanel;
</file>

<file path="src/components/PuzzleBoard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { BOARD_PADDING, COLORS, TILE_GAP } from "../constants/gameConfig";
import { useGameStore } from "../store/gameStore";
import { GridSize, ImageSource } from "../types";
import Tile from "./Tile";

interface PuzzleBoardProps {
  grid: number[];
  gridSize: GridSize;
  imageSource: ImageSource;
  onTilePress: (index: number) => void;
  boardSize?: number;
}

const PuzzleBoard: React.FC<PuzzleBoardProps> = ({
  grid,
  gridSize,
  imageSource,
  onTilePress,
  boardSize: propBoardSize,
}) => {
  const boardWidth = propBoardSize ? propBoardSize - BOARD_PADDING * 2 : 340;
  // Calculate tile size based on width and columns
  const totalGapX = TILE_GAP * (gridSize.cols - 1);
  const tileSize = (boardWidth - totalGapX) / gridSize.cols;

  // Calculate height based on rows
  const totalGapY = TILE_GAP * (gridSize.rows - 1);
  const boardHeight = tileSize * gridSize.rows + totalGapY;

  const emptyTileValue = gridSize.cols * gridSize.rows - 1;
  const hintedTiles = useGameStore((state) => state.hintedTiles);

  const tiles = useMemo(() => {
    return grid.map((value, index) => (
      <Tile
        key={value}
        index={index}
        value={value}
        gridSize={gridSize}
        tileSize={tileSize} // Pass pre-calculated size
        imageSource={imageSource}
        isEmpty={value === emptyTileValue}
        isHinted={hintedTiles.includes(value)}
        onPress={onTilePress}
      />
    ));
  }, [
    grid,
    gridSize,
    tileSize,
    imageSource,
    emptyTileValue,
    onTilePress,
    hintedTiles,
  ]);

  return (
    <View style={styles.container}>
      <View style={[styles.board, { width: boardWidth, height: boardHeight }]}>
        {tiles}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center",
    padding: BOARD_PADDING,
  },
  board: {
    backgroundColor: COLORS.surface,
    borderRadius: 6, // Reduced from 16 to match TILE_BORDER_RADIUS
    overflow: "hidden",
    position: "relative",
  },
});

export default PuzzleBoard;
</file>

<file path="src/components/Tile.tsx">
import { Image } from "expo-image";
import React, { memo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";
import { COLORS, TILE_BORDER_RADIUS, TILE_GAP } from "../constants/gameConfig";
import { GridSize, ImageSource } from "../types";
import {
  calculateImageOffset,
  calculateTilePosition,
} from "../utils/puzzleLogic";

interface TileProps {
  index: number;
  value: number;
  gridSize: GridSize;
  tileSize: number;
  imageSource: ImageSource;
  isEmpty: boolean;
  isHinted?: boolean;
  onPress: (index: number) => void;
}

const AnimatedTouchable = Animated.createAnimatedComponent(TouchableOpacity);

const Tile: React.FC<TileProps> = ({
  index,
  value,
  gridSize,
  tileSize,
  imageSource,
  isEmpty,
  isHinted,
  onPress,
}) => {
  const position = calculateTilePosition(index, gridSize, tileSize, TILE_GAP);
  const imageOffset = calculateImageOffset(value, gridSize, tileSize);
  const scale = useSharedValue(1);

  const animatedContainerStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: withTiming(position.x, { duration: 120 }) },
      { translateY: withTiming(position.y, { duration: 120 }) },
      { scale: scale.value },
    ],
  }));

  const handlePressIn = () => {
    scale.value = withTiming(0.95, { duration: 100 });
  };

  const handlePressOut = () => {
    scale.value = withTiming(1, { duration: 100 });
  };

  if (isEmpty) return null;

  return (
    <AnimatedTouchable
      style={[
        styles.tileContainer,
        { width: tileSize, height: tileSize },
        animatedContainerStyle,
      ]}
      onPress={() => onPress(index)}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      activeOpacity={0.9}
    >
      <View
        style={[styles.imageContainer, { borderRadius: TILE_BORDER_RADIUS }]}
      >
        <Image
          source={imageSource}
          style={[
            styles.image,
            {
              width: gridSize.cols * tileSize + (gridSize.cols - 1) * TILE_GAP, // Approx full image width
              height: gridSize.rows * tileSize + (gridSize.rows - 1) * TILE_GAP,
              top: imageOffset.top,
              left: imageOffset.left,
            },
          ]}
          contentFit="cover"
          transition={0}
        />
      </View>
      <View
        style={[
          styles.borderOverlay,
          { borderRadius: TILE_BORDER_RADIUS },
          // Green border if tile is in correct position
          value === index && {
            borderColor: "#22c55e",
            borderWidth: 3,
          },
        ]}
      />
      {/* Show position indicator for hinted tiles in wrong position */}
      {isHinted && value !== index && (
        <View style={styles.positionOverlay}>
          <Text style={styles.positionText}>
            {Math.floor(value / gridSize.cols) + 1}-
            {(value % gridSize.cols) + 1}
          </Text>
        </View>
      )}
    </AnimatedTouchable>
  );
};

const styles = StyleSheet.create({
  tileContainer: { position: "absolute" },
  imageContainer: { flex: 1, overflow: "hidden" },
  image: { position: "absolute" },
  borderOverlay: {
    ...StyleSheet.absoluteFillObject,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  positionOverlay: {
    position: "absolute",
    bottom: 2,
    alignSelf: "center",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    paddingHorizontal: 6,
    paddingVertical: 4,
    borderRadius: 6,
  },
  positionText: {
    color: "#fff",
    fontSize: 12,
    fontWeight: "900",
  },
});

export default memo(Tile, (prev, next) => {
  return (
    prev.index === next.index &&
    prev.value === next.value &&
    prev.isEmpty === next.isEmpty &&
    prev.gridSize.cols === next.gridSize.cols &&
    prev.gridSize.rows === next.gridSize.rows &&
    prev.tileSize === next.tileSize &&
    prev.isHinted === next.isHinted
  );
});
</file>

<file path="src/components/WinModal.tsx">
import { DotLottie } from "@lottiefiles/dotlottie-react-native";
import React, { useEffect } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, {
  Easing,
  FadeIn,
  ZoomIn, // Changed from SlideInDown
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated";
import { COLORS } from "../constants/gameConfig";

interface WinModalProps {
  visible: boolean;
  moves: number;
  stars: number;
  isLastLevel: boolean;
  chapterColor?: string;
  hasNextChapter?: boolean;
  onNextLevel: () => void;
  onReplay: () => void;
  onBackToLevels: () => void;
}

const Star: React.FC<{ delay: number }> = ({ delay }) => (
  <Animated.View entering={ZoomIn.delay(delay).springify()}>
    <DotLottie
      source={require("../assets/animations/star.lottie")}
      autoplay
      loop
      style={{ width: 90, height: 90 }}
    />
  </Animated.View>
);

const WinModal: React.FC<WinModalProps> = ({
  visible,
  moves,
  stars,
  isLastLevel,
  hasNextChapter,
  chapterColor,
  onNextLevel,
  onReplay,
  onBackToLevels,
}) => {
  const accentColor = chapterColor || COLORS.primary;
  const scale = useSharedValue(1);

  useEffect(() => {
    if (visible) {
      scale.value = withRepeat(
        withSequence(
          withTiming(1.1, { duration: 500, easing: Easing.ease }),
          withTiming(1, { duration: 500, easing: Easing.ease }),
        ),
        -1,
        true,
      );
    } else {
      scale.value = 1;
    }
  }, [visible]);

  const animatedTitleStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  if (!visible) return null; // Don't render if not visible

  return (
    <View style={[StyleSheet.absoluteFill, styles.overlayWrapper]}>
      <View style={styles.overlay}>
        <Animated.View
          entering={FadeIn.duration(300)}
          style={styles.modalContainer}
        >
          <Animated.Text style={[styles.title, animatedTitleStyle]}>
            Tebrikler!
          </Animated.Text>
          <Text style={styles.subtitle}>BulmacayÄ± TamamladÄ±n</Text>

          {/* Stars Container - Only render earned stars */}
          <View style={styles.starsContainer}>
            {Array.from({ length: stars }).map((_, index) => (
              <Star key={index} delay={index * 300} />
            ))}
          </View>

          <View style={styles.statsContainer}>
            <Text style={[styles.statValue, { color: accentColor }]}>
              {moves}
            </Text>
            <Text style={styles.statLabel}>Hamle</Text>
          </View>

          <View style={styles.buttonsContainer}>
            {(!isLastLevel || hasNextChapter) && (
              <TouchableOpacity
                style={[
                  styles.button,
                  styles.primaryButton,
                  { backgroundColor: accentColor },
                ]}
                onPress={onNextLevel}
                activeOpacity={0.8}
              >
                <Text style={styles.primaryButtonText}>
                  {isLastLevel ? "Sonraki BÃ¶lÃ¼m" : "Sonraki Seviye"}
                </Text>
              </TouchableOpacity>
            )}
            <TouchableOpacity
              style={[styles.button, styles.secondaryButton]}
              onPress={onReplay}
              activeOpacity={0.8}
            >
              <Text style={styles.secondaryButtonText}>Tekrar Oyna</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.button}
              onPress={onBackToLevels}
              activeOpacity={0.8}
            >
              <Text style={styles.tertiaryButtonText}>Seviyelere DÃ¶n</Text>
            </TouchableOpacity>
          </View>
        </Animated.View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  overlayWrapper: {
    zIndex: 9999, // Ensure it sits on top of everything
    elevation: 9999, // For Android
  },
  overlay: {
    flex: 1,
    backgroundColor: COLORS.overlay,
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  modalContainer: {
    backgroundColor: COLORS.surface,
    borderRadius: 24,
    padding: 32,
    width: "100%",
    maxWidth: 340,
    alignItems: "center",
  },
  lottieContainer: {
    marginBottom: 20,
    alignItems: "center",
    justifyContent: "center",
  },
  title: {
    fontSize: 28,
    fontWeight: "700",
    color: COLORS.textPrimary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 15,
    color: COLORS.textSecondary,
    marginBottom: 24,
  },
  starsContainer: {
    flexDirection: "row",
    marginBottom: 24,
    gap: 8,
    justifyContent: "center", // Centered content
  },
  star: {
    fontSize: 44,
    color: COLORS.starEmpty,
  },
  starFilled: {
    color: COLORS.starFilled,
  },
  statsContainer: {
    alignItems: "center",
    marginBottom: 32,
  },
  statValue: {
    fontSize: 40,
    fontWeight: "700",
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  buttonsContainer: {
    width: "100%",
    gap: 10,
  },
  button: {
    paddingVertical: 14,
    paddingHorizontal: 24,
    borderRadius: 14,
    alignItems: "center",
  },
  primaryButton: {},
  primaryButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  secondaryButton: {
    backgroundColor: COLORS.surfaceLight,
  },
  secondaryButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  tertiaryButtonText: {
    color: COLORS.textMuted,
    fontSize: 14,
  },
});

export default WinModal;
</file>

<file path="src/constants/gameConfig.ts">
import { GridSize } from "../types";

export const LEVELS_PER_CHAPTER = 24;
export const TOTAL_CHAPTERS = 20;

// SHUFFLE_MOVES logic moved to puzzleLogic dynamic calculation

export const getGridSizeForLevel = (levelIndex: number): GridSize => {
  if (levelIndex <= 8) return { cols: 3, rows: 4 };
  if (levelIndex <= 16) return { cols: 4, rows: 5 };
  return { cols: 5, rows: 6 };
};

export const normalizeGridSize = (
  size: GridSize | number | undefined,
): GridSize => {
  if (!size) return { cols: 3, rows: 4 }; // Default to 3x4
  if (typeof size === "number") {
    // Legacy mapping: N -> N cols x (N+1) rows (Vertical)
    return { cols: size, rows: size + 1 };
  }
  return size;
};

// ==========================================
// RESPONSIVE BREAKPOINTS
// ==========================================

export const BREAKPOINTS = {
  phone: 0,
  tablet: 768,
  desktop: 1024,
};

export const getDeviceType = (
  width: number,
): "phone" | "tablet" | "desktop" => {
  if (width >= BREAKPOINTS.desktop) return "desktop";
  if (width >= BREAKPOINTS.tablet) return "tablet";
  return "phone";
};

export const getResponsiveValue = <T>(
  width: number,
  values: { phone: T; tablet: T; desktop?: T },
): T => {
  const type = getDeviceType(width);
  if (type === "desktop") return values.desktop ?? values.tablet;
  if (type === "tablet") return values.tablet;
  return values.phone;
};

// ==========================================
// COLORS - Re-exported from centralized file
// ==========================================

export { COLORS } from "./colors";

// ==========================================
// LAYOUT - Re-exported from centralized file
// ==========================================

export { LAYOUT } from "./layout";

// ==========================================
// UI CONSTANTS
// ==========================================

export const BOARD_PADDING = 12; // Kept for backward compatibility, use LAYOUT.boardPadding
export const TILE_GAP = 2;
export const TILE_BORDER_RADIUS = 6;

export const getBoardSize = (screenWidth: number): number => {
  const maxBoardSize = screenWidth - BOARD_PADDING * 2;
  return maxBoardSize;
};

export const getGridColumns = (screenWidth: number): number => {
  return getResponsiveValue(screenWidth, { phone: 2, tablet: 3, desktop: 4 });
};

// ==========================================
// HINT SYSTEM
// ==========================================

export const HINT_CONFIG = {
  defaultHints: 10,
  chapterBonus: 5,
  rewardedAdHints: 10, // AdMob'da ayarlanan Ã¶dÃ¼l miktarÄ±
};

// ==========================================
// AD CONFIG
// ==========================================

// Test Ad IDs (for development)
const TEST_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-3940256099942544/1033173712",
    ios: "ca-app-pub-3940256099942544/4411468910",
  },
  rewarded: {
    android: "ca-app-pub-3940256099942544/5224354917",
    ios: "ca-app-pub-3940256099942544/1712485313",
  },
  banner: {
    android: "ca-app-pub-3940256099942544/6300978111",
    ios: "ca-app-pub-3940256099942544/2934735716",
  },
  native: {
    android: "ca-app-pub-3940256099942544/2247696110",
    ios: "ca-app-pub-3940256099942544/3986624511",
  },
};

// Production Ad IDs (for release builds)
const PROD_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-5502183878891798/5198222798",
    ios: "ca-app-pub-5502183878891798/3827454899",
  },
  rewarded: {
    android: "ca-app-pub-5502183878891798/3109269595",
    ios: "ca-app-pub-5502183878891798/2514373229",
  },
  banner: {
    android: "ca-app-pub-5502183878891798/4422351261",
    ios: "ca-app-pub-5502183878891798/2934735716",
  },
  native: {
    android: "ca-app-pub-5502183878891798/2705944917",
    ios: "ca-app-pub-5502183878891798/8494276450",
  },
};

// Automatically switch between test and production IDs
export const AD_CONFIG = __DEV__ ? TEST_AD_CONFIG : PROD_AD_CONFIG;

// ==========================================
// STORAGE KEYS
// ==========================================

export const STORAGE_KEYS = {
  USER_PROGRESS: "@puzzle_game_progress",
  HINT_COUNT: "@puzzle_game_hints",
  LAST_PLAYED: "@puzzle_game_last_played",
  DEVICE_ID: "@puzzle_game_device_id",
  LEVEL_STATE: "@puzzle_game_level_state",
};

// CHAPTER DATA handles moved to DataStore/Service
// generateChapters ve CHAPTERS kaldÄ±rÄ±ldÄ±.

// ==========================================
// STAR RATING SYSTEM (Difficulty Based)
// ==========================================

export const STAR_THRESHOLDS: Record<string, { gold: number; silver: number }> =
  {
    // Vertical grids (N x N+1)
    "1x2": { gold: 1, silver: 2 }, // 2 tiles
    "2x3": { gold: 15, silver: 30 }, // 6 tiles
    "3x4": { gold: 30, silver: 60 }, // 12 tiles
    "4x5": { gold: 60, silver: 120 }, // 20 tiles
    "5x6": { gold: 90, silver: 180 }, // 30 tiles
    "6x7": { gold: 120, silver: 240 }, // 42 tiles
    "7x8": { gold: 150, silver: 300 }, // 56 tiles
    "8x9": { gold: 180, silver: 360 }, // 72 tiles
    "9x10": { gold: 210, silver: 420 }, // 90 tiles
    "10x11": { gold: 240, silver: 480 }, // 110 tiles
  };

export const calculateStars = (moves: number, gridSize: GridSize): number => {
  const key = `${gridSize.cols}x${gridSize.rows}`;
  const threshold = STAR_THRESHOLDS[key] || {
    gold: gridSize.cols * gridSize.rows * 4,
    silver: gridSize.cols * gridSize.rows * 6,
  };

  if (moves <= threshold.gold) return 3;
  if (moves <= threshold.silver) return 2;
  return 1;
};
</file>

<file path="src/hooks/usePuzzleGame.ts">
import { useCallback, useEffect, useRef } from "react";
import { AppState, AppStateStatus } from "react-native";
import { normalizeGridSize } from "../constants/gameConfig";
import { useGameActions, useGameStore } from "../store/gameStore";
import { useProgressActions } from "../store/progressStore";
import { Level } from "../types";
import { getProgressPercentage } from "../utils/puzzleLogic";

interface UsePuzzleGameOptions {
  level?: Level;
  onWin?: (moves: number) => void;
}

export const usePuzzleGame = ({ level, onWin }: UsePuzzleGameOptions) => {
  const gameState = useGameStore();
  const gameActions = useGameActions();
  const progressActions = useProgressActions();
  const appState = useRef(AppState.currentState);

  const {
    currentGrid,
    emptySlotIndex,
    moveCount,
    isSolved,
    gridSize,
    isInitialized,
    hintedTiles,
  } = gameState;

  // Initialize or Resume
  useEffect(() => {
    if (level) {
      // Prevent ghost wins from previous level interactions
      gameActions.prepareGame();

      const initOrResume = async () => {
        const normalizedSize = normalizeGridSize(level.gridSize);
        const resumed = await gameActions.loadLevelState(
          level.chapterId,
          level.id,
          normalizedSize,
        );
        if (!resumed) {
          gameActions.initializeGame(normalizedSize);
        }
      };
      initOrResume();
    }
  }, [level?.id, level?.chapterId, level?.gridSize]);

  // Auto-save on AppState change
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      if (
        appState.current === "active" &&
        nextAppState.match(/inactive|background/)
      ) {
        // App is going to background, save state
        if (level && isInitialized && !isSolved) {
          gameActions.saveLevelState(level.chapterId, level.id);
        }
      }
      appState.current = nextAppState;
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange,
    );

    return () => {
      subscription.remove();
    };
  }, [level, isInitialized, isSolved, gameActions]);

  const progress = isInitialized ? getProgressPercentage(currentGrid) : 0;

  const handleTilePress = useCallback(
    (index: number) => {
      if (isSolved) return;
      const moved = gameActions.moveTile(index);

      // Check win condition after move
      if (moved) {
        // Get updated state after move
        const updatedState = useGameStore.getState();
        if (updatedState.isSolved && updatedState.isInitialized) {
          if (level) {
            gameActions.clearLevelState(level.chapterId, level.id);
          }
          onWin?.(updatedState.moveCount);
        }
      }
    },
    [isSolved, gameActions, level, onWin],
  );

  const resetGame = useCallback(() => {
    if (level) {
      gameActions.clearLevelState(level.chapterId, level.id);
    }
    gameActions.resetGame();
  }, [gameActions, level]);

  const completeAndSave = useCallback(() => {
    if (isSolved && level) {
      progressActions.completeLevel(
        level.chapterId,
        level.id,
        moveCount,
        normalizeGridSize(level.gridSize),
      );
    }
  }, [isSolved, level, moveCount, progressActions]);

  return {
    grid: currentGrid,
    emptySlotIndex,
    moveCount,
    isSolved,
    gridSize: gridSize || normalizeGridSize(level?.gridSize),
    isInitialized,
    progress,
    hintedTiles,
    handleTilePress,
    resetGame,
    useHint: gameActions.useHint,
    saveState: () =>
      level && gameActions.saveLevelState(level.chapterId, level.id),
    completeAndSave,
  };
};
</file>

<file path="src/services/adManager.ts">
import { Platform } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";
import { useAdStore } from "../store/adStore";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let InterstitialAd: any = null;
let RewardedAd: any = null;
let AdEventType: any = null;
let RewardedAdEventType: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  InterstitialAd = admob.InterstitialAd;
  RewardedAd = admob.RewardedAd;
  AdEventType = admob.AdEventType;
  RewardedAdEventType = admob.RewardedAdEventType;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
  console.log("ğŸ“º AdMob module loaded");
} catch (error) {
  console.log("ğŸ“º AdMob not available (Expo Go or not configured)");
  isAdMobAvailable = false;
}

// ==========================================
// AD UNIT IDS
// ==========================================

const getInterstitialId = () => {
  if (__DEV__ && TestIds) return TestIds.INTERSTITIAL;
  return Platform.OS === "ios"
    ? AD_CONFIG.interstitial.ios
    : AD_CONFIG.interstitial.android;
};

const getRewardedId = () => {
  if (__DEV__ && TestIds) return TestIds.REWARDED;
  return Platform.OS === "ios"
    ? AD_CONFIG.rewarded.ios
    : AD_CONFIG.rewarded.android;
};

// ==========================================
// AD INSTANCES
// ==========================================

let interstitialAd: any = null;
let rewardedAd: any = null;
let isInterstitialLoaded = false;
let isRewardedLoaded = false;

// ==========================================
// INTERSTITIAL ADS
// ==========================================

export const loadInterstitial = () => {
  if (!isAdMobAvailable || !InterstitialAd) {
    console.log("ğŸ“º AdMob not available, skipping interstitial load");
    return;
  }

  try {
    interstitialAd = InterstitialAd.createForAdRequest(getInterstitialId());

    interstitialAd.addAdEventListener(AdEventType.LOADED, () => {
      isInterstitialLoaded = true;
      useAdStore.getState().actions.setInterstitialReady(true);
      console.log("ğŸ“º Interstitial loaded");
    });

    interstitialAd.addAdEventListener(AdEventType.CLOSED, () => {
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
      loadInterstitial(); // Preload next
    });

    interstitialAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("ğŸ“º Interstitial error:", error);
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
    });

    interstitialAd.load();
  } catch (error) {
    console.log("ğŸ“º Interstitial init error:", error);
  }
};

export const showInterstitial = async (): Promise<boolean> => {
  if (!isAdMobAvailable || !isInterstitialLoaded || !interstitialAd) {
    console.log("ğŸ“º Interstitial not ready");
    return false;
  }

  return new Promise((resolve) => {
    try {
      interstitialAd.show();
      useAdStore.getState().actions.markInterstitialShown();
      resolve(true);
    } catch (error) {
      console.log("ğŸ“º Interstitial show error:", error);
      resolve(false);
    }
  });
};

// ==========================================
// REWARDED ADS
// ==========================================

export const loadRewarded = () => {
  if (!isAdMobAvailable || !RewardedAd) {
    console.log("ğŸ“º AdMob not available, skipping rewarded load");
    return;
  }

  try {
    rewardedAd = RewardedAd.createForAdRequest(getRewardedId());

    rewardedAd.addAdEventListener(RewardedAdEventType.LOADED, () => {
      isRewardedLoaded = true;
      useAdStore.getState().actions.setRewardedReady(true);
      console.log("ğŸ Rewarded loaded");
    });

    rewardedAd.addAdEventListener(RewardedAdEventType.EARNED_REWARD, () => {
      console.log("ğŸ Reward earned");
    });

    rewardedAd.addAdEventListener(AdEventType.CLOSED, () => {
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
      loadRewarded(); // Preload next
    });

    rewardedAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("ğŸ Rewarded error:", error);
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
    });

    rewardedAd.load();
  } catch (error) {
    console.log("ğŸ Rewarded init error:", error);
  }
};

export const showRewarded = (): Promise<boolean> => {
  if (!isAdMobAvailable || !isRewardedLoaded || !rewardedAd) {
    console.log("ğŸ Rewarded not ready");
    return Promise.resolve(false);
  }

  return new Promise((resolve) => {
    const unsubscribeReward = rewardedAd.addAdEventListener(
      RewardedAdEventType.EARNED_REWARD,
      () => {
        unsubscribeReward();
        useAdStore.getState().actions.markRewardedShown();
        resolve(true);
      },
    );

    const unsubscribeClose = rewardedAd.addAdEventListener(
      AdEventType.CLOSED,
      () => {
        unsubscribeClose();
      },
    );

    const unsubscribeError = rewardedAd.addAdEventListener(
      AdEventType.ERROR,
      () => {
        unsubscribeError();
        resolve(false);
      },
    );

    try {
      rewardedAd.show();
    } catch (error) {
      console.log("ğŸ Rewarded show error:", error);
      resolve(false);
    }
  });
};

// ==========================================
// INITIALIZATION
// ==========================================

export const initializeAds = () => {
  if (!isAdMobAvailable) {
    console.log("ğŸ“º AdMob not available, skipping initialization");
    return;
  }

  console.log("ğŸ“º Initializing ads...");
  loadInterstitial();
  loadRewarded();
};

export const isInterstitialReady = () =>
  isAdMobAvailable && isInterstitialLoaded;
export const isRewardedReady = () => isAdMobAvailable && isRewardedLoaded;
</file>

<file path="src/store/dataStore.ts">
import { create } from "zustand";
import { fetchChapters, fetchLevels } from "../services/dataService";
import { Chapter, Level } from "../types";

interface DataState {
  chapters: Chapter[];
  levelsCache: Record<number, Level[]>; // chapterId -> Level[]
  isLoading: boolean;
}

interface DataActions {
  getChapters: () => Promise<Chapter[]>;
  getLevels: (chapterId: number) => Promise<Level[]>;
  getChapterById: (id: number) => Chapter | undefined;
  getLevelById: (
    chapterId: number,
    levelId: number,
  ) => Promise<Level | undefined>;
}

interface DataStore extends DataState {
  actions: DataActions;
}

export const useDataStore = create<DataStore>((set, get) => ({
  chapters: [],
  levelsCache: {},
  isLoading: false,

  actions: {
    getChapters: async () => {
      const { chapters } = get();
      if (chapters.length > 0) return chapters;

      set({ isLoading: true });
      const fetchedChapters = await fetchChapters();

      set({ chapters: fetchedChapters, isLoading: false });
      return fetchedChapters;
    },

    getLevels: async (chapterId: number) => {
      const { levelsCache } = get();
      if (levelsCache[chapterId]) return levelsCache[chapterId];
      console.log(levelsCache[chapterId]);

      set({ isLoading: true });
      const fetchedLevels = await fetchLevels(chapterId);
      set((state) => ({
        levelsCache: { ...state.levelsCache, [chapterId]: fetchedLevels },
        isLoading: false,
      }));
      return fetchedLevels;
    },

    getChapterById: (id: number) => {
      return get().chapters.find((c) => c.id === id);
    },

    getLevelById: async (chapterId: number, levelId: number) => {
      const levels = await get().actions.getLevels(chapterId);
      return levels.find((l) => l.id === levelId);
    },
  },
}));

export const useChapters = () => useDataStore((state) => state.chapters);
export const useDataActions = () => useDataStore((state) => state.actions);
export const useIsDataLoading = () => useDataStore((state) => state.isLoading);
</file>

<file path="src/store/gameStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { STORAGE_KEYS } from "../constants/gameConfig";
import { GridSize } from "../types";
import { isSolved, performMove, shuffleGrid } from "../utils/puzzleLogic";

interface GameState {
  currentGrid: number[];
  emptySlotIndex: number;
  moveCount: number;
  hintsUsed: number;
  isSolved: boolean;
  gridSize: GridSize;
  isInitialized: boolean;
  hintedTiles: number[];
}

interface GameActions {
  initializeGame: (gridSize: GridSize) => void;
  loadLevelState: (
    chapterId: number,
    levelId: number,
    gridSize: GridSize,
  ) => Promise<boolean>;
  saveLevelState: (chapterId: number, levelId: number) => Promise<void>;
  clearLevelState: (chapterId: number, levelId: number) => Promise<void>;
  prepareGame: () => void;
  moveTile: (index: number) => boolean;
  resetGame: () => void;
  useHint: () => void;
}

interface GameStore extends GameState {
  actions: GameActions;
}

const initialState: GameState = {
  currentGrid: [],
  emptySlotIndex: -1,
  moveCount: 0,
  hintsUsed: 0,
  isSolved: false,
  gridSize: { cols: 3, rows: 3 },
  isInitialized: false,
  hintedTiles: [],
};

const getLevelStateKey = (chapterId: number, levelId: number) =>
  `${STORAGE_KEYS.LEVEL_STATE}_${chapterId}_${levelId}`;

export const useGameStore = create<GameStore>((set, get) => ({
  ...initialState,

  actions: {
    initializeGame: (gridSize: GridSize) => {
      const { grid, emptyIndex } = shuffleGrid(gridSize);
      set({
        currentGrid: grid,
        emptySlotIndex: emptyIndex,
        moveCount: 0,
        isSolved: false,
        gridSize,
        isInitialized: true,
        hintedTiles: [],
      });
    },

    loadLevelState: async (
      chapterId: number,
      levelId: number,
      gridSize: GridSize,
    ) => {
      try {
        const key = getLevelStateKey(chapterId, levelId);
        const stored = await AsyncStorage.getItem(key);
        if (stored) {
          const data = JSON.parse(stored);
          const totalTiles = gridSize.cols * gridSize.rows;
          // Validate stored grid matches current level dimensions
          if (data.grid.length === totalTiles) {
            set({
              currentGrid: data.grid,
              emptySlotIndex: data.emptyIndex,
              moveCount: data.moves,
              isSolved: isSolved(data.grid),
              gridSize,
              isInitialized: true,
              hintedTiles: data.hintedTiles || [],
            });
            return true;
          }
        }
      } catch (e) {
        console.error("Level state yÃ¼klenirken hata:", e);
      }
      return false;
    },

    saveLevelState: async (chapterId: number, levelId: number) => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return;

      try {
        const key = getLevelStateKey(chapterId, levelId);
        const data = {
          grid: state.currentGrid,
          emptyIndex: state.emptySlotIndex,
          moves: state.moveCount,
          hintedTiles: state.hintedTiles,
        };
        await AsyncStorage.setItem(key, JSON.stringify(data));
      } catch (e) {
        console.error("Level state kaydedilirken hata:", e);
      }
    },

    clearLevelState: async (chapterId: number, levelId: number) => {
      try {
        const key = getLevelStateKey(chapterId, levelId);
        await AsyncStorage.removeItem(key);
      } catch (e) {
        console.error("Level state silinirken hata:", e);
      }
    },

    prepareGame: () => {
      set({
        isSolved: false,
        isInitialized: false,
        moveCount: 0,
        hintedTiles: [],
        emptySlotIndex: -1,
        currentGrid: [],
      });
    },

    moveTile: (index: number) => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return false;

      const result = performMove(
        state.currentGrid,
        index,
        state.emptySlotIndex,
        state.gridSize,
      );

      if (result.moved) {
        const solved = isSolved(result.grid);
        set({
          currentGrid: result.grid,
          emptySlotIndex: result.emptyIndex,
          moveCount: state.moveCount + 1,
          isSolved: solved,
        });
      }

      return result.moved;
    },

    resetGame: () => {
      const state = get();
      if (!state.isInitialized) return;

      const { grid, emptyIndex } = shuffleGrid(state.gridSize);
      set({
        currentGrid: grid,
        emptySlotIndex: emptyIndex,
        moveCount: 0,
        isSolved: false,
        hintedTiles: [],
      });
    },

    useHint: () => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return;

      const grid = [...state.currentGrid];
      const emptyTileValue = state.gridSize.cols * state.gridSize.rows - 1;

      // Find all wrong tiles - separate hinted and non-hinted
      const wrongTilesNotHinted: number[] = [];
      const wrongTilesHinted: number[] = [];

      for (let i = 0; i < grid.length; i++) {
        if (grid[i] !== i && i !== emptyTileValue) {
          const tileValue = i;
          if (state.hintedTiles.includes(tileValue)) {
            wrongTilesHinted.push(i);
          } else {
            wrongTilesNotHinted.push(i);
          }
        }
      }

      // Prefer non-hinted tiles, fallback to hinted tiles
      const wrongTiles =
        wrongTilesNotHinted.length > 0 ? wrongTilesNotHinted : wrongTilesHinted;

      if (wrongTiles.length === 0) return;

      // Randomly pick one wrong tile
      const targetIndex =
        wrongTiles[Math.floor(Math.random() * wrongTiles.length)];
      const tileValue = targetIndex;
      const currentIndex = grid.indexOf(tileValue);

      [grid[targetIndex], grid[currentIndex]] = [
        grid[currentIndex],
        grid[targetIndex],
      ];

      let newEmptyIndex = state.emptySlotIndex;
      if (targetIndex === state.emptySlotIndex) {
        newEmptyIndex = currentIndex;
      } else if (currentIndex === state.emptySlotIndex) {
        newEmptyIndex = targetIndex;
      }

      // Only add to hintedTiles if it's not already there
      const newHintedTiles = state.hintedTiles.includes(tileValue)
        ? state.hintedTiles
        : [...state.hintedTiles, tileValue];

      set({
        currentGrid: grid,
        emptySlotIndex: newEmptyIndex,
        hintedTiles: newHintedTiles,
        hintsUsed: state.hintsUsed + 1,
        isSolved: isSolved(grid),
      });
    },
  },
}));

export const useGameActions = () => useGameStore((state) => state.actions);
</file>

<file path="src/types/index.ts">
import { ImageSourcePropType } from "react-native";

export type ImageSource = ImageSourcePropType | { uri: string };
export type GridSize = { cols: number; rows: number };

export interface Level {
  id: number;
  chapterId: number;
  name?: string; // Optional level name
  gridSize: GridSize;
  imageSource: ImageSource;
}

export interface Chapter {
  id: number;
  name: string;
  description: string;
  thumbnail: ImageSource;
  levels: Level[];
  color?: string;
}

export interface LevelProgress {
  completed: boolean;
  bestMoves: number;
  stars: number;
}

export interface UserProgress {
  unlockedChapters: number[];
  completedLevels: Record<string, LevelProgress>;
  totalStars: number;
  lastPlayed?: {
    chapterId: number;
    levelId: number;
  };
}

export interface TilePosition {
  row: number;
  col: number;
}

export interface HintState {
  count: number;
  lastUpdated: number;
}
</file>

<file path="app/_layout.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { createAsyncStoragePersister } from "@tanstack/query-async-storage-persister";
import { QueryClient } from "@tanstack/react-query";
import { PersistQueryClientProvider } from "@tanstack/react-query-persist-client";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useCallback, useEffect, useState } from "react";
import { StyleSheet, View } from "react-native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import DevPanel from "../src/components/DevPanel";
import { COLORS } from "../src/constants/gameConfig";
import { initializeAds } from "../src/services/adManager";
import { loginWithDevice } from "../src/services/authService";
import { getDeviceId } from "../src/services/deviceService";
import { useAdActions } from "../src/store/adStore";
import { useHintActions } from "../src/store/hintStore";
import { useProgressActions } from "../src/store/progressStore";

const __DEV_MODE__ = true;

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60 * 60 * 24, // 24 hours (Aggressive caching for offline)
      gcTime: 1000 * 60 * 60 * 24 * 2, // 48 hours
    },
  },
});

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [appIsReady, setAppIsReady] = useState(false);
  const progressActions = useProgressActions();
  const hintActions = useHintActions();
  const adActions = useAdActions();

  useEffect(() => {
    async function prepare() {
      try {
        const deviceId = await getDeviceId();
        console.log("ğŸš€ App starting with device:", deviceId);

        // CRITICAL: Login FIRST so auth.currentUser is available
        await loginWithDevice();

        // THEN load progress (which needs auth.currentUser to fetch cloud data)
        await progressActions.loadProgress();
        await hintActions.loadHints();
        await adActions.loadAdState();

        try {
          initializeAds();
        } catch (error) {
          console.log("ğŸ“º Ad initialization skipped:", error);
        }
      } catch (e) {
        console.warn("App init error:", e);
      } finally {
        setAppIsReady(true);
      }
    }

    prepare();
  }, []);

  // Setup sync queue listener
  useEffect(() => {
    let unsubscribe: (() => void) | undefined;

    const setupSync = async () => {
      const { setupSyncListener } = await import("../src/services/syncQueue");
      unsubscribe = setupSyncListener();
    };

    setupSync();

    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  const onLayoutRootView = useCallback(async () => {
    if (appIsReady) {
      await SplashScreen.hideAsync();
    }
  }, [appIsReady]);

  if (!appIsReady) {
    return null;
  }

  return (
    <SafeAreaProvider>
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister: asyncStoragePersister }}
      >
        <View style={styles.container} onLayout={onLayoutRootView}>
          <StatusBar style="light" />
          <Stack
            screenOptions={{
              headerStyle: { backgroundColor: COLORS.surface },
              headerTintColor: COLORS.textPrimary,
              headerTitleStyle: { fontWeight: "600" },
              contentStyle: { backgroundColor: COLORS.background },
              headerShadowVisible: false,
            }}
          />
          {__DEV_MODE__ && <DevPanel />}
        </View>
      </PersistQueryClientProvider>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background },
});
</file>

<file path="app/game/[chapterId]/[levelId].tsx">
import ConfirmModal from "@/src/components/ConfirmModal";
import { Ionicons } from "@expo/vector-icons";
import { Image } from "expo-image";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { lazy, Suspense, useCallback, useEffect, useState } from "react";
import {
  ActivityIndicator,
  Modal,
  StyleSheet,
  Text,
  TouchableOpacity,
  useWindowDimensions,
  View,
} from "react-native";
import Animated, { FadeIn, FadeInUp } from "react-native-reanimated";
import { SafeAreaView as SafeAreaContextView } from "react-native-safe-area-context";

// Lazy load PuzzleBoard for better performance
const PuzzleBoard = lazy(() => import("../../../src/components/PuzzleBoard"));

import GameBannerAd from "../../../src/components/GameBannerAd";
import WinModal from "../../../src/components/WinModal";
import {
  BOARD_PADDING,
  calculateStars,
  COLORS,
  getBoardSize,
  HINT_CONFIG,
  LEVELS_PER_CHAPTER,
  TOTAL_CHAPTERS,
} from "../../../src/constants/gameConfig";
import { usePuzzleGame } from "../../../src/hooks/usePuzzleGame";
import {
  showInterstitial,
  showRewarded,
} from "../../../src/services/adManager";
import { useAdActions } from "../../../src/store/adStore";
import { useDataActions, useIsDataLoading } from "../../../src/store/dataStore";
import { useGameActions, useGameStore } from "../../../src/store/gameStore";
import { useHintActions, useHintCount } from "../../../src/store/hintStore";
import { useProgressActions } from "../../../src/store/progressStore";
import { Chapter, GridSize, Level } from "../../../src/types";

export default function GameBoardScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const { chapterId, levelId } = useLocalSearchParams<{
    chapterId: string;
    levelId: string;
  }>();
  const [showWinModal, setShowWinModal] = useState(false);
  const [showPreviewModal, setShowPreviewModal] = useState(false);
  const [earnedStars, setEarnedStars] = useState(0);
  const [showResetModal, setShowResetModal] = useState(false);
  const [showAdModal, setShowAdModal] = useState(false);
  const [showSolvedInfoModal, setShowSolvedInfoModal] = useState(false);
  const [showAdSuccessModal, setShowAdSuccessModal] = useState(false);

  const { getChapterById, getLevelById, getChapters } = useDataActions();
  const isLoading = useIsDataLoading();

  const [chapter, setChapter] = useState<Chapter | undefined>();
  const [level, setLevel] = useState<Level | undefined>();

  const progressActions = useProgressActions();
  const hintCount = useHintCount();
  const hintActions = useHintActions();
  const gameActions = useGameActions();
  const adActions = useAdActions();

  // Show interstitial ad on level entry (not first 4 levels of chapter 1)
  useEffect(() => {
    if (
      level &&
      chapter &&
      adActions.canShowInterstitial(chapter.id, level.id)
    ) {
      showInterstitial();
    }
  }, [level, chapter]);

  useEffect(() => {
    const initData = async () => {
      await getChapters();
      const c = getChapterById(Number(chapterId));
      const l = await getLevelById(Number(chapterId), Number(levelId));
      setChapter(c);
      setLevel(l);
    };
    initData();
  }, [chapterId, levelId]);

  const boardSize = getBoardSize(width);

  useEffect(() => {
    if (level) {
      progressActions.setLastPlayed(level.chapterId, level.id);
    }
  }, [level]);

  // Declare handleWin first (will use gridSize from usePuzzleGame later)
  const [puzzleGridSize, setPuzzleGridSize] = useState<GridSize>({
    cols: 3,
    rows: 3,
  });

  const handleWin = useCallback(
    async (moves: number) => {
      if (level) {
        const stars = calculateStars(moves, puzzleGridSize);
        setEarnedStars(stars);

        // Complete and save BEFORE showing modal to prevent race conditions
        progressActions.completeLevel(
          level.chapterId,
          level.id,
          moves,
          puzzleGridSize,
        );

        if (level.id === LEVELS_PER_CHAPTER) {
          hintActions.addChapterBonus();
        }

        setShowWinModal(true);
      }
    },
    [level, hintActions, puzzleGridSize, progressActions],
  );

  const {
    grid,
    moveCount,
    isSolved,
    gridSize,
    isInitialized,
    handleTilePress,
    resetGame,
    useHint,
    saveState,
    completeAndSave,
  } = usePuzzleGame({
    level: level,
    onWin: handleWin,
  });

  // Update puzzleGridSize when gridSize changes
  useEffect(() => {
    if (gridSize) {
      setPuzzleGridSize(gridSize);
    }
  }, [gridSize]);

  const isUnlocked =
    chapterId && levelId
      ? progressActions.isLevelUnlocked(Number(chapterId), Number(levelId))
      : false;

  const handleResetPress = () => {
    if (moveCount > 0 && !isSolved) {
      setShowResetModal(true);
    } else {
      resetGame();
    }
  };

  // Removed: completion now happens synchronously in handleWin

  const handleGetHints = async () => {
    if (hintCount > 0) {
      const isEverythingCorrect = grid.every(
        (val: number, idx: number) =>
          val === idx || val === gridSize.cols * gridSize.rows - 1,
      );
      if (isEverythingCorrect) {
        setShowSolvedInfoModal(true);
        return;
      }

      // Use hint
      useHint();
      hintActions.useHint();

      // Check if hint solved the puzzle
      setTimeout(() => {
        const updatedState = useGameStore.getState();
        if (updatedState.isSolved && updatedState.isInitialized) {
          if (level) {
            gameActions.clearLevelState(level.chapterId, level.id);
          }
          handleWin(updatedState.moveCount);
        }
      }, 100);
    } else {
      setShowAdModal(true);
    }
  };

  const handleBack = () => {
    saveState?.();
    router.back();
  };

  const isLastLevel = level?.id === LEVELS_PER_CHAPTER;
  const hasNextChapter = chapterId ? Number(chapterId) < TOTAL_CHAPTERS : false;
  const currentStars = calculateStars(moveCount, gridSize);

  // Fallback values for header while loading
  const displayChapterId = chapter?.id || chapterId;
  const displayLevelId = level?.id || levelId;

  // Header Title Logic
  const getHeaderTitle = () => {
    if (level?.name) return level.name;
    if (chapter?.name) return `${chapter.name} - ${displayLevelId}`;
    return `${displayChapterId}-${displayLevelId}`;
  };

  return (
    <SafeAreaContextView style={styles.container} edges={["top"]}>
      <Stack.Screen options={{ headerShown: false }} />

      {/* Banner Ad at Top */}
      {adActions.canShowBanner() && <GameBannerAd />}

      {/* Fixed Header Section */}
      <View style={styles.headerSection}>
        {/* Top Row: Back - Level - Preview */}
        <View style={styles.topRow}>
          <TouchableOpacity style={styles.backBtn} onPress={handleBack}>
            <Ionicons name="arrow-back" size={32} color={COLORS.textPrimary} />
          </TouchableOpacity>

          <View style={styles.levelInfo}>
            <Text
              style={styles.levelLabel}
              numberOfLines={1}
              adjustsFontSizeToFit
            >
              {getHeaderTitle()}
            </Text>
          </View>

          {level ? (
            <TouchableOpacity
              style={styles.previewBtn}
              onPress={() => setShowPreviewModal(true)}
            >
              <Image source={level.imageSource} style={styles.previewThumb} />
              <Text style={styles.zoomTag}>ğŸ”</Text>
            </TouchableOpacity>
          ) : (
            <View style={[styles.previewBtn, { opacity: 0.5 }]} />
          )}
        </View>

        {/* Stats Row: Stars - Moves - Reset */}
        <View style={styles.statsRow}>
          {/* Left: Stars */}
          <View style={styles.starsArea}>
            {[1, 2, 3].map((s) => (
              <Text
                key={s}
                style={[
                  styles.bigStar,
                  s <= currentStars && styles.bigStarFilled,
                ]}
              >
                â˜…
              </Text>
            ))}
          </View>

          {/* Center: Moves Count */}
          <View style={styles.movesArea}>
            <Text style={styles.movesVal}>{moveCount}</Text>
          </View>

          {/* Right: Reset Button */}
          <TouchableOpacity
            style={styles.resetBtnHeader}
            onPress={handleResetPress}
            disabled={!level}
          >
            <Ionicons name="refresh" size={28} color={COLORS.textSecondary} />
          </TouchableOpacity>
        </View>
      </View>

      {/* Flexible Board Section */}
      <View style={styles.boardSection}>
        <Animated.View
          entering={FadeIn}
          key={levelId} // Trigger animation on level change
          style={styles.boardContainer}
        >
          {level && isInitialized ? (
            <Suspense
              fallback={
                <ActivityIndicator size="large" color={COLORS.accent} />
              }
            >
              <PuzzleBoard
                grid={grid}
                gridSize={gridSize}
                imageSource={level.imageSource}
                onTilePress={handleTilePress}
                boardSize={boardSize}
              />
            </Suspense>
          ) : (
            <ActivityIndicator size="large" color={COLORS.accent} />
          )}
        </Animated.View>
      </View>

      {/* Fixed Controls Section */}
      <View style={styles.controlsSection}>
        {!isSolved && (
          <TouchableOpacity
            style={[styles.controlBtn, styles.btnPrimary]}
            onPress={handleGetHints}
          >
            {hintCount > 0 && (
              <View style={[styles.badge, styles.badgeActive]}>
                <Text style={styles.badgeTxt}>{hintCount}</Text>
              </View>
            )}
            <Text style={styles.controlBtnIcon}>ğŸ’¡</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* Zoom Preview Modal */}
      <Modal visible={showPreviewModal} transparent animationType="fade">
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setShowPreviewModal(false)}
        >
          <Animated.View entering={FadeInUp} style={styles.modalBox}>
            {level && (
              <Image
                source={level.imageSource}
                style={styles.fullImg}
                contentFit="contain"
              />
            )}
            <TouchableOpacity
              style={styles.modalClose}
              onPress={() => setShowPreviewModal(false)}
            >
              <Text style={styles.modalCloseTxt}>GÄ°ZLE</Text>
            </TouchableOpacity>
          </Animated.View>
        </TouchableOpacity>
      </Modal>

      {/* --- MODALS --- */}

      {/* 1. Reset Confirmation */}
      <ConfirmModal
        visible={showResetModal}
        title="Yeniden BaÅŸlat"
        message="BÃ¶lÃ¼m ilerlemeniz sÄ±fÄ±rlanacak. Emin misiniz?"
        confirmText="SÄ±fÄ±rla"
        cancelText="VazgeÃ§"
        isDestructive
        onConfirm={() => {
          setShowResetModal(false);
          resetGame();
        }}
        onCancel={() => setShowResetModal(false)}
      />

      {/* 2. Watch Ad Confirmation */}
      <ConfirmModal
        visible={showAdModal}
        title="Hamle Al"
        message={`Reklam izleyerek ${HINT_CONFIG.rewardedAdHints} hamle hakkÄ± kazan!`}
        confirmText="Reklam Ä°zle"
        cancelText="Ä°ptal"
        onConfirm={async () => {
          setShowAdModal(false);
          const rewarded = await showRewarded();
          if (rewarded) {
            hintActions.addHints(HINT_CONFIG.rewardedAdHints);
            setTimeout(() => setShowAdSuccessModal(true), 500);
          }
        }}
        onCancel={() => setShowAdModal(false)}
      />

      {/* 3. Already Solved Info */}
      <ConfirmModal
        visible={showSolvedInfoModal}
        title="Zaten Ã‡Ã¶zÃ¼ldÃ¼"
        message="TÃ¼m parÃ§alar doÄŸru yerinde!"
        confirmText="Tamam"
        onConfirm={() => setShowSolvedInfoModal(false)}
      />

      {/* 4. Ad Success Info */}
      <ConfirmModal
        visible={showAdSuccessModal}
        title="Tebrikler!"
        message={`${HINT_CONFIG.rewardedAdHints} hamle hakkÄ± kazandÄ±n!`}
        confirmText="Harika"
        onConfirm={() => setShowAdSuccessModal(false)}
      />

      <WinModal
        visible={showWinModal}
        moves={moveCount}
        stars={earnedStars}
        isLastLevel={isLastLevel}
        hasNextChapter={hasNextChapter}
        chapterColor={chapter?.color || COLORS.primary}
        onNextLevel={() => {
          setShowWinModal(false);
          if (!isLastLevel) {
            router.replace(`/game/${chapterId}/${Number(levelId) + 1}`);
          } else if (hasNextChapter) {
            router.replace(`/game/${Number(chapterId) + 1}/1`);
          }
        }}
        onReplay={() => {
          setShowWinModal(false);
          resetGame();
        }}
        onBackToLevels={() => {
          setShowWinModal(false);
          router.back();
        }}
      />
    </SafeAreaContextView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background },

  // Fixed Header Section
  headerSection: {
    paddingHorizontal: BOARD_PADDING,
    paddingTop: 10,
    paddingBottom: 8,
  },
  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    height: 60,
    paddingHorizontal: 4,
  },
  backBtn: {
    width: 44,
    height: 44,
    justifyContent: "center",
    alignItems: "flex-start",
  },
  levelInfo: { flex: 1, alignItems: "center" },
  levelLabel: {
    fontSize: 24,
    fontWeight: "900",
    color: COLORS.textPrimary,
    letterSpacing: 1,
  },
  previewBtn: {
    width: 48,
    height: 48,
    borderRadius: 10,
    overflow: "hidden",
    borderWidth: 1.5,
    borderColor: COLORS.border,
  },
  previewThumb: { width: "100%", height: "100%" },
  zoomTag: {
    position: "absolute",
    bottom: 0,
    right: 0,
    fontSize: 8,
    backgroundColor: "rgba(0,0,0,0.5)",
    padding: 1,
  },
  statsRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 12,
    paddingTop: 8,
  },
  starsArea: {
    flexDirection: "row",
    gap: 4,
    width: 60,
  },
  bigStar: { fontSize: 24, color: COLORS.starEmpty },
  bigStarFilled: { color: COLORS.starFilled },

  movesArea: {
    alignItems: "center",
    justifyContent: "center",
    flex: 1,
  },
  movesVal: {
    fontSize: 48,
    fontWeight: "900",
    color: COLORS.textPrimary,
  },

  resetBtnHeader: {
    width: 44,
    height: 44,
    justifyContent: "center",
    alignItems: "flex-end",
  },

  // Flexible Board Section
  boardSection: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: BOARD_PADDING,
  },
  boardContainer: {
    width: "100%",
    height: "100%",
    justifyContent: "center",
    alignItems: "center",
  },

  // Fixed Controls Section
  controlsSection: {
    height: 120,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    paddingBottom: 20,
  },
  controlBtn: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: "center",
    alignItems: "center",
  },
  btnPrimary: {
    backgroundColor: "transparent",
    borderWidth: 0.5, // Thicker border for visibility
    borderColor: COLORS.accent,
  },
  btnSecondary: {
    backgroundColor: "transparent",
  },
  controlBtnIcon: { fontSize: 32 },
  replayIcon: { fontSize: 48, color: "#fafafa" }, // Much larger
  badge: {
    position: "absolute",
    top: -4,
    right: -4,
    backgroundColor: COLORS.surfaceLight,
    minWidth: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: COLORS.background,
    zIndex: 1,
  },
  badgeActive: { backgroundColor: COLORS.accent },
  badgeTxt: { color: COLORS.textPrimary, fontSize: 10, fontWeight: "900" },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.95)",
    justifyContent: "center",
    alignItems: "center",
  },
  modalBox: {
    width: "90%",
    aspectRatio: 1,
    backgroundColor: COLORS.surface,
    borderRadius: 24,
    padding: 12,
    alignItems: "center",
  },
  fullImg: { width: "100%", height: "100%", borderRadius: 16 },
  modalClose: { marginTop: 20, padding: 10 },
  modalCloseTxt: {
    color: COLORS.textPrimary,
    fontWeight: "800",
    letterSpacing: 2,
  },
  errorContainer: { flex: 1, justifyContent: "center", alignItems: "center" },
});
</file>

<file path="app/levels/[chapterId].tsx">
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { useEffect } from "react";
import {
  ActivityIndicator,
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, { FadeInDown } from "react-native-reanimated";
import {
  BOARD_PADDING,
  COLORS,
  getResponsiveValue,
} from "../../src/constants/gameConfig";
import { useDataActions, useIsDataLoading } from "../../src/store/dataStore";
import {
  useProgressActions,
  useProgressStore,
} from "../../src/store/progressStore";
import { Level, LevelProgress } from "../../src/types";

interface LevelCardProps {
  level: Level;
  index: number;
  isUnlocked: boolean;
  progress: LevelProgress | null;
  cardSize: number;
  chapterColor?: string;
  onPress: () => void;
}

import { Image } from "expo-image"; // Ensure this is imported at top of file

import { Ionicons } from "@expo/vector-icons"; // Add this import at the top if missing, I will check effectively by deducing or adding it.

// ... existing imports

const LevelCard: React.FC<LevelCardProps> = ({
  level,
  index,
  isUnlocked,
  progress,
  cardSize,
  chapterColor,
  onPress,
}) => {
  return (
    <Animated.View
      entering={FadeInDown.delay(index * 20).springify()}
      style={{ width: cardSize, alignItems: "center" }}
    >
      <TouchableOpacity
        style={[
          styles.levelCard,
          { width: cardSize, height: cardSize },
          progress?.completed && {
            borderColor: chapterColor || COLORS.accent,
            borderWidth: 2,
          },
        ]}
        onPress={onPress}
        disabled={!isUnlocked}
        activeOpacity={0.7}
      >
        {/* Background Image */}
        <Image
          source={level.imageSource}
          style={[StyleSheet.absoluteFill, styles.cardBgImage]}
          contentFit="cover"
          transition={200}
        />

        {/* Dark Overlay for Readability (Only when locked) */}
        {!isUnlocked && (
          <View style={[StyleSheet.absoluteFill, styles.cardOverlayLocked]} />
        )}

        {isUnlocked ? (
          <View style={styles.cardContent}>
            <View style={styles.levelBadge}>
              <Text style={styles.levelNumber}>{level.id}</Text>
            </View>
          </View>
        ) : (
          <View style={styles.centeredContent}>
            <Text style={styles.lockIcon}>ğŸ”’</Text>
          </View>
        )}
      </TouchableOpacity>

      {/* Stars Row - Consistent Height for ALL cards */}
      <View style={styles.starsRowBelow}>
        {isUnlocked ? (
          [1, 2, 3].map((star) => {
            const isFilled =
              progress?.completed && star <= (progress?.stars || 0);
            return (
              <Ionicons
                key={star}
                name="star"
                size={14}
                color={isFilled ? "#fbbf24" : "#e2e8f0"} // Gold or Light Gray
                style={isFilled && styles.starShadow} // Optional shadow for filled
              />
            );
          })
        ) : (
          // Placeholder for locked levels to maintain height
          <View style={{ height: 14 }} />
        )}
      </View>
    </Animated.View>
  );
};

export default function LevelsScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const { chapterId } = useLocalSearchParams<{ chapterId: string }>();
  const progressActions = useProgressActions();

  // Subscribe to progress changes for real-time updates
  const progress = useProgressStore((state) => state.progress);

  const { getLevels, getChapterById } = useDataActions();
  const isLoading = useIsDataLoading();
  const [levels, setLevels] = React.useState<Level[]>([]);
  const chapter = getChapterById(Number(chapterId));

  useEffect(() => {
    const loadLevels = async () => {
      const fetchedLevels = await getLevels(Number(chapterId));
      setLevels(fetchedLevels);
    };
    loadLevels();
  }, [chapterId]);

  if (isLoading && levels.length === 0) {
    return (
      <View style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  if (!chapter) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorText}>Kategori bulunamadÄ±</Text>
      </View>
    );
  }

  const numColumns = getResponsiveValue(width, { phone: 4, tablet: 6 });
  const padding = BOARD_PADDING;
  const gap = 10;
  const cardSize = (width - padding * 2 - gap * (numColumns - 1)) / numColumns;
  const chapterProgress = progressActions.getChapterProgress(chapter.id);

  const renderLevel = ({ item, index }: { item: Level; index: number }) => {
    const isUnlocked = progressActions.isLevelUnlocked(chapter.id, item.id);
    const progress = progressActions.getLevelProgress(chapter.id, item.id);
    return (
      <LevelCard
        level={item}
        index={index}
        isUnlocked={isUnlocked}
        progress={progress}
        cardSize={cardSize}
        chapterColor={chapter.color}
        onPress={() => router.push(`/game/jigsaw/${chapterId}/${item.id}`)}
      />
    );
  };

  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: chapter.name,
          headerStyle: { backgroundColor: COLORS.background },
          headerTintColor: COLORS.textPrimary,
          headerShadowVisible: false,
        }}
      />

      {/* Header Info (Aesthetics Update) */}
      <View style={styles.headerInfoArea}>
        <View style={styles.headerTop}>
          <View
            style={[styles.chapterBadge, { backgroundColor: COLORS.surface }]}
          >
            <Text style={styles.chapterBadgeText}>{chapter.id}</Text>
          </View>
          <View style={styles.headerTitles}>
            <Text style={styles.headerTitle}>{chapter.name}</Text>
            <View style={styles.progressPill}>
              <Text style={styles.progressPillText}>
                {chapterProgress.completed} / {chapterProgress.total} SEVÄ°YE
              </Text>
            </View>
          </View>
          <View style={styles.starPill}>
            <Text style={styles.starPillIcon}>â˜…</Text>
            <Text style={styles.starPillText}>{chapterProgress.stars}</Text>
          </View>
        </View>
      </View>

      <FlatList
        data={levels}
        renderItem={renderLevel}
        keyExtractor={(item) => item.id.toString()}
        numColumns={numColumns}
        key={numColumns}
        contentContainerStyle={[styles.listContent, { padding }]}
        columnWrapperStyle={{ gap }}
        ItemSeparatorComponent={() => <View style={{ height: gap }} />}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  centered: {
    justifyContent: "center",
    alignItems: "center",
  },
  errorText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    textAlign: "center",
    marginTop: 24,
  },
  headerInfoArea: {
    padding: BOARD_PADDING,
    paddingBottom: 20,
    backgroundColor: COLORS.background,
  },
  headerTop: {
    flexDirection: "row",
    alignItems: "center",
    gap: 15,
  },
  chapterBadge: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: COLORS.border,
  },
  chapterBadgeText: {
    fontSize: 28,
    fontWeight: "900",
    color: COLORS.textPrimary,
  },
  headerTitles: { flex: 1 },
  headerTitle: { fontSize: 24, fontWeight: "800", color: COLORS.textPrimary },
  progressPill: {
    backgroundColor: COLORS.surface,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 6,
    alignSelf: "flex-start",
    marginTop: 4,
  },
  progressPillText: {
    fontSize: 10,
    color: COLORS.textSecondary,
    fontWeight: "700",
  },
  starPill: {
    backgroundColor: COLORS.surface,
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  starPillIcon: { color: COLORS.starFilled, fontSize: 18 },
  starPillText: { color: COLORS.textPrimary, fontWeight: "800", fontSize: 16 },
  listContent: {
    paddingBottom: 40,
  },
  levelCard: {
    backgroundColor: COLORS.surface,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
    overflow: "hidden", // Important for image masking
  },
  cardBgImage: {
    opacity: 1, // Full vibrancy!
  },
  cardOverlay: {
    // Removed default dark overlay
    backgroundColor: "transparent",
  },
  cardOverlayLocked: {
    backgroundColor: "rgba(0,0,0,0.6)", // Lighter lock overlay
  },
  cardContent: {
    flex: 1,
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 8,
  },
  levelCardLocked: {
    opacity: 0.5,
  },
  levelBadge: {
    backgroundColor: "rgba(255,255,255,0.9)", // Bright badge
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
    marginTop: 4,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  levelNumber: {
    fontSize: 16,
    fontWeight: "900",
    color: COLORS.textSecondary, // Dark text on light badge
  },
  lockIcon: {
    fontSize: 24,
    marginTop: 20, // Center optically
  },
  starsRow: {
    // Old starsRow style kept just in case, but unused now
    flexDirection: "row",
    gap: 1,
    marginBottom: 4,
  },
  starsRowBelow: {
    flexDirection: "row",
    gap: 2,
    marginTop: 4,
    height: 16, // Fixed height to prevent layout shifts
    alignItems: "center",
    justifyContent: "center",
  },
  starSmall: {
    fontSize: 12,
    color: "#cbd5e1", // Light gray for empty stars (slate-300)
  },
  starFilledSmall: {
    color: "#fbbf24", // Vibrant Gold
  },
  centeredContent: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  starPlaceholder: {
    fontSize: 10,
    color: "transparent",
  },
  star: {
    fontSize: 12,
    color: "rgba(255,255,255,0.5)", // Unearned star
    textShadowColor: "black",
    textShadowRadius: 1,
  },
  starFilled: {
    color: "#fbbf24", // Vibrant Gold
    textShadowColor: "rgba(0,0,0,0.5)",
    textShadowRadius: 1,
  },
  starShadow: {
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 1,
  },
});
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "Puzzle Game",
    "slug": "puzzle-game",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "puzzlegame",
    "userInterfaceStyle": "dark",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/images/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#0a0a0f"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.eoist.puzzlegame"
    },
    "android": {
      "package": "com.eoist.puzzlegame",
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#0a0a0f"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-5502183878891798~8940999016",
          "iosAppId": "ca-app-pub-5502183878891798~3324892015"
        }
      ],
      [
        "expo-build-properties",
        {
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0"
          },
          "ios": {
            "deploymentTarget": "15.1",
            "useFrameworks": "static"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {},
      "eas": {
        "projectId": "b35e8ced-defe-4118-828f-56967256d5a8"
      }
    }
  }
}
</file>

<file path="package.json">
{
  "name": "puzzle-game",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@lottiefiles/dotlottie-react-native": "^0.7.1",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/native": "^7.1.8",
    "@tanstack/query-async-storage-persister": "^5.90.20",
    "@tanstack/react-query": "^5.90.18",
    "@tanstack/react-query-persist-client": "^5.90.20",
    "expo": "~54.0.31",
    "expo-application": "~7.0.8",
    "expo-build-properties": "~1.0.10",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-router": "~6.0.21",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-web-browser": "~15.0.10",
    "firebase": "^12.8.0",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "^2.30.0",
    "react-native-google-mobile-ads": "^16.0.1",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "react-test-renderer": "19.1.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

</files>
