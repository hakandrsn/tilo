This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.json
app/_layout.tsx
app/chapters.tsx
app/game/jigsaw/[chapterId]/[levelId].tsx
app/index.tsx
app/levels/[chapterId].tsx
build-1768664620944.apk
DEVELOPMENT.md
docs/jigsaw_mechanics.md
eas.json
firebaseConfig.js
metro.config.js
package.json
src/assets/animations/confettie.lottie
src/assets/animations/star.lottie
src/assets/fonts/SpaceMono-Regular.ttf
src/assets/images/adaptive-icon.png
src/assets/images/favicon.png
src/assets/images/icon.png
src/assets/images/ios-dark.png
src/assets/images/ios-light.png
src/assets/images/ios-tinted.png
src/assets/images/splash-icon.png
src/components/ChapterNativeAd.tsx
src/components/ConfirmModal.tsx
src/components/DevPanel.tsx
src/components/GameBannerAd.tsx
src/components/GameSettingsMenu.tsx
src/components/NetworkError.tsx
src/components/PuzzleBoard.tsx
src/components/Tile.tsx
src/components/WinModal.tsx
src/constants/colors.ts
src/constants/data.ts
src/constants/gameConfig.ts
src/constants/layout.ts
src/constants/uiText.ts
src/global.d.ts
src/hooks/usePuzzleGame.ts
src/modules/jigsaw/JigsawBoard.tsx
src/modules/jigsaw/JigsawGroup.tsx
src/modules/jigsaw/JigsawPiece.tsx
src/modules/jigsaw/jigsawStore.ts
src/modules/jigsaw/useJigsawLogic.ts
src/services/adManager.ts
src/services/authService.ts
src/services/dataService.ts
src/services/deviceService.ts
src/services/syncQueue.ts
src/store/adStore.ts
src/store/dataStore.ts
src/store/gameStore.ts
src/store/hintStore.ts
src/store/progressStore.ts
src/store/settingsStore.ts
src/types/index.ts
src/utils/puzzleLogic.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="DEVELOPMENT.md">
# Puzzle Game - GeliÅŸtirme DokÃ¼mantasyonu

## ğŸ“‹ Proje Ã–zeti

React Native (Expo) ile geliÅŸtirilmiÅŸ, chapter-level bazlÄ± bir **Sliding Tile Puzzle** oyunu. Virtual splitting tekniÄŸi kullanÄ±larak gÃ¶rseller fiziksel olarak bÃ¶lÃ¼nmeden puzzle parÃ§alarÄ± oluÅŸturulur.

## ğŸ¯ Temel Ã–zellikler

### Oyun MekaniÄŸi
- **Virtual Splitting**: GÃ¶rseller fiziksel olarak bÃ¶lÃ¼nmez, tek gÃ¶rsel Ã¼zerinden maskeleme yapÄ±lÄ±r
- **Ã‡Ã¶zÃ¼lebilir Shuffle**: Her zaman Ã§Ã¶zÃ¼lebilir puzzle garantisi (geriye doÄŸru hamle simÃ¼lasyonu)
- **Progresif Zorluk**: 
  - Seviye 1-8: 3Ã—3 grid (50 shuffle hamlesi)
  - Seviye 9-16: 4Ã—4 grid (100 shuffle hamlesi)
  - Seviye 17-24: 5Ã—5 grid (150 shuffle hamlesi)

### Ä°Ã§erik
- **20 Kategori** Ã— **24 Seviye** = **480 Toplam Seviye**
- Her kategori farklÄ± tema ve renk paleti
- Her seviye iÃ§in unique gÃ¶rsel

### Ä°lerleme Sistemi
- YÄ±ldÄ±z sistemi (1-3 yÄ±ldÄ±z, performansa gÃ¶re)
- Chapter unlock sistemi
- Level unlock sistemi (sÄ±ralÄ± aÃ§Ä±lma)
- Son oynanan level kaydÄ±

### Hamle Sistemi
- VarsayÄ±lan: **10 hamle hakkÄ±**
- Her chapter bitiminde: **+5 bonus hamle**
- Rewarded reklam izleyerek: **+3 hamle hakkÄ±**

### Reklam Sistemi (AdMob)
- **Interstitial**: Level geÃ§iÅŸlerinde gÃ¶sterilir
- **Rewarded**: Hamle almak iÃ§in izlenir
- Test ID'leri ile geliÅŸtirme desteÄŸi
- Expo Go'da conditional loading (native modÃ¼l yoksa no-op)

## ğŸ—ï¸ Mimari YapÄ±

### Dizin YapÄ±sÄ±

```
puzzle-game/
â”œâ”€â”€ app/                          # Expo Router ekranlarÄ±
â”‚   â”œâ”€â”€ _layout.tsx              # Root layout (splash, device ID, ads init)
â”‚   â”œâ”€â”€ index.tsx                # Start ekranÄ± (Devam Et + BÃ¶lÃ¼mler)
â”‚   â”œâ”€â”€ chapters.tsx             # Kategori listesi
â”‚   â”œâ”€â”€ levels/[chapterId].tsx   # Seviye listesi
â”‚   â””â”€â”€ game/[chapterId]/[levelId].tsx  # Oyun ekranÄ±
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Tile.tsx             # Puzzle parÃ§asÄ± (virtual splitting)
â”‚   â”‚   â”œâ”€â”€ PuzzleBoard.tsx      # Oyun tahtasÄ±
â”‚   â”‚   â”œâ”€â”€ WinModal.tsx         # Kazanma modalÄ±
â”‚   â”‚   â””â”€â”€ DevPanel.tsx         # Development paneli
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ usePuzzleGame.ts     # Oyun mantÄ±ÄŸÄ± hook'u
â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”œâ”€â”€ gameStore.ts         # Aktif oyun state'i (Zustand)
â”‚   â”‚   â”œâ”€â”€ progressStore.ts     # Ä°lerleme state'i (Zustand + AsyncStorage)
â”‚   â”‚   â””â”€â”€ hintStore.ts         # Hamle hakkÄ± state'i (Zustand + AsyncStorage)
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ deviceService.ts     # Device ID alma
â”‚   â”‚   â””â”€â”€ adManager.ts         # AdMob yÃ¶netimi (conditional)
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ puzzleLogic.ts       # Puzzle algoritmalarÄ±
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts             # TypeScript tipleri
â”‚   â””â”€â”€ constants/
â”‚       â””â”€â”€ gameConfig.ts         # Oyun konfigÃ¼rasyonu
â”œâ”€â”€ app.json                      # Expo config
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

## ğŸ¨ UI/UX TasarÄ±m

### Renk Paleti (Minimalist Dark Theme)

```typescript
background: '#0a0a0f'      // Ana arka plan
surface: '#12121a'         // Kart arka planÄ±
surfaceLight: '#1e1e2d'    // Hover/active durumlar
primary: '#8b5cf6'         // Mor (ana renk)
accent: '#06b6d4'          // Cyan (vurgu)
```

### Responsive TasarÄ±m

- **Phone** (<768px): 2 sÃ¼tun grid, 360px max board
- **Tablet** (â‰¥768px): 3 sÃ¼tun grid, 480px max board
- **Desktop** (â‰¥1024px): 4 sÃ¼tun grid, 480px max board

### Animasyonlar

- Tile hareketleri: `withTiming` (120ms, bounce yok)
- Modal aÃ§Ä±lÄ±ÅŸlarÄ±: `FadeIn` + `SlideInDown`
- Sayfa geÃ§iÅŸleri: Expo Router slide animation

## ğŸ”§ Teknik Detaylar

### State Management (Zustand)

#### gameStore
- Aktif oyun durumu
- Grid state, boÅŸ slot, hamle sayÄ±sÄ±
- Ã‡Ã¶zÃ¼m kontrolÃ¼

#### progressStore
- KullanÄ±cÄ± ilerlemesi (AsyncStorage ile persist)
- Unlocked chapters/levels
- Tamamlanan level'ler ve yÄ±ldÄ±zlar
- Son oynanan level

#### hintStore
- Hamle hakkÄ± sayÄ±sÄ± (AsyncStorage ile persist)
- Chapter bonus sistemi
- Reklam reward sistemi

### Virtual Splitting TekniÄŸi

```typescript
// Her tile iÃ§in gÃ¶rsel offset hesaplama
const imageOffset = {
  top: -(rowIndex * tileSize),
  left: -(colIndex * tileSize),
};

// Container overflow: hidden ile maskeleme
<View style={{ overflow: 'hidden' }}>
  <Image style={{ position: 'absolute', ...imageOffset }} />
</View>
```

### Shuffle AlgoritmasÄ±

1. Ã‡Ã¶zÃ¼lmÃ¼ÅŸ grid ile baÅŸla: `[0, 1, 2, ..., n-1]`
2. X adet geÃ§erli rastgele hamle simÃ¼le et
3. Bu yÃ¶ntem her zaman Ã§Ã¶zÃ¼lebilir puzzle garantiler

### Device ID Sistemi

- `expo-application` ile unique device ID
- Android: `getAndroidId()`
- iOS: `getIosIdForVendorAsync()`
- Web: Fallback ID
- Ä°lk aÃ§Ä±lÄ±ÅŸta loglanÄ±r

### AdMob Entegrasyonu

#### Conditional Loading
- Expo Go'da native modÃ¼l yoksa no-op fonksiyonlar
- Try-catch ile gÃ¼venli yÃ¼kleme
- Production build'de normal Ã§alÄ±ÅŸÄ±r

#### Reklam Tipleri
- **Interstitial**: Level geÃ§iÅŸlerinde
- **Rewarded**: Hamle almak iÃ§in
- Test ID'leri: `TestIds.INTERSTITIAL`, `TestIds.REWARDED`

## ğŸ“± Ekranlar

### 1. Start Screen (`app/index.tsx`)
- Logo ve baÅŸlÄ±k
- **Devam Et** butonu (son kaldÄ±ÄŸÄ± level)
- **BÃ¶lÃ¼mler** butonu
- YÄ±ldÄ±z ve hamle hakkÄ± gÃ¶stergesi
- Ä°lerleme barÄ±

### 2. Chapters Screen (`app/chapters.tsx`)
- Grid layout (responsive)
- Her chapter iÃ§in:
  - Thumbnail gÃ¶rsel
  - Chapter numarasÄ± badge
  - Ä°lerleme barÄ±
  - YÄ±ldÄ±z sayÄ±sÄ±
- Lock overlay (unlocked deÄŸilse)

### 3. Levels Screen (`app/levels/[chapterId].tsx`)
- Chapter header (thumbnail + istatistikler)
- Level grid (responsive)
- Her level iÃ§in:
  - Level numarasÄ±
  - Grid boyutu
  - YÄ±ldÄ±zlar (tamamlandÄ±ysa)
- Lock icon (unlocked deÄŸilse)

### 4. Game Screen (`app/game/[chapterId]/[levelId].tsx`)
- Header:
  - Hedef gÃ¶rsel (kÃ¼Ã§Ã¼k preview)
  - Hamle sayÄ±sÄ±
  - Level badge
- Puzzle board (responsive)
- Alt butonlar:
  - Yeniden BaÅŸlat
  - Hamle Al (reklam ile)
- Win Modal (Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nde)

## ğŸ› ï¸ Development Tools

### Dev Panel
- SaÄŸ altta kÄ±rmÄ±zÄ± ğŸ›  butonu
- Level'e git (bÃ¶lÃ¼m + level seÃ§imi)
- Puzzle'Ä± Ã§Ã¶z (instant win)
- +10 hamle hakkÄ± ekle

**Aktif/Pasif**: `app/_layout.tsx` iÃ§inde `__DEV_MODE__` deÄŸiÅŸkeni

## ğŸ“¦ BaÄŸÄ±mlÄ±lÄ±klar

### Core
- `expo`: ~54.0.31
- `expo-router`: ~6.0.21
- `react-native`: 0.81.5
- `react`: 19.1.0

### State & Storage
- `zustand`: ^5.0.10
- `@react-native-async-storage/async-storage`: 2.2.0

### Animasyon
- `react-native-reanimated`: ~4.1.1

### GÃ¶rsel
- `expo-image`: ~3.0.11

### Reklam
- `react-native-google-mobile-ads`: (conditional)

### Utility
- `expo-application`: Device ID iÃ§in
- `expo-splash-screen`: Splash screen kontrolÃ¼

## ğŸ” Storage Keys

```typescript
USER_PROGRESS: '@puzzle_game_progress'
HINT_COUNT: '@puzzle_game_hints'
LAST_PLAYED: '@puzzle_game_last_played'
DEVICE_ID: '@puzzle_game_device_id'
```

## ğŸ® Oyun AkÄ±ÅŸÄ±

1. **Uygulama AÃ§Ä±lÄ±ÅŸÄ±**
   - Device ID al ve logla
   - Progress ve hints yÃ¼kle
   - AdMob initialize (varsa)

2. **Start Screen**
   - Devam Et â†’ Son oynanan level
   - BÃ¶lÃ¼mler â†’ Chapter listesi

3. **Chapter Selection**
   - Unlocked chapter'lar seÃ§ilebilir
   - Her chapter iÃ§in progress gÃ¶sterilir

4. **Level Selection**
   - SÄ±ralÄ± unlock (Ã¶nceki level tamamlanmalÄ±)
   - Tamamlanan level'ler yÄ±ldÄ±zlÄ± gÃ¶sterilir

5. **Oyun**
   - Tile'lara dokunarak hareket ettir
   - Hamle sayÄ±sÄ± takip edilir
   - Ã‡Ã¶zÃ¼ldÃ¼ÄŸÃ¼nde:
     - YÄ±ldÄ±z hesaplanÄ±r
     - Progress kaydedilir
     - Interstitial reklam gÃ¶sterilir
     - Chapter bonus verilir (son level ise)

6. **Hamle Al**
   - Rewarded reklam izle
   - +3 hamle hakkÄ± kazan

## ğŸš€ Ã‡alÄ±ÅŸtÄ±rma

### Development
```bash
npm start
# veya
npx expo start
```

### Platform Specific
```bash
npm run android
npm run ios
npm run web
```

### Cache Temizleme
```bash
npm run reset
# veya
npx expo start --clear
```

## âš ï¸ Ã–nemli Notlar

### Expo Go Limitation
- AdMob native modÃ¼lÃ¼ Expo Go'da Ã§alÄ±ÅŸmaz
- Conditional loading ile uygulama Ã§alÄ±ÅŸÄ±r ama reklamlar gÃ¶sterilmez
- Production build iÃ§in `npx expo prebuild` gerekir (kullanÄ±cÄ± istemiyor)

### Production Build
- AdMob iÃ§in native build gerekli
- `app.json` iÃ§inde AdMob App ID'leri yapÄ±landÄ±rÄ±lmalÄ±
- Test ID'leri production'da deÄŸiÅŸtirilmeli

### Performance
- Tile animasyonlarÄ± optimize edildi (memo, withTiming)
- Board boyutu responsive (tablet/phone)
- Image lazy loading (expo-image)

## ğŸ“ Gelecek GeliÅŸtirmeler

- [ ] Backend entegrasyonu (device ID ile kullanÄ±cÄ± takibi)
- [ ] Leaderboard sistemi
- [ ] Daily challenges
- [ ] Power-ups (shuffle, hint, etc.)
- [ ] Custom image upload
- [ ] Social sharing
- [ ] Achievement sistemi

## ğŸ› Bilinen Sorunlar

- Expo Go'da AdMob Ã§alÄ±ÅŸmaz (beklenen davranÄ±ÅŸ)
- Web platform'da bazÄ± native Ã¶zellikler sÄ±nÄ±rlÄ±

## ğŸ“„ Lisans

MIT

---

**Son GÃ¼ncelleme**: 2024
**Versiyon**: 1.0.0
</file>

<file path="docs/jigsaw_mechanics.md">
# Jigsaw Puzzle Oyunu - Sorun Analizi ve Ã‡Ã¶zÃ¼m PlanÄ±

## ğŸ¯ Oyunun AmacÄ±

- `A x B` boyutundaki bir board'da resim parÃ§alarÄ± var.
- ParÃ§alar tutulup sÃ¼rÃ¼klenerek yer deÄŸiÅŸtiriliyor.
- Yan yana gelen parÃ§alarÄ±n **doÄŸru komÅŸu** olup olmadÄ±ÄŸÄ± kontrol ediliyor.
- DoÄŸruysa **birleÅŸiyorlar** ve tek grup olarak hareket ediyorlar.
- TÃ¼m parÃ§alar birleÅŸince **oyun kazanÄ±lÄ±yor**.

---

## ğŸš¨ Tespit Edilen Sorunlar

### 1. **Ãœst Ãœste Binme (Overlap) Sorunu** âš ï¸ KRÄ°TÄ°K

**Senaryo**: 3x2 grubu, 2x2 grubun Ã¼zerine taÅŸÄ±nÄ±yor. 2x2 grubu itilmesi gerekirken, Ã¼st Ã¼ste kalÄ±yor.

**KÃ¶k Neden** (`jigsawStore.ts` satÄ±r 297-318):

```typescript
// HATA: Ã–nce aktif grubu taÅŸÄ±yoruz (satÄ±r 283-290)
// Sonra victim gruplarÄ± eski koordinatlarÄ±yla arÄ±yoruz (satÄ±r 298)
const vGroup = Object.values(pieces).filter((p) => p.groupId === vId);
```

- `pieces` objesi **zaten gÃ¼ncellendi** (aktif grup yeni yerine taÅŸÄ±ndÄ±).
- Ama `vGroup` iÃ§indeki parÃ§alarÄ±n `currentRow/Col` deÄŸerleri **hala eski**.
- `findNearestEmptySlotForGroup` fonksiyonu `pieces` objesini kontrol ederken, **aktif grubun eski yeri** hala "dolu" gÃ¶rÃ¼nÃ¼yor.

**SonuÃ§**: BFS yanlÄ±ÅŸ sonuÃ§ veriyor veya hiÃ§ sonuÃ§ bulamÄ±yor.

---

### 2. **Transactional Olmayan TaÅŸÄ±ma** âš ï¸ KRÄ°TÄ°K

**Problem**: EÄŸer victim grup itilecek yer bulamazsa (`shift === null`), aktif grup **zaten taÅŸÄ±nmÄ±ÅŸ oluyor**.

**OlmasÄ± Gereken**:

- Ã–nce TÃœM victim gruplarÄ±n itilip itilemeyeceÄŸi kontrol edilmeli.
- EÄŸer herhangi biri itilemiyorsa, **tÃ¼m iÅŸlem iptal edilmeli** (Snap Back).

---

### 3. **BirleÅŸme SonrasÄ± Ä°tme KontrolÃ¼ Yok**

**Problem**: Ä°ki grup birleÅŸtiÄŸinde, yeni bÃ¼yÃ¼k grubun footprint'i baÅŸka gruplarla Ã§akÄ±ÅŸÄ±yor olabilir.
**SonuÃ§**: BirleÅŸme sonrasÄ± Ã¼st Ã¼ste binme oluÅŸabiliyor.

---

### 4. **OccupiedSlots Hesaplama HatasÄ±**

**Problem** (`jigsawStore.ts` satÄ±r 293-294):

```typescript
const currentOccupied = new Set(
  targetFootprint.map((f) => `${f.row},${f.col}`),
);
```

Bu set sadece **aktif grubun yeni yerini** iÃ§eriyor.

- DiÄŸer (victim olmayan) gruplarÄ±n yerleri **dahil edilmemiÅŸ**.
- BFS, baÅŸka gruplarÄ±n Ã¼zerine de itme Ã¶nerebilir.

---

### 5. **SÃ¼rÃ¼kleme SÄ±rasÄ±nda SÄ±nÄ±r KontrolÃ¼ (Clamping) Yok**

**Problem**: KullanÄ±cÄ± bir grubu ekran dÄ±ÅŸÄ±na sÃ¼rÃ¼kleyebiliyor.

- `moveGroupToGrid` reddetse bile, kullanÄ±cÄ± deneyimi kÃ¶tÃ¼ (ani geri sekme).

**OlmasÄ± Gereken**: SÃ¼rÃ¼kleme sÄ±rasÄ±nda grup, board sÄ±nÄ±rlarÄ± iÃ§inde **clamp** edilmeli.

---

### 6. **Merge SonrasÄ± Recursive Merge KontrolÃ¼ Yok**

**Problem**: A grubu B ile birleÅŸti. Yeni AB grubu artÄ±k C grubunun yanÄ±nda. Ama AC birleÅŸmesi denemiyor.
**SonuÃ§**: KullanÄ±cÄ± tekrar dokunmak zorunda kalÄ±yor.

---

### 7. **Performance: TÃ¼m ParÃ§alar Her Harekette Render Oluyor**

**Problem**: `pieces` objesi her harekette tamamen yeni obje oluyor.

- `useMemo(() => Object.values(pieces), [pieces])` â†’ Her seferinde yeni array.
- `React.memo` bile yardÄ±m etmiyor Ã§Ã¼nkÃ¼ referanslar deÄŸiÅŸiyor.

---

## âœ… Ã‡Ã¶zÃ¼m PlanÄ±

### A. Transactional Move Logic (Ã–ncelik: KRÄ°TÄ°K)

1. **Ã–nce simÃ¼lasyon yap, sonra uygula**:

   ```typescript
   // 1. Aktif grubun yeni footprint'ini hesapla (henÃ¼z taÅŸÄ±ma)
   // 2. Victim gruplarÄ± bul
   // 3. Her victim iÃ§in BFS ile shift hesapla
   // 4. EÄŸer herhangi bir victim itilemezse â†’ return { merged: false }
   // 5. TÃ¼m shiftler geÃ§erliyse â†’ state'i gÃ¼ncelle
   ```

2. **OccupiedSlots DoÄŸru Hesapla**:
   - TÃ¼m parÃ§alarÄ±n mevcut yerlerini al.
   - Aktif grubun **eski yerini** Ã§Ä±kar.
   - Aktif grubun **yeni yerini** ekle.
   - Her victim itildikÃ§e, eski yerini Ã§Ä±kar, yeni yerini ekle.

### B. Clamping During Drag

- `JigsawPiece.tsx` iÃ§inde `onUpdate` callback'inde:
  ```typescript
  const clampedX = Math.max(0, Math.min(translationX, maxX));
  const clampedY = Math.max(0, Math.min(translationY, maxY));
  ```

### C. Recursive Merge

- Merge sonrasÄ±, yeni grubun tÃ¼m komÅŸularÄ±nÄ± tekrar kontrol et.
- `while (didMerge)` loop'u ekle.

### D. Performance Optimization

- ParÃ§a objeleri sadece deÄŸiÅŸenler iÃ§in yeni referans alsÄ±n.
- `immer` veya manuel shallow copy kullan.

---

## ğŸ“‹ Uygulama SÄ±rasÄ±

1. [x] **Transactional Move Logic** refaktÃ¶rÃ¼ (`jigsawStore.ts`)
2. [x] **OccupiedSlots** hesaplamasÄ±nÄ± dÃ¼zelt
3. [ ] **Clamping** ekle (`JigsawPiece.tsx`)
4. [x] **Recursive Merge** ekle
5. [ ] **Test**: 2x2 â†’ 3x2 senaryosunu doÄŸrula
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.28.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="firebaseConfig.js">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { initializeApp } from "firebase/app";
import { getReactNativePersistence, initializeAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
  apiKey: "AIzaSyDbw35GvHjcXVdt4x__MCVo6IeaERVuOV4",
  authDomain: "puzzle-game-a5b2a.firebaseapp.com",
  projectId: "puzzle-game-a5b2a",
  storageBucket: "puzzle-game-a5b2a.firebasestorage.app",
  messagingSenderId: "167040071688",
  appId: "1:167040071688:web:9877039f99e61702e579bd",
  measurementId: "G-3SQGX6R0R4"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Initialize Auth with AsyncStorage persistence
const auth = initializeAuth(app, {
  persistence: getReactNativePersistence(AsyncStorage),
});

export { auth, db };
export default app;
</file>

<file path="src/components/ChapterNativeAd.tsx">
import React from "react";
import { Platform, StyleSheet, View } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("ğŸ“º AdMob not available for native ads");
  isAdMobAvailable = false;
}

// ==========================================
// NATIVE AD COMPONENT (Using Medium Rectangle Banner)
// ==========================================

interface ChapterNativeAdProps {
  index: number;
}

const ChapterNativeAd: React.FC<ChapterNativeAdProps> = ({ index }) => {
  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    // Fallback: Show nothing if AdMob not available
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  return (
    <View style={styles.adWrapper}>
      <BannerAd
        unitId={getBannerId()}
        size={BannerAdSize.MEDIUM_RECTANGLE}
        requestOptions={{
          requestNonPersonalizedAdsOnly: false,
        }}
        onAdLoaded={() => {
          console.log("ğŸ“º Chapter ad loaded");
        }}
        onAdFailedToLoad={(error: any) => {
          console.log("ğŸ“º Chapter ad failed:", error);
        }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  adWrapper: {
    width: "100%",
    alignItems: "center",
    marginVertical: 8,
  },
});

export default ChapterNativeAd;
</file>

<file path="src/components/ConfirmModal.tsx">
import React from "react";
import { Modal, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, { FadeInUp } from "react-native-reanimated";
import { COLORS } from "../constants/gameConfig";

interface ConfirmModalProps {
  visible: boolean;
  title: string;
  message: string;
  onConfirm: () => void;
  onCancel?: () => void; // Made optional
  confirmText?: string;
  cancelText?: string;
  isDestructive?: boolean;
}

export default function ConfirmModal({
  visible,
  title,
  message,
  onConfirm,
  onCancel,
  confirmText = "Onayla",
  cancelText = "VazgeÃ§",
  isDestructive = false,
}: ConfirmModalProps) {
  if (!visible) return null;

  return (
    <Modal visible={visible} transparent animationType="fade">
      <View style={styles.overlay}>
        <Animated.View entering={FadeInUp.springify()} style={styles.container}>
          <Text style={styles.title}>{title}</Text>
          <Text style={styles.message}>{message}</Text>

          <View style={styles.buttonRow}>
            {onCancel && (
              <TouchableOpacity style={styles.cancelButton} onPress={onCancel}>
                <Text style={styles.cancelText}>{cancelText}</Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={[
                styles.confirmButton,
                isDestructive && styles.destructiveButton,
              ]}
              onPress={onConfirm}
            >
              <Text style={styles.confirmText}>{confirmText}</Text>
            </TouchableOpacity>
          </View>
        </Animated.View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.8)",
    justifyContent: "center",
    alignItems: "center",
    padding: 20,
  },
  container: {
    width: "100%",
    maxWidth: 320,
    backgroundColor: COLORS.surface,
    borderRadius: 24,
    padding: 24,
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.5,
    shadowRadius: 20,
    elevation: 10,
  },
  title: {
    fontSize: 20,
    fontWeight: "800",
    color: COLORS.textPrimary,
    marginBottom: 8,
    textAlign: "center",
  },
  message: {
    fontSize: 15,
    color: COLORS.textSecondary,
    textAlign: "center",
    lineHeight: 22,
    marginBottom: 24,
  },
  buttonRow: {
    flexDirection: "row",
    gap: 12,
    width: "100%",
  },
  cancelButton: {
    flex: 1,
    height: 48,
    borderRadius: 12,
    backgroundColor: COLORS.surfaceLight,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  confirmButton: {
    flex: 1,
    height: 48,
    borderRadius: 12,
    backgroundColor: COLORS.accent,
    justifyContent: "center",
    alignItems: "center",
  },
  destructiveButton: {
    backgroundColor: "#FF453A", // iOS system red or a defined error color
  },
  cancelText: {
    color: COLORS.textSecondary,
    fontWeight: "700",
    fontSize: 15,
  },
  confirmText: {
    color: "#000",
    fontWeight: "700",
    fontSize: 15,
  },
});
</file>

<file path="src/components/GameSettingsMenu.tsx">
import { Ionicons } from "@expo/vector-icons"; // Need to check if Feather/MaterialIcons fit better or stick to Ionicons
import React from "react";
import {
  Modal,
  StyleSheet,
  Switch,
  Text,
  TouchableOpacity,
  TouchableWithoutFeedback,
  View,
} from "react-native";
import { COLORS } from "../constants/gameConfig";
import { useSettingsStore } from "../store/settingsStore";

interface GameSettingsMenuProps {
  visible: boolean;
  onClose: () => void;
}

const GameSettingsMenu: React.FC<GameSettingsMenuProps> = ({
  visible,
  onClose,
}) => {
  const {
    hapticsEnabled,
    musicEnabled,
    soundEnabled,
    actions: { toggleHaptics, toggleMusic, toggleSound },
  } = useSettingsStore();

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
    >
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={styles.overlay}>
          <TouchableWithoutFeedback>
            <View style={styles.menuContainer}>
              <View style={styles.header}>
                <Text style={styles.title}>Ayarlar</Text>
                <TouchableOpacity onPress={onClose} style={styles.closeBtn}>
                  <Ionicons
                    name="close"
                    size={24}
                    color={COLORS.textSecondary}
                  />
                </TouchableOpacity>
              </View>

              {/* Haptics Toggle */}
              <View style={styles.row}>
                <View style={styles.labelContainer}>
                  <Ionicons
                    name="phone-portrait-outline"
                    size={22}
                    color={COLORS.textPrimary}
                  />
                  <Text style={styles.label}>TitreÅŸim</Text>
                </View>
                <Switch
                  value={hapticsEnabled}
                  onValueChange={toggleHaptics}
                  trackColor={{ false: "#e0e0e0", true: COLORS.primary }} // Use primary (sunflower) for on
                  thumbColor={"#fff"}
                />
              </View>

              {/* Music Toggle */}
              <View style={styles.row}>
                <View style={styles.labelContainer}>
                  <Ionicons
                    name="musical-notes-outline"
                    size={22}
                    color={COLORS.textPrimary}
                  />
                  <Text style={styles.label}>MÃ¼zik</Text>
                </View>
                <Switch
                  value={musicEnabled}
                  onValueChange={toggleMusic}
                  trackColor={{ false: "#e0e0e0", true: COLORS.primary }}
                  thumbColor={"#fff"}
                />
              </View>

              {/* Sound Toggle */}
              <View style={styles.row}>
                <View style={styles.labelContainer}>
                  <Ionicons
                    name="volume-high-outline"
                    size={22}
                    color={COLORS.textPrimary}
                  />
                  <Text style={styles.label}>Ses Efektleri</Text>
                </View>
                <Switch
                  value={soundEnabled}
                  onValueChange={toggleSound}
                  trackColor={{ false: "#e0e0e0", true: COLORS.primary }}
                  thumbColor={"#fff"}
                />
              </View>
            </View>
          </TouchableWithoutFeedback>
        </View>
      </TouchableWithoutFeedback>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "transparent", // Overlayless as requested
    // User said "overlaysiz bir modal aÃ§Ä±lacak". If I interpret strictly, maybe just a dropdown?
    // But then click-outside-to-close is harder without full view.
    // I'll make the background transparent-ish or very subtle.
    // "overlaysiz" usually implies "don't dim the whole screen".
    // I will use transparent overlay to catch clicks but show game behind clearly.
    // Just alignment: center or top-right? User didn't specify position, just "modal".
    justifyContent: "center",
    alignItems: "center",
  },
  menuContainer: {
    width: 280,
    backgroundColor: COLORS.surface,
    borderRadius: 16,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 5,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 20,
  },
  title: {
    fontSize: 18,
    fontWeight: "700",
    color: COLORS.textPrimary,
  },
  closeBtn: {
    padding: 4,
  },
  row: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 16,
  },
  labelContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  label: {
    fontSize: 16,
    color: COLORS.textPrimary,
    fontWeight: "500",
  },
});

export default GameSettingsMenu;
</file>

<file path="src/components/NetworkError.tsx">
import React from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { COLORS } from "../constants/gameConfig";

interface NetworkErrorProps {
  onRetry: () => void;
  message?: string;
}

export const NetworkError: React.FC<NetworkErrorProps> = ({
  onRetry,
  message = "Veri yÃ¼klenemedi. LÃ¼tfen internet baÄŸlantÄ±nÄ±zÄ± kontrol edip tekrar deneyin.",
}) => {
  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Text style={styles.icon}>ğŸ“¡</Text>
      </View>
      <Text style={styles.title}>BaÄŸlantÄ± HatasÄ±</Text>
      <Text style={styles.message}>{message}</Text>
      <TouchableOpacity
        style={styles.retryButton}
        onPress={onRetry}
        activeOpacity={0.8}
      >
        <Text style={styles.retryText}>Tekrar Dene</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: COLORS.background,
    paddingHorizontal: 24,
  },
  iconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: COLORS.surface,
    justifyContent: "center",
    alignItems: "center",
    marginBottom: 24,
    borderWidth: 1,
    borderColor: COLORS.error,
  },
  icon: {
    fontSize: 32,
  },
  title: {
    fontSize: 24,
    fontWeight: "800",
    color: COLORS.textPrimary,
    marginBottom: 12,
  },
  message: {
    fontSize: 16,
    color: COLORS.textSecondary,
    textAlign: "center",
    marginBottom: 32,
    lineHeight: 22,
  },
  retryButton: {
    backgroundColor: COLORS.surface,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: COLORS.primary,
  },
  retryText: {
    color: COLORS.textPrimary,
    fontWeight: "700",
    fontSize: 16,
  },
});
</file>

<file path="src/constants/data.ts">
const chapters = [
  // --- BAÅLANGIÃ‡: Net Objeler & CanlÄ± Renkler ---
  {
    id: 1,
    name: "Sevimli Dostlar", // Eski: Hayvanlar (Daha sÄ±cak bir isim)
    description: "Kedi, kÃ¶pek ve tÃ¼ylÃ¼ dostlarÄ±n en tatlÄ± halleri",
    color: "#f472b6", // Pembe/SÄ±cak
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?w=400&q=80",
    }, // Kedi
  },
  {
    id: 2,
    name: "Lezzet DuraÄŸÄ±", // Yeni: Yemek/TatlÄ± (Renkler canlÄ±, parÃ§a birleÅŸimi kolay)
    description: "Ä°ÅŸtah kabartan tatlÄ±lar ve meyveler",
    color: "#fb923c", // Turuncu
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1563729784474-d77dbb933a9e?w=400&q=80",
    }, // Cake
  },
  {
    id: 3,
    name: "Retro Objeler", // Yeni: Vintage (Kamera, daktilo vb. net ÅŸekiller)
    description: "Nostaljik eÅŸyalar ve antika detaylar",
    color: "#78716c", // Kahve/Gri
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1550259114-ad7188f0a967?w=400&q=80",
    }, // Retro Car/Camera
  },
  {
    id: 4,
    name: "Renkli Kanatlar", // Eski: KuÅŸlar (Daha spesifik)
    description: "Egzotik kuÅŸlarÄ±n muhteÅŸem tÃ¼yleri",
    color: "#0ea5e9", // GÃ¶kyÃ¼zÃ¼ Mavisi
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1552728089-57bdde30ebd1?w=400&q=80",
    }, // Parrot
  },
  {
    id: 5,
    name: "Botanik BahÃ§e", // Eski: Ã‡iÃ§ekler (Daha makro Ã§ekimler)
    description: "DoÄŸanÄ±n en canlÄ± renk paletleri",
    color: "#22c55e", // YeÅŸil
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1470506028280-a011fb34b6f7?w=400&q=80",
    }, // Flower field
  },

  // --- KEÅÄ°F: Manzaralar & Mimari ---
  {
    id: 6,
    name: "Tropik KaÃ§Ä±ÅŸ", // Eski: Yaz/Plaj
    description: "Turkuaz sular ve palmiye gÃ¶lgeleri",
    color: "#06b6d4", // Cyan
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1596895111956-bf1cf0599ce5?w=400&q=80",
    }, // Maldives
  },
  {
    id: 7,
    name: "Antik Gizemler", // Eski: Antik/Tarihi
    description: "UnutulmuÅŸ tapÄ±naklar ve harabeler",
    color: "#d97706", // AltÄ±n/Toprak
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1564507592333-c60657eea523?w=400&q=80",
    }, // Taj Mahal/Pyramid
  },
  {
    id: 8,
    name: "Neon Sokaklar", // Yeni: Cyberpunk/Tokyo geceleri
    description: "Gece Ä±ÅŸÄ±klarÄ± ve ÅŸehir yansÄ±malarÄ±",
    color: "#8b5cf6", // Mor
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1555680202-c86f0e12f086?w=400&q=80",
    }, // Neon City
  },
  {
    id: 9,
    name: "Sokak SanatÄ±", // Yeni: Graffiti (KarmaÅŸÄ±k ama renkli)
    description: "Duvarlardaki renkli isyan",
    color: "#ec4899", // Hot Pink
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1517713982677-4b6633299833?w=400&q=80",
    }, // Graffiti
  },
  {
    id: 10,
    name: "Masal KÃ¶yleri", // Eski: KÃ¶yler
    description: "Tablo gibi gÃ¶rÃ¼nen ÅŸirin kasabalar",
    color: "#84cc16", // Lime
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1518730518541-d0843268c287?w=400&q=80",
    }, // Hallstatt/Cinque Terre
  },

  // --- ATMOSFER: Doku & Zor Renkler ---
  {
    id: 11,
    name: "Derin Mavi", // Eski: Deniz/Okyanus (SualtÄ± aÄŸÄ±rlÄ±klÄ±)
    description: "Okyanusun altÄ±ndaki sessiz dÃ¼nya",
    color: "#1e40af", // Koyu Mavi
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1582967788606-a171f1080ca8?w=400&q=80",
    }, // Jellyfish/Coral
  },
  {
    id: 12,
    name: "Sonbahar Yolu", // Eski: Sonbahar
    description: "KÄ±zÄ±l yapraklar ve orman patikalarÄ±",
    color: "#ea580c", // YanÄ±k Turuncu
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1507783548227-544c3b8bc210?w=400&q=80",
    }, // Autumn Road
  },
  {
    id: 13,
    name: "Buz KrallÄ±ÄŸÄ±", // Eski: KÄ±ÅŸ (Beyaz aÄŸÄ±rlÄ±klÄ± olduÄŸu iÃ§in zordur)
    description: "Kar taneleri ve buzlu zirveler",
    color: "#cbd5e1", // AÃ§Ä±k Gri/Buz
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1483664852095-d6cc6870705d?w=400&q=80",
    }, // Snow
  },
  {
    id: 14,
    name: "AltÄ±n Saatler", // Eski: GÃ¼n BatÄ±mÄ±
    description: "GÃ¼neÅŸin batarken bÄ±raktÄ±ÄŸÄ± silÃ¼etler",
    color: "#f59e0b", // Amber
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1472120435266-531128262475?w=400&q=80",
    }, // Sunset
  },
  {
    id: 15,
    name: "Makro Evren", // Yeni: BÃ¶cek/GÃ¶z/Doku detaylarÄ±
    description: "GÃ¶zle gÃ¶rÃ¼lmeyen detaylarÄ±n dÃ¼nyasÄ±",
    color: "#10b981", // Emerald
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1550684848-fac1c5b4e853?w=400&q=80",
    }, // Macro Eye/Insect
  },

  // --- SOYUT & FÄ°NAL: En Zor ve En Etkileyici ---
  {
    id: 16,
    name: "Kristal MaÄŸara", // Yeni: TaÅŸlar/Mineraller (KÄ±rÄ±k Ã§izgiler zordur)
    description: "DeÄŸerli taÅŸlar ve Ä±ÅŸÄ±k kÄ±rÄ±lmalarÄ±",
    color: "#6366f1", // Indigo
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1515516089376-88db1e26e9c0?w=400&q=80",
    }, // Crystals
  },
  {
    id: 17,
    name: "Gotik Mimari", // Eski: Mimari (Ama daha karanlÄ±k ve detaylÄ±)
    description: "Katedraller, vitraylar ve detaylar",
    color: "#111827", // Ã‡ok koyu gri
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1548625361-9877039f99e6?w=400&q=80",
    }, // Gothic
  },
  {
    id: 18,
    name: "Soyut RÃ¼ya", // Eski: Sanat (YaÄŸlÄ± boya / Abstract)
    description: "Renklerin ve ÅŸekillerin dansÄ±",
    color: "#db2777", // Koyu Pembe
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1541701494587-cb58502866ab?w=400&q=80",
    }, // Abstract Paint
  },
  {
    id: 19,
    name: "Kuzey IÅŸÄ±klarÄ±", // Yeni: Aurora Borealis (GeÃ§iÅŸli renkler Ã§ok zordur)
    description: "GÃ¶kyÃ¼zÃ¼ndeki bÃ¼yÃ¼lÃ¼ Ä±ÅŸÄ±k dansÄ±",
    color: "#34d399", // YeÅŸil/Mavi karÄ±ÅŸÄ±mÄ±
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1531366936337-7c912a4589a7?w=400&q=80",
    }, // Aurora
  },
  {
    id: 20,
    name: "Sonsuz Uzay", // Eski: Uzay (En zor, siyah boÅŸluklar Ã§ok)
    description: "Galaksiler, nebulalar ve bilinmeyen",
    color: "#4c1d95", // Deep Purple
    thumbnail: {
      uri: "https://images.unsplash.com/photo-1462331940025-496dfbfc7564?w=400&q=80",
    }, // Nebula
  },
];

export default chapters;
</file>

<file path="src/constants/layout.ts">
export const LAYOUT = {
  // Board
  boardPadding: 16,

  // Controls
  controlButtonSize: 70,
  controlButtonRadius: 35,
  controlsBottomOffset: 40,
  controlsGap: 50,

  // Badges
  badgeSize: 20,
  badgeOffset: -4,

  // Buttons
  backButtonSize: 44,
  resetButtonSize: 44,
  previewButtonSize: 48,

  // Header
  levelLabelSize: 24,

  // Stars
  starSize: 24,
  bigStarSize: 44,

  // Moves
  movesSize: 48,

  // Modal
  modalPadding: 24,
  modalMaxWidth: 340,
  modalBorderRadius: 24,

  // Preview
  previewThumbSize: 48,
  previewThumbRadius: 10,

  // Chapter Badge
  chapterBadgeSize: 60,
  chapterBadgeRadius: 30,
};
</file>

<file path="src/constants/uiText.ts">
export const UI_TEXT = {
  winModal: {
    title: "Tebrikler!",
    subtitle: "BulmacayÄ± TamamladÄ±n",
    moves: "Hamle",
    nextLevel: "Sonraki Seviye",
    replay: "Tekrar Oyna",
    backToLevels: "Seviyelere DÃ¶n",
  },
  confirmModals: {
    reset: {
      title: "Yeniden BaÅŸlat",
      message: "BÃ¶lÃ¼m ilerlemeniz sÄ±fÄ±rlanacak. Emin misiniz?",
      confirm: "SÄ±fÄ±rla",
      cancel: "VazgeÃ§",
    },
    watchAd: {
      title: "Hamle Al",
      messageTemplate: "Reklam izleyerek {count} hamle hakkÄ± kazan!",
      confirm: "Reklam Ä°zle",
      cancel: "Ä°ptal",
    },
    alreadySolved: {
      title: "Zaten Ã‡Ã¶zÃ¼ldÃ¼",
      message: "TÃ¼m parÃ§alar doÄŸru yerinde!",
      confirm: "Tamam",
    },
    adSuccess: {
      title: "Tebrikler!",
      messageTemplate: "{count} hamle hakkÄ± kazandÄ±n!",
      confirm: "Harika",
    },
  },
  previewModal: {
    close: "GÄ°ZLE",
  },
  errors: {
    chapterNotFound: "Kategori bulunamadÄ±",
  },
  levels: {
    levelCount: "{completed} / {total} SEVÄ°YE",
  },
};
</file>

<file path="src/global.d.ts">
declare module "*.lottie" {
  const value: any;
  export default value;
}
</file>

<file path="src/modules/jigsaw/JigsawBoard.tsx">
import { Image } from "expo-image";
import React, { useCallback, useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { useSharedValue } from "react-native-reanimated";
import { GridSize, ImageSource } from "../../types";
import JigsawPiece from "./JigsawPiece";
import { JigsawPiece as JigsawPieceType, useJigsawStore } from "./jigsawStore";
import { useJigsawLogic } from "./useJigsawLogic";

interface JigsawBoardProps {
  gridSize: GridSize;
  imageSource: ImageSource;
  boardWidth: number;
  boardHeight: number;
}

const BOARD_PADDING = 32; // Increased padding
const MAX_BOARD_WIDTH = 1080;
const MAX_BOARD_HEIGHT = 1440;

const JigsawBoard: React.FC<JigsawBoardProps> = ({
  gridSize,
  imageSource,
  boardWidth,
  boardHeight,
}) => {
  const pieces = useJigsawStore((state) => state.pieces);

  const isInitialized = useJigsawStore((state) => state.isInitialized);

  // Calculate strict piece size with max constraints (1080x1440)
  const {
    pieceWidth,
    pieceHeight,
    totalGridHeight,
    topOffset,
    totalGridWidth,
    leftOffset,
  } = useMemo(() => {
    // Apply max constraints
    const constrainedWidth = Math.min(boardWidth, MAX_BOARD_WIDTH);
    const constrainedHeight = Math.min(boardHeight, MAX_BOARD_HEIGHT);

    const availableWidth = constrainedWidth - BOARD_PADDING * 2;
    const availableHeight = constrainedHeight - BOARD_PADDING * 2;

    // Desired Aspect Ratio: 3:4 (0.75) -> Width / Height = 0.75
    // pieceHeight = pieceWidth / 0.75 = pieceWidth * 1.333

    // 1. Calculate max possible width based on available width
    const maxPieceW = availableWidth / gridSize.cols;

    // 2. Calculate corresponding height for that width
    const suggestedPieceH = maxPieceW * (4 / 3);

    // 3. Check if this height fits in available height
    let pieceW, pieceH;

    if (suggestedPieceH * gridSize.rows <= availableHeight) {
      // Fits! Use these dims
      pieceW = Math.floor(maxPieceW);
      pieceH = Math.floor(suggestedPieceH);
    } else {
      // Too tall! Constrain by height instead
      const maxPieceH = availableHeight / gridSize.rows;
      pieceH = Math.floor(maxPieceH);
      pieceW = Math.floor(maxPieceH * (3 / 4));
    }

    const tGridHeight = pieceH * gridSize.rows;
    const tGridWidth = pieceW * gridSize.cols;

    // Center the grid within the board
    const tOffset = Math.floor(Math.max(0, (boardHeight - tGridHeight) / 2));
    const lOffset = Math.floor(Math.max(0, (boardWidth - tGridWidth) / 2));

    return {
      pieceWidth: pieceW,
      pieceHeight: pieceH,
      totalGridHeight: tGridHeight,
      totalGridWidth: tGridWidth,
      topOffset: tOffset,
      leftOffset: lOffset,
    };
  }, [boardWidth, boardHeight, gridSize]);

  // Internal initialization removed. Controlled by parent.

  // Signal System for Group Dragging
  const draggedGroupId = useSharedValue<string | null>(null);
  const dragTranslation = useSharedValue({ x: 0, y: 0 });

  const { attemptDrop } = useJigsawLogic(pieceWidth, pieceHeight);

  // PERFORMANCE: Stable callbacks with useCallback
  const onDragStart = useCallback((groupId: string) => {
    // Opt: Don't bring to front via store on start (expensive re-render).
    // Reanimated handles zIndex visually during drag.
    // Store zIndex update happens on drop via moveGroupToGrid logic if needed.
  }, []);

  const onDragEnd = useCallback(
    (pieceId: number, finalX: number, finalY: number) => {
      attemptDrop(pieceId, finalX, finalY);
    },
    [attemptDrop],
  );

  // Render Flat List of Pieces
  const pieceList = useMemo(() => Object.values(pieces), [pieces]);

  // PERFORMANCE: O(1) position lookup map instead of O(n) .some() calls
  const positionMap = useMemo(() => {
    const map = new Map<string, JigsawPieceType>();
    pieceList.forEach((p) => map.set(`${p.currentRow},${p.currentCol}`, p));
    return map;
  }, [pieceList]);

  // PERFORMANCE: Pre-calculate neighbor connections for all pieces
  const neighborConnections = useMemo(() => {
    const connections: Record<
      number,
      { top: boolean; bottom: boolean; left: boolean; right: boolean }
    > = {};
    pieceList.forEach((piece) => {
      const topNeighbor = positionMap.get(
        `${piece.currentRow - 1},${piece.currentCol}`,
      );
      const bottomNeighbor = positionMap.get(
        `${piece.currentRow + 1},${piece.currentCol}`,
      );
      const leftNeighbor = positionMap.get(
        `${piece.currentRow},${piece.currentCol - 1}`,
      );
      const rightNeighbor = positionMap.get(
        `${piece.currentRow},${piece.currentCol + 1}`,
      );
      connections[piece.id] = {
        top: topNeighbor?.groupId === piece.groupId,
        bottom: bottomNeighbor?.groupId === piece.groupId,
        left: leftNeighbor?.groupId === piece.groupId,
        right: rightNeighbor?.groupId === piece.groupId,
      };
    });
    return connections;
  }, [pieceList, positionMap]);

  // PERFORMANCE: Memoize grid line arrays
  const verticalLines = useMemo(
    () => Array.from({ length: gridSize.cols + 1 }, (_, i) => i),
    [gridSize.cols],
  );
  const horizontalLines = useMemo(
    () => Array.from({ length: gridSize.rows + 1 }, (_, i) => i),
    [gridSize.rows],
  );

  if (!isInitialized) {
    return <View style={styles.container} />;
  }

  return (
    <View
      style={[
        styles.container,
        { width: boardWidth, height: boardHeight + 200 },
      ]}
    >
      {/* Ghost Image on Board */}
      <View
        style={{
          position: "absolute",
          top: topOffset,
          left: leftOffset,
          width: totalGridWidth,
          height: totalGridHeight,
          opacity: 0.15,
        }}
      >
        <Image
          source={imageSource}
          style={{ width: "100%", height: "100%" }}
          contentFit="cover"
        />
      </View>

      <View
        style={{
          marginTop: topOffset,
          marginLeft: leftOffset,
          width: totalGridWidth,
          height: totalGridHeight,
          zIndex: 1,
        }}
      >
        {/* Background Grid Lines Removed as per user request */}

        {/* Render Flat Pieces - O(1) neighbor lookup */}
        {pieceList.map((piece) => {
          const conn = neighborConnections[piece.id];
          return (
            <JigsawPiece
              key={piece.id}
              piece={piece}
              pieceWidth={pieceWidth}
              pieceHeight={pieceHeight}
              imageSource={imageSource}
              gridSize={gridSize}
              draggedGroupId={draggedGroupId}
              dragTranslation={dragTranslation}
              onDragStart={onDragStart}
              onDragEnd={onDragEnd}
              hasNeighborTop={conn.top}
              hasNeighborBottom={conn.bottom}
              hasNeighborLeft={conn.left}
              hasNeighborRight={conn.right}
            />
          );
        })}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: "transparent",
    overflow: "visible",
  },
  // Grid styles removed
});

export default JigsawBoard;
</file>

<file path="src/modules/jigsaw/JigsawGroup.tsx">
import { Image } from "expo-image";
import React, { useEffect, useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withSpring,
  withTiming,
} from "react-native-reanimated";
import { GridSize, ImageSource } from "../../types";
import { calculateImageOffset } from "../../utils/puzzleLogic";
import { JigsawPiece as JigsawPieceType, useJigsawStore } from "./jigsawStore";
import { useJigsawLogic } from "./useJigsawLogic";

interface JigsawGroupProps {
  groupId: string;
  pieces: JigsawPieceType[];
  pieceSize: number;
  imageSource: ImageSource;
  gridSize: GridSize;
  boardWidth: number;
}

const JigsawGroup: React.FC<JigsawGroupProps> = ({
  groupId,
  pieces,
  pieceSize,
  imageSource,
  gridSize,
  boardWidth,
}) => {
  const bringGroupToFront = useJigsawStore(
    (state) => state.actions.bringGroupToFront,
  );
  const status = useJigsawStore((state) => state.status);
  const { attemptDrop } = useJigsawLogic(pieceSize);

  // Group State
  const isLocked = pieces[0]?.isLocked ?? false;
  const isWon = status === "won";

  // Calculate Group Bounding Box
  const minCol = pieces.length
    ? Math.min(...pieces.map((p) => p.currentCol))
    : 0;
  const minRow = pieces.length
    ? Math.min(...pieces.map((p) => p.currentRow))
    : 0;

  // Initial Position Logic (Always on Grid now)
  const initialX = minCol * pieceSize;
  const initialY = minRow * pieceSize;

  const width = pieces.length
    ? (Math.max(...pieces.map((p) => p.currentCol)) - minCol + 1) * pieceSize
    : pieceSize;
  const height = pieces.length
    ? (Math.max(...pieces.map((p) => p.currentRow)) - minRow + 1) * pieceSize
    : pieceSize;

  // Shared Values
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const isDragging = useSharedValue(false);
  const scale = useSharedValue(1);
  const zIndexLocal = useSharedValue(pieces[0]?.zIndex ?? 1);
  const glowOpacity = useSharedValue(0);

  // Coordinate Compensation State
  const prevInitialPos = React.useRef({ x: initialX, y: initialY });

  // Sync with Store Updates (and compensate for jumps)
  useEffect(() => {
    if (!isDragging.value) {
      // Check for Coordinate Jump (e.g. Merge occurred, bounding box changed)
      const diffX = initialX - prevInitialPos.current.x;
      const diffY = initialY - prevInitialPos.current.y;

      // If there is a significant jump (due to bbox change from merge or push)
      // We compensate so the piece stays visually in place, then slides to new target.
      if (Math.abs(diffX) > 0.1 || Math.abs(diffY) > 0.1) {
        // Keep current visual position by reversing the data jump
        translateX.value = translateX.value + diffX;
        translateY.value = translateY.value + diffY;
      }

      // Animate to target (new data position) smoothly and quickly
      translateX.value = withTiming(initialX, { duration: 150 });
      translateY.value = withTiming(initialY, { duration: 150 });

      prevInitialPos.current = { x: initialX, y: initialY };

      if (!isLocked) {
        zIndexLocal.value = pieces[0]?.zIndex ?? 1;
      }
    }
  }, [initialX, initialY, pieces[0]?.zIndex, isLocked]);

  // Win Animation
  useEffect(() => {
    if (isWon) {
      glowOpacity.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 1000 }),
          withTiming(0.5, { duration: 1000 }),
        ),
        -1,
        true,
      );
    }
  }, [isWon]);

  // Robust Gesture with SharedValues
  const startX = useSharedValue(0);
  const startY = useSharedValue(0);

  const panGesture = useMemo(
    () =>
      Gesture.Pan()
        .enabled(!isLocked && !isWon)
        .onStart(() => {
          startX.value = translateX.value;
          startY.value = translateY.value;

          isDragging.value = true;
          scale.value = withSpring(1.05);
          zIndexLocal.value = 9999;

          // runOnJS fix
          runOnJS(bringGroupToFront)(groupId);
        })
        .onUpdate((event) => {
          translateX.value = startX.value + event.translationX;
          translateY.value = startY.value + event.translationY;
        })
        .onEnd((event) => {
          const finalX = startX.value + event.translationX;
          const finalY = startY.value + event.translationY;

          const anchor = pieces[0];
          const anchorRelX = (anchor.currentCol - minCol) * pieceSize;
          const anchorRelY = (anchor.currentRow - minRow) * pieceSize;

          runOnJS(attemptDrop)(
            anchor.id,
            finalX + anchorRelX,
            finalY + anchorRelY,
          );

          isDragging.value = false;
          scale.value = withSpring(1);
        }),
    [
      groupId,
      isLocked,
      isWon,
      minCol,
      minRow,
      pieces, // Added dependency
      pieceSize,
      attemptDrop,
      bringGroupToFront,
    ],
  );

  const groupStyle = useAnimatedStyle(() => ({
    position: "absolute",
    left: 0,
    top: 0,
    width: width,
    height: height,
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
    zIndex: zIndexLocal.value,
    elevation: zIndexLocal.value > 100 ? 50 : 0,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: isDragging.value ? 0.3 : 0,
    shadowRadius: 4,
  }));

  const glowStyle = useAnimatedStyle(() => ({
    position: "absolute",
    top: -4,
    left: -4,
    right: -4,
    bottom: -4,
    borderWidth: 4,
    borderColor: "#fbbf24", // Golden glow
    borderRadius: 8,
    opacity: glowOpacity.value,
  }));

  // Border Rendering Logic
  // Only show internal borders if NOT merged? No, showing borders helps see individual pieces.
  // But merged groups should look unified.
  // Let's keep the previous logic: render individual pieces, check neighbors for borders.
  const isMerged = pieces.length > 1;

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={groupStyle} pointerEvents="box-none">
        {/* Win Glow Overlay */}
        {isWon && <Animated.View style={glowStyle} />}

        {pieces.map((piece) => {
          const relLeft = (piece.currentCol - minCol) * pieceSize;
          const relTop = (piece.currentRow - minRow) * pieceSize;

          const { top, left } = calculateImageOffset(
            piece.id,
            gridSize,
            pieceSize,
          );

          // Neighbor Logic for Borders
          const hasTop = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow - 1 &&
              p.currentCol === piece.currentCol,
          );
          const hasBottom = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow + 1 &&
              p.currentCol === piece.currentCol,
          );
          const hasLeft = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow &&
              p.currentCol === piece.currentCol - 1,
          );
          const hasRight = pieces.some(
            (p) =>
              p.currentRow === piece.currentRow &&
              p.currentCol === piece.currentCol + 1,
          );

          return (
            <View
              key={piece.id}
              style={{
                position: "absolute",
                left: relLeft,
                top: relTop,
                width: pieceSize,
                height: pieceSize,
                overflow: "hidden", // Clip image
              }}
            >
              <Image
                source={imageSource}
                style={{
                  width: gridSize.cols * pieceSize,
                  height: gridSize.rows * pieceSize,
                  transform: [{ translateX: left }, { translateY: top }],
                }}
              />

              {/* Highlight Locked Pieces (Magnet) */}
              {isLocked && !isWon && (
                <View
                  style={{
                    ...StyleSheet.absoluteFillObject,
                    backgroundColor: "rgba(251, 191, 36, 0.2)",
                  }}
                />
              )}

              {/* Borders */}
              {!isWon && (
                <>
                  {!hasTop && (
                    <View
                      style={[
                        styles.borderTop,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasBottom && (
                    <View
                      style={[
                        styles.borderBottom,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasLeft && (
                    <View
                      style={[
                        styles.borderLeft,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                  {!hasRight && (
                    <View
                      style={[
                        styles.borderRight,
                        isMerged && styles.borderMerged,
                      ]}
                    />
                  )}
                </>
              )}
            </View>
          );
        })}
      </Animated.View>
    </GestureDetector>
  );
};

const styles = StyleSheet.create({
  borderTop: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderBottom: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    height: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderLeft: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    width: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderRight: {
    position: "absolute",
    top: 0,
    bottom: 0,
    right: 0,
    width: 1,
    backgroundColor: "rgba(255,255,255,0.3)",
    zIndex: 10,
  },
  borderMerged: {
    backgroundColor: "#fbbf24",
    height: 2, // Thicker for external
    width: 2,
  },
});

export default JigsawGroup;
</file>

<file path="src/modules/jigsaw/useJigsawLogic.ts">
import * as Haptics from "expo-haptics";
import { useCallback } from "react";
import { useJigsawStore } from "./jigsawStore";

export type DropResult = {
  success: boolean;
  merged: boolean;
  swapped?: boolean;
};

/**
 * Hook to handle grid-based drops with haptic feedback
 */
export const useJigsawLogic = (pieceWidth: number, pieceHeight: number) => {
  const moveGroupToGrid = useJigsawStore(
    (state) => state.actions.moveGroupToGrid,
  );
  const gridSize = useJigsawStore((state) => state.gridSize);

  /**
   * Trigger haptic feedback based on scenario
   */
  const triggerHaptic = useCallback(
    (type: "merge" | "reject" | "move" | "drag") => {
      const isHapticEnabled = useJigsawStore.getState().isHapticEnabled;
      if (!isHapticEnabled) return;

      switch (type) {
        case "merge":
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          break;
        case "reject":
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
          break;
        case "move":
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          break;
        case "drag":
          Haptics.selectionAsync();
          break;
      }
    },
    [],
  );

  /**
   * Called when a piece is dropped.
   * Calculates which grid cell (row, col) the piece falls into.
   */
  const attemptDrop = useCallback(
    (
      draggedPieceId: number,
      relativeDropX: number,
      relativeDropY: number,
    ): DropResult => {
      // Calculate target grid coordinates
      const targetCol = Math.round(relativeDropX / pieceWidth);
      const targetRow = Math.round(relativeDropY / pieceHeight);

      // Check if drop is within the Grid Board
      if (
        targetRow >= 0 &&
        targetRow < gridSize.rows &&
        targetCol >= 0 &&
        targetCol < gridSize.cols
      ) {
        // Valid Grid Drop
        const result = moveGroupToGrid(draggedPieceId, targetRow, targetCol);

        if (result.merged) {
          triggerHaptic("merge");
          return { success: true, merged: true };
        } else if (result.merged === false) {
          // Move was accepted but no merge
          triggerHaptic("move");
          return { success: true, merged: false };
        }
      }

      // Move rejected (OOB or collision)
      triggerHaptic("reject");
      return { success: false, merged: false };
    },
    [pieceWidth, pieceHeight, gridSize, moveGroupToGrid, triggerHaptic],
  );

  /**
   * Called when drag starts - light haptic
   */
  const onDragStartHaptic = useCallback(() => {
    triggerHaptic("drag");
  }, [triggerHaptic]);

  return {
    attemptDrop,
    onDragStartHaptic,
    triggerHaptic,
  };
};
</file>

<file path="src/services/authService.ts">
import {
  createUserWithEmailAndPassword,
  onAuthStateChanged,
  signInWithEmailAndPassword,
  User,
} from "firebase/auth";
import { auth } from "../../firebaseConfig";
import { getDeviceId } from "./deviceService";

export const loginWithDevice = async (): Promise<User | null> => {
  const deviceId = await getDeviceId();
  const email = `${deviceId}@puzzle.game`;
  const password = `pass_${deviceId.slice(0, 8)}!`; // Cihaza Ã¶zel sabit ÅŸifre

  try {
    // GiriÅŸ yapmayÄ± dene
    const userCredential = await signInWithEmailAndPassword(
      auth,
      email,
      password
    );
    console.log("ğŸ” Firebase: GiriÅŸ baÅŸarÄ±lÄ±", userCredential.user.uid);
    return userCredential.user;
  } catch (error: any) {
    // EÄŸer kullanÄ±cÄ± yoksa yeni oluÅŸtur
    if (
      error.code === "auth/user-not-found" ||
      error.code === "auth/invalid-credential"
    ) {
      try {
        const userCredential = await createUserWithEmailAndPassword(
          auth,
          email,
          password
        );
        console.log(
          "ğŸ” Firebase: Yeni kullanÄ±cÄ± oluÅŸturuldu",
          userCredential.user.uid
        );
        return userCredential.user;
      } catch (createError) {
        console.error("ğŸ” Firebase: KayÄ±t hatasÄ±", createError);
        return null;
      }
    }
    console.error("ğŸ” Firebase: Auth hatasÄ±", error);
    return null;
  }
};

export const getCurrentUser = (): User | null => auth.currentUser;

export const subscribeToAuthChanges = (
  callback: (user: User | null) => void
) => {
  return onAuthStateChanged(auth, callback);
};
</file>

<file path="src/services/dataService.ts">
import {
  collection,
  doc,
  getDoc,
  getDocs,
  orderBy,
  query,
} from "firebase/firestore";
import { db } from "../../firebaseConfig";
import { Chapter, Level } from "../types";

export const fetchChapters = async (): Promise<Chapter[]> => {
  try {
    const chaptersCol = collection(db, "chapters");
    const q = query(chaptersCol, orderBy("id", "asc"));
    const snapshot = await getDocs(q);

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
        } as Chapter)
    );
  } catch (error) {
    console.error("BÃ¶lÃ¼mler Ã§ekilirken hata oluÅŸtu:", error);
    return [];
  }
};

export const fetchLevels = async (chapterId: number): Promise<Level[]> => {
  try {
    const levelsCol = collection(
      db,
      "chapters",
      chapterId.toString(),
      "levels"
    );
    const q = query(levelsCol, orderBy("id", "asc"));
    const snapshot = await getDocs(q);

    return snapshot.docs.map(
      (doc) =>
        ({
          ...doc.data(),
        } as Level)
    );
  } catch (error) {
    console.error("Seviyeler Ã§ekilirken hata oluÅŸtu:", error);
    return [];
  }
};

export const fetchLevelDetails = async (
  chapterId: number,
  levelId: number
): Promise<Level | null> => {
  try {
    const levelDoc = await getDoc(
      doc(db, "chapters", chapterId.toString(), "levels", levelId.toString())
    );
    if (levelDoc.exists()) {
      return levelDoc.data() as Level;
    }
    return null;
  } catch (error) {
    console.error("Seviye detayÄ± Ã§ekilirken hata oluÅŸtu:", error);
    return null;
  }
};
</file>

<file path="src/services/deviceService.ts">
import * as Application from 'expo-application';
import { Platform } from 'react-native';

let cachedDeviceId: string | null = null;

export const getDeviceId = async (): Promise<string> => {
  if (cachedDeviceId) return cachedDeviceId;

  try {
    if (Platform.OS === 'android') {
      cachedDeviceId = Application.getAndroidId() || 'unknown-android';
    } else if (Platform.OS === 'ios') {
      cachedDeviceId = await Application.getIosIdForVendorAsync() || 'unknown-ios';
    } else {
      // Web fallback
      cachedDeviceId = `web-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
  } catch (error) {
    cachedDeviceId = `fallback-${Date.now()}`;
  }

  console.log('ğŸ“± Device ID:', cachedDeviceId);
  return cachedDeviceId;
};

export const getAppInfo = () => {
  return {
    name: Application.applicationName,
    version: Application.nativeApplicationVersion,
    buildVersion: Application.nativeBuildVersion,
  };
};
</file>

<file path="src/services/syncQueue.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import NetInfo from "@react-native-community/netinfo";
import { doc, getDoc, setDoc } from "firebase/firestore";
import { auth, db } from "../../firebaseConfig";

const SYNC_QUEUE_KEY = "@puzzle_sync_queue";

interface QueuedProgress {
  chapterId: number;
  levelId: number;
  moves: number;
  stars: number;
  timestamp: number;
}

/**
 * Add progress to offline sync queue
 */
export const queueProgressUpdate = async (
  chapterId: number,
  levelId: number,
  moves: number,
  stars: number
): Promise<void> => {
  try {
    const queueData = await AsyncStorage.getItem(SYNC_QUEUE_KEY);
    const queue: QueuedProgress[] = queueData ? JSON.parse(queueData) : [];

    const levelKey = `${chapterId}-${levelId}`;

    // Update or add to queue
    const existingIndex = queue.findIndex(
      (item) => `${item.chapterId}-${item.levelId}` === levelKey
    );

    const newItem: QueuedProgress = {
      chapterId,
      levelId,
      moves,
      stars,
      timestamp: Date.now(),
    };

    if (existingIndex >= 0) {
      // Update existing: keep best performance
      const existing = queue[existingIndex];
      queue[existingIndex] = {
        ...newItem,
        stars: Math.max(existing.stars, stars),
        moves: existing.moves === 0 ? moves : Math.min(existing.moves, moves),
      };
    } else {
      queue.push(newItem);
    }

    await AsyncStorage.setItem(SYNC_QUEUE_KEY, JSON.stringify(queue));
    console.log("ğŸ“¦ Queued progress:", levelKey, newItem);
  } catch (error) {
    console.error("Error queueing progress:", error);
  }
};

/**
 * Process sync queue when online
 */
export const processSyncQueue = async (): Promise<void> => {
  try {
    const user = auth.currentUser;
    if (!user) {
      console.log("âš ï¸ No user, skipping sync");
      return;
    }

    const netState = await NetInfo.fetch();
    if (!netState.isConnected) {
      console.log("âš ï¸ Offline, skipping sync");
      return;
    }

    const queueData = await AsyncStorage.getItem(SYNC_QUEUE_KEY);
    if (!queueData) {
      console.log("âœ… No queued progress to sync");
      return;
    }

    const queue: QueuedProgress[] = JSON.parse(queueData);
    if (queue.length === 0) {
      console.log("âœ… Queue empty");
      return;
    }

    console.log(`ğŸ”„ Syncing ${queue.length} queued progress items...`);

    // Get current cloud progress
    const userDoc = await getDoc(doc(db, "users", user.uid));
    const cloudData = userDoc.exists() ? userDoc.data() : {};
    const cloudProgress = cloudData.progress || {
      completedLevels: {},
      totalStars: 0,
      unlockedChapters: [1],
    };

    let totalStarsDiff = 0;
    const updates: any = {};

    // Merge queue with cloud
    for (const item of queue) {
      const levelKey = `${item.chapterId}-${item.levelId}`;
      const cloudLevel = cloudProgress.completedLevels[levelKey];

      let finalStars = item.stars;
      let finalMoves = item.moves;

      if (cloudLevel) {
        // Merge: take max stars, min moves
        finalStars = Math.max(cloudLevel.stars || 0, item.stars);
        finalMoves =
          cloudLevel.bestMoves === 0
            ? item.moves
            : Math.min(cloudLevel.bestMoves, item.moves);

        totalStarsDiff += finalStars - (cloudLevel.stars || 0);
      } else {
        totalStarsDiff += finalStars;
      }

      updates[levelKey] = {
        completed: true,
        stars: finalStars,
        bestMoves: finalMoves,
      };
    }

    // Update Firestore with merged data
    const firestoreUpdate = {
      progress: {
        completedLevels: {
          ...cloudProgress.completedLevels,
          ...updates,
        },
        totalStars: (cloudProgress.totalStars || 0) + totalStarsDiff,
        unlockedChapters: cloudProgress.unlockedChapters || [1],
      },
      lastUpdated: new Date().toISOString(),
    };

    await setDoc(doc(db, "users", user.uid), firestoreUpdate, { merge: true });

    // Clear queue
    await AsyncStorage.removeItem(SYNC_QUEUE_KEY);
    console.log(`âœ… Synced ${queue.length} items, cleared queue`);
  } catch (error) {
    console.error("âŒ Sync queue error:", error);
  }
};

/**
 * Setup network listener to auto-sync when online
 */
export const setupSyncListener = (): (() => void) => {
  const unsubscribe = NetInfo.addEventListener((state) => {
    if (state.isConnected) {
      console.log("ğŸŒ Network connected, processing sync queue...");
      processSyncQueue();
    }
  });

  // Process immediately if online
  NetInfo.fetch().then((state) => {
    if (state.isConnected) {
      processSyncQueue();
    }
  });

  return unsubscribe;
};
</file>

<file path="src/store/adStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";

// ==========================================
// AD CONFIGURATION
// ==========================================

export const AD_RULES = {
  // Interstitial rules
  interstitial: {
    excludedLevels: [
      { chapterId: 1, levelId: 1 },
      { chapterId: 1, levelId: 2 },
      { chapterId: 1, levelId: 3 },
      { chapterId: 1, levelId: 4 },
    ],
    minTimeBetweenAds: 300000, // 5 minutes between interstitial ads
    showOnLevelEntry: true, // Show when entering a level (not on completion)
  },

  // Rewarded rules
  rewarded: {
    enabled: true, // Rewarded ads for hints
  },

  // Banner rules
  banner: {
    showInGame: true, // Show banner at top of game screen
    showInChapters: false, // Don't show banner in chapters (use native ads instead)
  },

  // Native ads rules
  native: {
    showInChapters: true, // Show native ad in chapters screen
    showEveryNChapters: 4, // Show ad after every 4 chapters
  },
};

// ==========================================
// AD STATE INTERFACE
// ==========================================

interface AdState {
  // Last shown timestamps
  lastInterstitialShown: number;
  lastRewardedShown: number;

  // Ad readiness
  isInterstitialReady: boolean;
  isRewardedReady: boolean;
  isBannerReady: boolean;

  // Statistics
  totalInterstitialsShown: number;
  totalRewardedsShown: number;
  totalBannersShown: number;
}

interface AdActions {
  // Interstitial
  canShowInterstitial: (chapterId: number, levelId: number) => boolean;
  markInterstitialShown: () => void;
  setInterstitialReady: (ready: boolean) => void;

  // Rewarded
  canShowRewarded: () => boolean;
  markRewardedShown: () => void;
  setRewardedReady: (ready: boolean) => void;

  // Banner
  canShowBanner: () => boolean;
  setBannerReady: (ready: boolean) => void;

  // Native
  shouldShowNativeAdAtIndex: (index: number) => boolean;

  // Persistence
  loadAdState: () => Promise<void>;
  saveAdState: () => Promise<void>;
}

interface AdStore extends AdState {
  actions: AdActions;
}

// ==========================================
// STORAGE KEY
// ==========================================

const AD_STATE_KEY = "@puzzle_game_ad_state";

// ==========================================
// INITIAL STATE
// ==========================================

const initialState: AdState = {
  lastInterstitialShown: 0,
  lastRewardedShown: 0,
  isInterstitialReady: false,
  isRewardedReady: false,
  isBannerReady: false,
  totalInterstitialsShown: 0,
  totalRewardedsShown: 0,
  totalBannersShown: 0,
};

// ==========================================
// AD STORE
// ==========================================

export const useAdStore = create<AdStore>((set, get) => ({
  ...initialState,

  actions: {
    // ==========================================
    // INTERSTITIAL ADS
    // ==========================================

    canShowInterstitial: (chapterId: number, levelId: number) => {
      const state = get();

      // Check if this level is excluded
      const isExcluded = AD_RULES.interstitial.excludedLevels.some(
        (excluded) =>
          excluded.chapterId === chapterId && excluded.levelId === levelId,
      );

      if (isExcluded) {
        console.log(`ğŸ“º Level ${chapterId}-${levelId} is excluded from ads`);
        return false;
      }

      // Check if enough time has passed
      const now = Date.now();
      const timeSinceLastAd = now - state.lastInterstitialShown;
      if (timeSinceLastAd < AD_RULES.interstitial.minTimeBetweenAds) {
        const remainingSeconds = Math.ceil(
          (AD_RULES.interstitial.minTimeBetweenAds - timeSinceLastAd) / 1000,
        );
        console.log(`ğŸ“º Too soon for ad, wait ${remainingSeconds}s`);
        return false;
      }

      // Check if ad is ready
      if (!state.isInterstitialReady) {
        console.log("ğŸ“º Interstitial not ready");
        return false;
      }

      return true;
    },

    markInterstitialShown: () => {
      const now = Date.now();
      set((state) => ({
        lastInterstitialShown: now,
        totalInterstitialsShown: state.totalInterstitialsShown + 1,
        isInterstitialReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setInterstitialReady: (ready: boolean) => {
      set({ isInterstitialReady: ready });
    },

    // ==========================================
    // REWARDED ADS
    // ==========================================

    canShowRewarded: () => {
      const state = get();

      if (!AD_RULES.rewarded.enabled) {
        console.log("ğŸ Rewarded ads disabled");
        return false;
      }

      if (!state.isRewardedReady) {
        console.log("ğŸ Rewarded not ready");
        return false;
      }

      return true;
    },

    markRewardedShown: () => {
      const now = Date.now();
      set((state) => ({
        lastRewardedShown: now,
        totalRewardedsShown: state.totalRewardedsShown + 1,
        isRewardedReady: false, // Will be reloaded
      }));
      get().actions.saveAdState();
    },

    setRewardedReady: (ready: boolean) => {
      set({ isRewardedReady: ready });
    },

    // ==========================================
    // BANNER ADS
    // ==========================================

    canShowBanner: () => {
      const state = get();
      return AD_RULES.banner.showInGame && state.isBannerReady;
    },

    setBannerReady: (ready: boolean) => {
      set({ isBannerReady: ready });
    },

    // ==========================================
    // NATIVE ADS
    // ==========================================

    shouldShowNativeAdAtIndex: (index: number) => {
      if (!AD_RULES.native.showInChapters) return false;

      // Show ad every N chapters (e.g., after chapter 4, 8, 12, etc.)
      // Index is 0-based, so we add 1
      const chapterNumber = index + 1;
      return chapterNumber % AD_RULES.native.showEveryNChapters === 0;
    },

    // ==========================================
    // PERSISTENCE
    // ==========================================

    loadAdState: async () => {
      try {
        const stored = await AsyncStorage.getItem(AD_STATE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          set({
            lastInterstitialShown: parsed.lastInterstitialShown || 0,
            lastRewardedShown: parsed.lastRewardedShown || 0,
            totalInterstitialsShown: parsed.totalInterstitialsShown || 0,
            totalRewardedsShown: parsed.totalRewardedsShown || 0,
            totalBannersShown: parsed.totalBannersShown || 0,
          });
          console.log("ğŸ“º Ad state loaded from storage");
        }
      } catch (error) {
        console.error("ğŸ“º Failed to load ad state:", error);
      }
    },

    saveAdState: async () => {
      try {
        const state = get();
        const toSave = {
          lastInterstitialShown: state.lastInterstitialShown,
          lastRewardedShown: state.lastRewardedShown,
          totalInterstitialsShown: state.totalInterstitialsShown,
          totalRewardedsShown: state.totalRewardedsShown,
          totalBannersShown: state.totalBannersShown,
        };
        await AsyncStorage.setItem(AD_STATE_KEY, JSON.stringify(toSave));
      } catch (error) {
        console.error("ğŸ“º Failed to save ad state:", error);
      }
    },
  },
}));

// ==========================================
// HOOKS
// ==========================================

export const useAdActions = () => useAdStore((state) => state.actions);
export const useIsInterstitialReady = () =>
  useAdStore((state) => state.isInterstitialReady);
export const useIsRewardedReady = () =>
  useAdStore((state) => state.isRewardedReady);
export const useIsBannerReady = () =>
  useAdStore((state) => state.isBannerReady);
</file>

<file path="src/store/hintStore.ts">
import { create } from 'zustand';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { STORAGE_KEYS, HINT_CONFIG } from '../constants/gameConfig';

interface HintState {
  hintCount: number;
  isLoaded: boolean;
}

interface HintActions {
  loadHints: () => Promise<void>;
  saveHints: () => Promise<void>;
  useHint: () => boolean;
  addHints: (amount: number) => void;
  addChapterBonus: () => void;
  resetHints: () => void;
}

interface HintStore extends HintState {
  actions: HintActions;
}

export const useHintStore = create<HintStore>((set, get) => ({
  hintCount: HINT_CONFIG.defaultHints,
  isLoaded: false,

  actions: {
    loadHints: async () => {
      try {
        const stored = await AsyncStorage.getItem(STORAGE_KEYS.HINT_COUNT);
        if (stored) {
          set({ hintCount: parseInt(stored, 10), isLoaded: true });
        } else {
          set({ isLoaded: true });
        }
      } catch {
        set({ isLoaded: true });
      }
    },

    saveHints: async () => {
      try {
        const { hintCount } = get();
        await AsyncStorage.setItem(STORAGE_KEYS.HINT_COUNT, hintCount.toString());
      } catch {}
    },

    useHint: () => {
      const { hintCount } = get();
      if (hintCount <= 0) return false;

      set({ hintCount: hintCount - 1 });
      get().actions.saveHints();
      return true;
    },

    addHints: (amount: number) => {
      const { hintCount } = get();
      set({ hintCount: hintCount + amount });
      get().actions.saveHints();
    },

    addChapterBonus: () => {
      get().actions.addHints(HINT_CONFIG.chapterBonus);
    },

    resetHints: () => {
      set({ hintCount: HINT_CONFIG.defaultHints });
      get().actions.saveHints();
    },
  },
}));

export const useHintCount = () => useHintStore((state) => state.hintCount);
export const useHintActions = () => useHintStore((state) => state.actions);
</file>

<file path="src/store/settingsStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";

interface SettingsState {
  hapticsEnabled: boolean;
  musicEnabled: boolean;
  soundEnabled: boolean;

  actions: {
    toggleHaptics: () => void;
    toggleMusic: () => void;
    toggleSound: () => void;
  };
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      hapticsEnabled: true,
      musicEnabled: false, // Default off as per request "ÅŸuan yok ama bir mÃ¼zik koyacaÄŸÄ±z" music close
      soundEnabled: true,

      actions: {
        toggleHaptics: () =>
          set((state) => ({ hapticsEnabled: !state.hapticsEnabled })),
        toggleMusic: () =>
          set((state) => ({ musicEnabled: !state.musicEnabled })),
        toggleSound: () =>
          set((state) => ({ soundEnabled: !state.soundEnabled })),
      },
    }),
    {
      name: "settings-storage",
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        hapticsEnabled: state.hapticsEnabled,
        musicEnabled: state.musicEnabled,
        soundEnabled: state.soundEnabled,
      }),
    },
  ),
);

// Selector hooks for convenience
export const useSettingsActions = () =>
  useSettingsStore((state) => state.actions);
export const useHapticsEnabled = () =>
  useSettingsStore((state) => state.hapticsEnabled);
export const useMusicEnabled = () =>
  useSettingsStore((state) => state.musicEnabled);
export const useSoundEnabled = () =>
  useSettingsStore((state) => state.soundEnabled);
</file>

<file path="src/utils/puzzleLogic.ts">
import { GridSize, TilePosition } from "../types";

export const createSolvedGrid = (gridSize: GridSize): number[] => {
  const totalTiles = gridSize.cols * gridSize.rows;
  return Array.from({ length: totalTiles }, (_, i) => i);
};

export const indexToPosition = (
  index: number,
  gridSize: GridSize
): TilePosition => ({
  row: Math.floor(index / gridSize.cols),
  col: index % gridSize.cols,
});

export const positionToIndex = (
  position: TilePosition,
  gridSize: GridSize
): number => {
  return position.row * gridSize.cols + position.col;
};

export const getAdjacentIndices = (
  index: number,
  gridSize: GridSize
): number[] => {
  const { row, col } = indexToPosition(index, gridSize);
  const adjacent: number[] = [];

  if (row > 0) adjacent.push(positionToIndex({ row: row - 1, col }, gridSize));
  if (row < gridSize.rows - 1)
    adjacent.push(positionToIndex({ row: row + 1, col }, gridSize));
  if (col > 0) adjacent.push(positionToIndex({ row, col: col - 1 }, gridSize));
  if (col < gridSize.cols - 1)
    adjacent.push(positionToIndex({ row, col: col + 1 }, gridSize));

  return adjacent;
};

export const canMoveTile = (
  tileIndex: number,
  emptyIndex: number,
  gridSize: GridSize
): boolean => {
  return getAdjacentIndices(emptyIndex, gridSize).includes(tileIndex);
};

export const swapTiles = (
  grid: number[],
  index1: number,
  index2: number
): number[] => {
  const newGrid = [...grid];
  [newGrid[index1], newGrid[index2]] = [newGrid[index2], newGrid[index1]];
  return newGrid;
};

export const performMove = (
  grid: number[],
  tileIndex: number,
  emptyIndex: number,
  gridSize: GridSize
): { grid: number[]; emptyIndex: number; moved: boolean } => {
  if (!canMoveTile(tileIndex, emptyIndex, gridSize)) {
    return { grid, emptyIndex, moved: false };
  }
  const newGrid = swapTiles(grid, tileIndex, emptyIndex);
  return { grid: newGrid, emptyIndex: tileIndex, moved: true };
};

export const shuffleGrid = (
  gridSize: GridSize
): { grid: number[]; emptyIndex: number } => {
  let grid = createSolvedGrid(gridSize);
  const totalTiles = gridSize.cols * gridSize.rows;
  let emptyIndex = totalTiles - 1;
  const moves = totalTiles * 5; // Dynamic shuffle count
  let lastMove = -1;

  for (let i = 0; i < moves; i++) {
    const adjacent = getAdjacentIndices(emptyIndex, gridSize);
    const validMoves = adjacent.filter((idx) => idx !== lastMove);
    const randomIndex = Math.floor(Math.random() * validMoves.length);
    const tileToMove = validMoves[randomIndex];
    lastMove = emptyIndex;
    grid = swapTiles(grid, tileToMove, emptyIndex);
    emptyIndex = tileToMove;
  }

  return { grid, emptyIndex };
};

export const isSolved = (grid: number[]): boolean => {
  for (let i = 0; i < grid.length; i++) {
    if (grid[i] !== i) return false;
  }
  return true;
};

export const getProgressPercentage = (grid: number[]): number => {
  let correct = 0;
  for (let i = 0; i < grid.length; i++) {
    if (grid[i] === i) correct++;
  }
  return Math.round((correct / grid.length) * 100);
};

export const calculateTilePosition = (
  index: number,
  gridSize: GridSize,
  tileSize: number,
  gap: number
): { x: number; y: number } => {
  const { row, col } = indexToPosition(index, gridSize);
  return {
    x: col * (tileSize + gap),
    y: row * (tileSize + gap),
  };
};

export const calculateImageOffset = (
  tileValue: number,
  gridSize: GridSize,
  tileSize: number
): { top: number; left: number } => {
  const { row, col } = indexToPosition(tileValue, gridSize);
  return {
    top: -(row * tileSize),
    left: -(col * tileSize),
  };
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# generated native folders
/ios
/android

/legacy
</file>

<file path="app/game/jigsaw/[chapterId]/[levelId].tsx">
import { Ionicons } from "@expo/vector-icons";
import { DotLottie } from "@lottiefiles/dotlottie-react-native";
import { Image } from "expo-image";
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { useEffect, useState } from "react";
import {
  ActivityIndicator,
  Modal,
  StyleSheet,
  Text,
  TouchableOpacity,
  useWindowDimensions,
  View,
} from "react-native";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import Animated, {
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";

// Stores & Hooks
import {
  calculateStars,
  COLORS,
  LEVELS_PER_CHAPTER,
  TOTAL_CHAPTERS,
} from "@/src/constants/gameConfig";
import { useJigsawStore } from "@/src/modules/jigsaw/jigsawStore";
import { useAdStore } from "@/src/store/adStore";
import { useDataActions } from "@/src/store/dataStore";

// Components
import GameBannerAd from "@/src/components/GameBannerAd";
import GameSettingsMenu from "@/src/components/GameSettingsMenu";
import JigsawBoard from "@/src/modules/jigsaw/JigsawBoard";
import { useProgressActions } from "@/src/store/progressStore";
import { Level } from "@/src/types";

export default function JigsawGameScreen() {
  const router = useRouter();
  const { width, height } = useWindowDimensions();
  const insets = useSafeAreaInsets();

  const params = useLocalSearchParams<{
    chapterId: string;
    levelId: string;
  }>();

  // Local state for infinite scrolling
  const [currentChapter, setCurrentChapter] = useState(
    Number(params.chapterId),
  );
  const [currentLevelId, setCurrentLevelId] = useState(Number(params.levelId));

  const { getLevelById, getChapters } = useDataActions();
  const { completeLevel } = useProgressActions();
  const resetGame = useJigsawStore((state) => state.actions.resetGame);
  const status = useJigsawStore((state) => state.status);
  const moves = useJigsawStore((state) => state.moves);
  const isInitialized = useJigsawStore((state) => state.isInitialized);
  const initializeLevel = useJigsawStore(
    (state) => state.actions.initializeLevel,
  );
  const canShowBanner = useAdStore((state) => state.actions.canShowBanner);

  const [level, setLevel] = useState<Level | undefined>();
  const [prevLevel, setPrevLevel] = useState<Level | undefined>(); // For visual transition
  const [isLoading, setIsLoading] = useState(true);
  const [showPreview, setShowPreview] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showContinue, setShowContinue] = useState(false);

  // Vertical Scroll Transition
  const scrollTranslateY = useSharedValue(0);

  // Win Animation SharedValues
  const headerTranslateY = useSharedValue(0);
  const movesTranslateY = useSharedValue(0);
  const star1Scale = useSharedValue(0);
  const star2Scale = useSharedValue(0);
  const star3Scale = useSharedValue(0);
  const boardScale = useSharedValue(1);
  const boardTranslateY = useSharedValue(0);
  const continueButtonScale = useSharedValue(0);

  const [earnedStars, setEarnedStars] = useState(0);

  // Initialize Data (Initial Load)
  useEffect(() => {
    const initData = async () => {
      await getChapters();
      loadLevel(currentChapter, currentLevelId);
    };
    initData();
  }, []);

  const loadLevel = async (chapId: number, lvlId: number) => {
    setIsLoading(true);
    const l = await getLevelById(chapId, lvlId);
    if (l) {
      // Initialize game logic BEFORE hiding loader
      initializeLevel(l.gridSize);
    }
    setLevel(l);
    setIsLoading(false);
  };

  useEffect(() => {
    if (status === "won" && level) {
      // 0. Save Progress
      completeLevel(currentChapter, currentLevelId, moves, level.gridSize);

      // 1. Trigger background prefetch for next level image
      const prefetchNextLevel = async () => {
        try {
          const cLvl = currentLevelId;
          const cChap = currentChapter;
          let nextChapter = cChap;
          let nextLevel = cLvl + 1;

          if (nextLevel > LEVELS_PER_CHAPTER) {
            nextChapter++;
            nextLevel = 1;
          }
          if (nextChapter > TOTAL_CHAPTERS) return;

          const nextLvl = await getLevelById(nextChapter, nextLevel);

          if (nextLvl?.imageSource) {
            const source = nextLvl.imageSource;
            if (typeof source === "object" && "uri" in source && source.uri) {
              await Image.prefetch(source.uri);
            }
          }
        } catch (e) {}
      };
      prefetchNextLevel();

      // Delay before starting win sequence
      const timer = setTimeout(() => {
        // Calculate stars
        const stars = calculateStars(moves, level.gridSize);
        setEarnedStars(stars);

        // Animations
        headerTranslateY.value = withTiming(-100, { duration: 400 });
        movesTranslateY.value = withTiming(-30, { duration: 500 });
        boardScale.value = withTiming(0.85, { duration: 500 });
        boardTranslateY.value = withTiming(-60, { duration: 500 });

        setTimeout(() => {
          star1Scale.value = withTiming(1, { duration: 300 });
        }, 400);
        setTimeout(() => {
          star2Scale.value = withTiming(1, { duration: 300 });
        }, 600);
        setTimeout(() => {
          star3Scale.value = withTiming(1, { duration: 300 });
        }, 800);

        setTimeout(() => {
          setShowContinue(true);
          continueButtonScale.value = withTiming(1, { duration: 400 });
        }, 1200);
      }, 800);
      return () => clearTimeout(timer);
    }
  }, [status]);

  const handleBack = () => {
    router.back();
  };

  const handleNextLevel = async () => {
    if (!level) return;

    // 1. Determine Next Level IDs
    let nextChapter = currentChapter;
    let nextLevel = currentLevelId + 1;

    if (nextLevel > LEVELS_PER_CHAPTER) {
      nextChapter++;
      nextLevel = 1;
    }

    if (nextChapter > TOTAL_CHAPTERS) {
      router.back();
      return;
    }

    // 2. Prepare Transition State
    // "Snapshot" current won level as Previous
    setPrevLevel(level);

    // Fetch Next Level Data *before* resetting visuals completely if possible,
    // or show loading on the next page.
    // For smoothness, we want the next board ready.
    const nextLvlData = await getLevelById(nextChapter, nextLevel);

    if (!nextLvlData) {
      setIsLoading(false); // Error case
      return;
    }

    // 3. Reset UI & Store for NEXT Level
    // The "PrevLevel" view will stick to screen, hiding this reset.
    resetGame();
    initializeLevel(nextLvlData.gridSize);

    // Reset Win UI
    setShowContinue(false);
    setEarnedStars(0);
    headerTranslateY.value = 0;
    movesTranslateY.value = 0;
    boardScale.value = 1;
    boardTranslateY.value = 0;
    continueButtonScale.value = 0;
    star1Scale.value = 0;
    star2Scale.value = 0;
    star3Scale.value = 0;

    // Update Main Level State (This renders the NEW board at the "Bottom" view)
    setLevel(nextLvlData);
    setCurrentChapter(nextChapter);
    setCurrentLevelId(nextLevel);

    // 4. Animate Scroll (Move Up)
    // Container is at 0 (showing Prev). We want to move to -height (showing Next).
    scrollTranslateY.value = withTiming(
      -height,
      { duration: 600 },
      (finished) => {
        if (finished) {
          runOnJS(cleanUpTransition)();
        }
      },
    );
  };

  const cleanUpTransition = () => {
    // Reset Scroll to 0 (Now "Next" becomes "Current" visually)
    scrollTranslateY.value = 0;
    // Remove "Prev" view
    setPrevLevel(undefined);
  };

  const handleReplay = () => {
    headerTranslateY.value = 0;
    boardScale.value = 1;
    boardTranslateY.value = 0;
    continueButtonScale.value = 0;
    setShowContinue(false);
    star1Scale.value = 0;
    star2Scale.value = 0;
    star3Scale.value = 0;

    resetGame();
    if (level) {
      initializeLevel(level.gridSize);
    }
  };

  // Animated Styles
  const scrollStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: scrollTranslateY.value }],
  }));

  const headerAnimatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: headerTranslateY.value }],
  }));
  const movesAnimatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: movesTranslateY.value }],
  }));
  const star1Style = useAnimatedStyle(() => ({
    transform: [{ scale: star1Scale.value }],
  }));
  const star2Style = useAnimatedStyle(() => ({
    transform: [{ scale: star2Scale.value }],
  }));
  const star3Style = useAnimatedStyle(() => ({
    transform: [{ scale: star3Scale.value }],
  }));
  const boardAnimatedStyle = useAnimatedStyle(() => ({
    transform: [
      { scale: boardScale.value },
      { translateY: boardTranslateY.value },
    ],
  }));
  const continueButtonStyle = useAnimatedStyle(() => ({
    transform: [{ scale: continueButtonScale.value }],
  }));

  // Layout Calculations
  const HEADER_HEIGHT = 60;
  const MOVES_HEIGHT = 80;
  const BANNER_HEIGHT = canShowBanner() ? 60 : 0;
  const topInset = insets.top;
  const contentTopStart = topInset + HEADER_HEIGHT + MOVES_HEIGHT - 20;
  const bottomSpace = canShowBanner() ? BANNER_HEIGHT : insets.bottom;
  const boardHeight = height - contentTopStart - bottomSpace;

  // Render Inner Content (The Game)
  // We extract this to render it twice (once for prev, once for next)
  // BUT 'prev' is static image, 'next' is interactive board.
  // So we handle them explicitly.

  if (isLoading && !level) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  return (
    <GestureHandlerRootView
      style={{ flex: 1, backgroundColor: COLORS.background }}
    >
      <Stack.Screen options={{ headerShown: false }} />

      {/* Main Vertical Scroll Container */}
      <Animated.View style={[{ flex: 1 }, scrollStyle]}>
        {/* VIEW 1: PREVIOUS LEVEL (Only visible during transition) */}
        {prevLevel && (
          <View
            style={{ width, height, position: "absolute", top: 0, left: 0 }}
          >
            {/* Just the Image as "Won State" */}
            <View style={styles.header}>
              {/* Dummy Header for visuals */}
              <View style={styles.headerCenter}>
                <Text style={styles.headerTitle}>{prevLevel.name}</Text>
              </View>
            </View>
            <View
              style={{
                flex: 1,
                justifyContent: "center",
                alignItems: "center",
              }}
            >
              <Image
                source={prevLevel.imageSource}
                style={{ width: width - 40, height: boardHeight }}
                contentFit="contain"
              />
            </View>
          </View>
        )}

        {/* VIEW 2: CURRENT / NEXT LEVEL (Bottom if transition, or Top if normal) */}
        <View
          style={{
            width,
            height,
            marginTop: prevLevel ? height : 0, // Push down if prev exists
          }}
        >
          {/* Confetti (Only for current active game) */}
          {status === "won" && (
            <View style={styles.confettiContainer} pointerEvents="none">
              <DotLottie
                source={require("@/src/assets/animations/confettie.lottie")}
                style={{ flex: 1 }}
                autoplay
                loop={false}
              />
            </View>
          )}

          {/* HEADER */}
          <Animated.View
            style={[
              styles.header,
              { top: insets.top, height: HEADER_HEIGHT },
              headerAnimatedStyle,
            ]}
          >
            <View style={styles.headerLeftGroups}>
              <TouchableOpacity onPress={handleBack} style={styles.headerBtn}>
                <Ionicons
                  name="chevron-back"
                  size={28}
                  color={COLORS.textPrimary}
                />
              </TouchableOpacity>
              <TouchableOpacity onPress={handleReplay} style={styles.headerBtn}>
                <Ionicons name="refresh" size={24} color={COLORS.textPrimary} />
              </TouchableOpacity>
            </View>
            <View style={styles.headerCenter}>
              <Text style={styles.headerTitle} numberOfLines={1}>
                {level?.name || `Level ${currentLevelId}`}
              </Text>
            </View>
            <View style={styles.headerRightGroups}>
              <TouchableOpacity
                onPress={() => setShowPreview(true)}
                style={styles.headerBtn}
              >
                {level && (
                  <Image
                    source={level.imageSource}
                    style={styles.thumbnail}
                    contentFit="cover"
                  />
                )}
              </TouchableOpacity>
              <TouchableOpacity
                onPress={() => setShowSettings(true)}
                style={styles.headerBtn}
              >
                <Ionicons
                  name="settings-sharp"
                  size={24}
                  color={COLORS.textPrimary}
                />
              </TouchableOpacity>
            </View>
          </Animated.View>

          {/* STATS */}
          <View
            style={[
              styles.statsContainer,
              { top: topInset + HEADER_HEIGHT, height: MOVES_HEIGHT },
            ]}
          >
            <Animated.View style={[styles.movesBlock, movesAnimatedStyle]}>
              <Text style={styles.movesValueBig}>{moves}</Text>
              <Text style={styles.movesLabelSmall}>HAMLE</Text>
            </Animated.View>
            <View style={styles.starsRow}>
              <Animated.View style={star1Style}>
                <Ionicons
                  name="star"
                  size={48}
                  color={
                    earnedStars >= 1 ? COLORS.starFilled : COLORS.starEmpty
                  }
                />
              </Animated.View>
              <Animated.View style={[star2Style, { marginTop: -20 }]}>
                <Ionicons
                  name="star"
                  size={64}
                  color={
                    earnedStars >= 2 ? COLORS.starFilled : COLORS.starEmpty
                  }
                />
              </Animated.View>
              <Animated.View style={star3Style}>
                <Ionicons
                  name="star"
                  size={48}
                  color={
                    earnedStars >= 3 ? COLORS.starFilled : COLORS.starEmpty
                  }
                />
              </Animated.View>
            </View>
          </View>

          {/* BOARD */}
          <Animated.View
            style={[
              styles.gameArea,
              { marginTop: contentTopStart, height: boardHeight },
              boardAnimatedStyle,
            ]}
          >
            {level && (
              <JigsawBoard
                gridSize={level.gridSize}
                imageSource={level.imageSource}
                boardWidth={width}
                boardHeight={boardHeight}
              />
            )}
          </Animated.View>

          {/* CONTINUE BUTTON */}
          {showContinue && (
            <Animated.View
              style={[styles.continueContainer, continueButtonStyle]}
            >
              <TouchableOpacity
                style={styles.continueButton}
                onPress={handleNextLevel}
              >
                <Text style={styles.continueText}>SONRAKÄ°</Text>
                <Ionicons name="arrow-down" size={20} color="white" />
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.replayButton}
                onPress={handleReplay}
              >
                <Ionicons
                  name="refresh"
                  size={18}
                  color={COLORS.textSecondary}
                />
                <Text style={styles.replayText}>Replay</Text>
              </TouchableOpacity>
            </Animated.View>
          )}
        </View>
      </Animated.View>

      {/* GLOBAL MODALS (Outside Scroll) */}
      <Modal
        visible={showPreview}
        transparent
        animationType="fade"
        onRequestClose={() => setShowPreview(false)}
      >
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setShowPreview(false)}
        >
          <View style={styles.previewContainer}>
            {level && (
              <Image
                source={level.imageSource}
                style={{ width: width * 0.9, height: height * 0.6 }}
                contentFit="contain"
              />
            )}
            <Text style={styles.previewText}>Tap to Close</Text>
          </View>
        </TouchableOpacity>
      </Modal>

      <GameSettingsMenu
        visible={showSettings}
        onClose={() => setShowSettings(false)}
      />

      <View style={styles.bottomBanner}>
        <GameBannerAd />
      </View>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: COLORS.background,
  },
  header: {
    position: "absolute",
    left: 0,
    right: 0,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 8,
    zIndex: 100,
  },
  headerLeftGroups: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  headerRightGroups: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  headerBtn: {
    padding: 8,
  },
  headerTitle: {
    fontSize: 22,
    fontWeight: "bold",
    color: COLORS.textPrimary,
  },
  thumbnail: {
    width: 32,
    height: 32,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  bannerContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "transparent",
    zIndex: 90,
  },
  gameArea: {
    width: "100%",
    backgroundColor: "transparent",
    overflow: "hidden",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
  },
  previewContainer: {
    alignItems: "center",
    justifyContent: "center",
  },
  previewText: {
    color: COLORS.textPrimary,
    marginTop: 20,
    fontSize: 16,
    opacity: 0.8,
  },
  continueContainer: {
    position: "absolute",
    bottom: 80,
    left: 0,
    right: 0,
    alignItems: "center",
    gap: 12,
  },
  continueButton: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    backgroundColor: COLORS.accent,
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 30,
  },
  continueText: {
    color: COLORS.textPrimary,
    fontSize: 18,
    fontWeight: "bold",
  },
  replayButton: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  replayText: {
    color: COLORS.textMuted,
    fontSize: 14,
  },
  bottomBanner: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    alignItems: "center",
    zIndex: 999,
    backgroundColor: "transparent",
  },
  statsContainer: {
    position: "absolute",
    left: 0,
    right: 0,
    alignItems: "center",
    zIndex: 95,
    pointerEvents: "none",
  },
  movesBlock: {
    alignItems: "center",
  },
  movesValueBig: {
    fontSize: 32,
    fontWeight: "800",
    color: COLORS.textPrimary,
    textShadowColor: "rgba(0,0,0,0.1)",
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 2,
  },
  movesLabelSmall: {
    fontSize: 12,
    fontWeight: "600",
    color: COLORS.textSecondary,
    marginTop: -2,
    letterSpacing: 1,
  },
  starsRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 2,
    marginTop: 8,
  },
  headerCenter: {
    alignItems: "center",
  },
  confettiContainer: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
  },
});
</file>

<file path="metro.config.js">
const { getDefaultConfig } = require("expo/metro-config");

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

config.resolver.sourceExts.push("mjs");
config.resolver.assetExts.push("lottie"); // Add .lottie support

module.exports = config;
</file>

<file path="src/components/GameBannerAd.tsx">
import React, { useEffect, useState } from "react";
import { Platform, StyleSheet, View } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";
import { useAdActions, useIsBannerReady } from "../store/adStore";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let BannerAd: any = null;
let BannerAdSize: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  BannerAd = admob.BannerAd;
  BannerAdSize = admob.BannerAdSize;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
} catch (error) {
  console.log("ğŸ“º AdMob not available for banner");
  isAdMobAvailable = false;
}

// ==========================================
// BANNER AD COMPONENT
// ==========================================

interface GameBannerAdProps {
  onAdLoaded?: () => void;
  onAdFailedToLoad?: () => void;
}

const GameBannerAd: React.FC<GameBannerAdProps> = ({
  onAdLoaded,
  onAdFailedToLoad,
}) => {
  const adActions = useAdActions();
  const isBannerReady = useIsBannerReady();
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (isAdMobAvailable) {
      setIsVisible(true);
    }
  }, []);

  if (!isAdMobAvailable || !BannerAd || !BannerAdSize) {
    return null;
  }

  const getBannerId = () => {
    if (__DEV__ && TestIds) return TestIds.BANNER;
    return Platform.OS === "ios"
      ? AD_CONFIG.banner.ios
      : AD_CONFIG.banner.android;
  };

  const handleAdLoaded = () => {
    console.log("ğŸ“º Banner ad loaded");
    adActions.setBannerReady(true);
    onAdLoaded?.();
  };

  const handleAdFailedToLoad = (error: any) => {
    console.log("ğŸ“º Banner ad failed to load:", error);
    adActions.setBannerReady(false);
    onAdFailedToLoad?.();
  };

  if (!isVisible) return null;

  return (
    <View style={styles.bannerContainer}>
      <BannerAd
        unitId={getBannerId()}
        size={BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
        requestOptions={{
          requestNonPersonalizedAdsOnly: false,
        }}
        onAdLoaded={handleAdLoaded}
        onAdFailedToLoad={handleAdFailedToLoad}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  bannerContainer: {
    width: "100%",
    alignItems: "center",
    borderTopWidth: 1,
  },
});

export default GameBannerAd;
</file>

<file path="src/components/PuzzleBoard.tsx">
import React, { useMemo } from "react";
import { StyleSheet, View } from "react-native";
import { BOARD_PADDING, COLORS, TILE_GAP } from "../constants/gameConfig";
import { useGameStore } from "../store/gameStore";
import { GridSize, ImageSource } from "../types";
import Tile from "./Tile";

interface PuzzleBoardProps {
  grid: number[];
  gridSize: GridSize;
  imageSource: ImageSource;
  onTilePress: (index: number) => void;
  boardSize?: number;
}

const PuzzleBoard: React.FC<PuzzleBoardProps> = ({
  grid,
  gridSize,
  imageSource,
  onTilePress,
  boardSize: propBoardSize,
}) => {
  const boardWidth = propBoardSize ? propBoardSize - BOARD_PADDING * 2 : 340;
  // Calculate tile size based on width and columns
  const totalGapX = TILE_GAP * (gridSize.cols - 1);
  const tileSize = (boardWidth - totalGapX) / gridSize.cols;

  // Calculate height based on rows
  const totalGapY = TILE_GAP * (gridSize.rows - 1);
  const boardHeight = tileSize * gridSize.rows + totalGapY;

  const emptyTileValue = gridSize.cols * gridSize.rows - 1;
  const hintedTiles = useGameStore((state) => state.hintedTiles);

  const tiles = useMemo(() => {
    return grid.map((value, index) => (
      <Tile
        key={value}
        index={index}
        value={value}
        gridSize={gridSize}
        tileSize={tileSize} // Pass pre-calculated size
        imageSource={imageSource}
        isEmpty={value === emptyTileValue}
        isHinted={hintedTiles.includes(value)}
        onPress={onTilePress}
      />
    ));
  }, [
    grid,
    gridSize,
    tileSize,
    imageSource,
    emptyTileValue,
    onTilePress,
    hintedTiles,
  ]);

  return (
    <View style={styles.container}>
      <View style={[styles.board, { width: boardWidth, height: boardHeight }]}>
        {tiles}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center",
    padding: BOARD_PADDING,
  },
  board: {
    backgroundColor: COLORS.surface,
    borderRadius: 6, // Reduced from 16 to match TILE_BORDER_RADIUS
    overflow: "hidden",
    position: "relative",
  },
});

export default PuzzleBoard;
</file>

<file path="src/components/Tile.tsx">
import { Image } from "expo-image";
import React, { memo } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} from "react-native-reanimated";
import { COLORS, TILE_BORDER_RADIUS, TILE_GAP } from "../constants/gameConfig";
import { GridSize, ImageSource } from "../types";
import {
  calculateImageOffset,
  calculateTilePosition,
} from "../utils/puzzleLogic";

interface TileProps {
  index: number;
  value: number;
  gridSize: GridSize;
  tileSize: number;
  imageSource: ImageSource;
  isEmpty: boolean;
  isHinted?: boolean;
  onPress: (index: number) => void;
}

const AnimatedTouchable = Animated.createAnimatedComponent(TouchableOpacity);

const Tile: React.FC<TileProps> = ({
  index,
  value,
  gridSize,
  tileSize,
  imageSource,
  isEmpty,
  isHinted,
  onPress,
}) => {
  const position = calculateTilePosition(index, gridSize, tileSize, TILE_GAP);
  const imageOffset = calculateImageOffset(value, gridSize, tileSize);
  const scale = useSharedValue(1);

  const animatedContainerStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: withTiming(position.x, { duration: 120 }) },
      { translateY: withTiming(position.y, { duration: 120 }) },
      { scale: scale.value },
    ],
  }));

  const handlePressIn = () => {
    scale.value = withTiming(0.95, { duration: 100 });
  };

  const handlePressOut = () => {
    scale.value = withTiming(1, { duration: 100 });
  };

  if (isEmpty) return null;

  return (
    <AnimatedTouchable
      style={[
        styles.tileContainer,
        { width: tileSize, height: tileSize },
        animatedContainerStyle,
      ]}
      onPress={() => onPress(index)}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      activeOpacity={0.9}
    >
      <View
        style={[styles.imageContainer, { borderRadius: TILE_BORDER_RADIUS }]}
      >
        <Image
          source={imageSource}
          style={[
            styles.image,
            {
              width: gridSize.cols * tileSize + (gridSize.cols - 1) * TILE_GAP, // Approx full image width
              height: gridSize.rows * tileSize + (gridSize.rows - 1) * TILE_GAP,
              top: imageOffset.top,
              left: imageOffset.left,
            },
          ]}
          contentFit="cover"
          transition={0}
        />
      </View>
      <View
        style={[
          styles.borderOverlay,
          { borderRadius: TILE_BORDER_RADIUS },
          // Green border if tile is in correct position
          value === index && {
            borderColor: "#22c55e",
            borderWidth: 3,
          },
        ]}
      />
      {/* Show position indicator for hinted tiles in wrong position */}
      {isHinted && value !== index && (
        <View style={styles.positionOverlay}>
          <Text style={styles.positionText}>
            {Math.floor(value / gridSize.cols) + 1}-
            {(value % gridSize.cols) + 1}
          </Text>
        </View>
      )}
    </AnimatedTouchable>
  );
};

const styles = StyleSheet.create({
  tileContainer: { position: "absolute" },
  imageContainer: { flex: 1, overflow: "hidden" },
  image: { position: "absolute" },
  borderOverlay: {
    ...StyleSheet.absoluteFillObject,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  positionOverlay: {
    position: "absolute",
    bottom: 2,
    alignSelf: "center",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    paddingHorizontal: 6,
    paddingVertical: 4,
    borderRadius: 6,
  },
  positionText: {
    color: "#fff",
    fontSize: 12,
    fontWeight: "900",
  },
});

export default memo(Tile, (prev, next) => {
  return (
    prev.index === next.index &&
    prev.value === next.value &&
    prev.isEmpty === next.isEmpty &&
    prev.gridSize.cols === next.gridSize.cols &&
    prev.gridSize.rows === next.gridSize.rows &&
    prev.tileSize === next.tileSize &&
    prev.isHinted === next.isHinted
  );
});
</file>

<file path="src/constants/colors.ts">
// Comprehensive Color Palette
const PALETTE = {
  // Brand Colors
  turquoise: "#4bc9c3", // Background
  sunflower: "#f9cd46", // Buttons
  coral: "#fc7e68", // Transitions, specific Text, Borders

  // Neutral Colors
  white: "#ffffff",
  black: "#000000",
  grayStart: "#333333", // Legacy dark border
  grayDark: "#1a1a1a", // Legacy surface

  // Functional
  emerald: "#10b981", // Success
  red: "#ef4444", // Error
  amber: "#f59e0b", // Warning
};

export const COLORS = {
  // Main Theme
  background: PALETTE.turquoise,
  surface: PALETTE.white, // Cleaner look on turquoise
  card: "rgba(255, 255, 255, 0.9)", // For overlays/cards

  // Interactive
  primary: PALETTE.sunflower,
  primaryText: PALETTE.black, // Text on primary button

  secondary: PALETTE.coral,
  secondaryText: PALETTE.white,

  // Text & Borders
  textPrimary: "#493f3fff", // Default text on turquoise bg (often needs to be white or very dark) - reverting to white for contrast or dark if needed.
  // Let's stick to what fits #4bc9c3. White text is readable on dark turquoise, but #4bc9c3 is bright.
  // Black text is safer on #4bc9c3.
  // HOWEVER, existing app was Dark Mode (#0a0a0a). Switching to #4bc9c3 is a big change (Light Mode essentially).
  // User asked for "Some text as #fc7e68".
  // Let's set main text to white for now as it's a game, often vibrant.
  // Wait, #4bc9c3 is quite bright. White text might be hard to read.
  // Let's allow overriding.
  textSecondary: PALETTE.coral,
  border: PALETTE.coral,

  // Legacy/Game Specific (Mapping to new palette where possible or keeping neutral)
  starFilled: "#fbbf24", // Similar to sunflower but kept distinct for stars
  starEmpty: "#4a4a4a",

  // Inherited Functional
  success: PALETTE.emerald,
  error: PALETTE.red,
  warning: PALETTE.amber,

  // Compatibility / Aliases
  accent: PALETTE.coral,
  textMuted: "#888888", // Manually defined neutral gray for now

  // Direct Access (for when semantic names don't fit)
  ...PALETTE,
};
</file>

<file path="src/hooks/usePuzzleGame.ts">
import { useCallback, useEffect, useRef } from "react";
import { AppState, AppStateStatus } from "react-native";
import { normalizeGridSize } from "../constants/gameConfig";
import { useGameActions, useGameStore } from "../store/gameStore";
import { useProgressActions } from "../store/progressStore";
import { Level } from "../types";
import { getProgressPercentage } from "../utils/puzzleLogic";

interface UsePuzzleGameOptions {
  level?: Level;
  onWin?: (moves: number) => void;
}

export const usePuzzleGame = ({ level, onWin }: UsePuzzleGameOptions) => {
  const gameState = useGameStore();
  const gameActions = useGameActions();
  const progressActions = useProgressActions();
  const appState = useRef(AppState.currentState);

  const {
    currentGrid,
    emptySlotIndex,
    moveCount,
    isSolved,
    gridSize,
    isInitialized,
    hintedTiles,
  } = gameState;

  // Initialize or Resume
  useEffect(() => {
    if (level) {
      // Prevent ghost wins from previous level interactions
      gameActions.prepareGame();

      const initOrResume = async () => {
        const normalizedSize = normalizeGridSize(level.gridSize);
        const resumed = await gameActions.loadLevelState(
          level.chapterId,
          level.id,
          normalizedSize,
        );
        if (!resumed) {
          gameActions.initializeGame(normalizedSize);
        }
      };
      initOrResume();
    }
  }, [level?.id, level?.chapterId, level?.gridSize]);

  // Auto-save on AppState change
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      if (
        appState.current === "active" &&
        nextAppState.match(/inactive|background/)
      ) {
        // App is going to background, save state
        if (level && isInitialized && !isSolved) {
          gameActions.saveLevelState(level.chapterId, level.id);
        }
      }
      appState.current = nextAppState;
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange,
    );

    return () => {
      subscription.remove();
    };
  }, [level, isInitialized, isSolved, gameActions]);

  const progress = isInitialized ? getProgressPercentage(currentGrid) : 0;

  const handleTilePress = useCallback(
    (index: number) => {
      if (isSolved) return;
      const moved = gameActions.moveTile(index);

      // Check win condition after move
      if (moved) {
        // Get updated state after move
        const updatedState = useGameStore.getState();
        if (updatedState.isSolved && updatedState.isInitialized) {
          if (level) {
            gameActions.clearLevelState(level.chapterId, level.id);
          }
          onWin?.(updatedState.moveCount);
        }
      }
    },
    [isSolved, gameActions, level, onWin],
  );

  const resetGame = useCallback(() => {
    if (level) {
      gameActions.clearLevelState(level.chapterId, level.id);
    }
    gameActions.resetGame();
  }, [gameActions, level]);

  const completeAndSave = useCallback(() => {
    if (isSolved && level) {
      progressActions.completeLevel(
        level.chapterId,
        level.id,
        moveCount,
        normalizeGridSize(level.gridSize),
      );
    }
  }, [isSolved, level, moveCount, progressActions]);

  return {
    grid: currentGrid,
    emptySlotIndex,
    moveCount,
    isSolved,
    gridSize: gridSize || normalizeGridSize(level?.gridSize),
    isInitialized,
    progress,
    hintedTiles,
    handleTilePress,
    resetGame,
    useHint: gameActions.useHint,
    saveState: () =>
      level && gameActions.saveLevelState(level.chapterId, level.id),
    completeAndSave,
  };
};
</file>

<file path="src/modules/jigsaw/JigsawPiece.tsx">
import { Image } from "expo-image";
import React, { useEffect, useLayoutEffect, useMemo, useRef } from "react";
import { StyleSheet } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  runOnJS,
  SharedValue,
  useAnimatedStyle,
  useSharedValue,
  withDelay,
  withTiming,
} from "react-native-reanimated";
import { COLORS } from "../../constants/gameConfig";
import { GridSize, ImageSource } from "../../types";
import { JigsawPiece as JigsawPieceType } from "./jigsawStore";

interface JigsawPieceProps {
  piece: JigsawPieceType;
  pieceWidth: number;
  pieceHeight: number;
  imageSource: ImageSource;
  gridSize: GridSize;
  draggedGroupId: SharedValue<string | null>;
  dragTranslation: SharedValue<{ x: number; y: number }>;
  onDragStart: (groupId: string) => void;
  onDragEnd: (pieceId: number, finalX: number, finalY: number) => void;
  hasNeighborTop?: boolean;
  hasNeighborBottom?: boolean;
  hasNeighborLeft?: boolean;
  hasNeighborRight?: boolean;
  isGameOver?: boolean;
}

const DAMPING_FACTOR = 1.0;

const JigsawPiece: React.FC<JigsawPieceProps> = ({
  piece,
  pieceWidth,
  pieceHeight,
  imageSource,
  gridSize,
  draggedGroupId,
  dragTranslation,
  onDragStart,
  onDragEnd,
  hasNeighborTop = false,
  hasNeighborBottom = false,
  hasNeighborLeft = false,
  hasNeighborRight = false,
  isGameOver = false,
}) => {
  const targetX = piece.currentCol * pieceWidth;
  const targetY = piece.currentRow * pieceHeight;

  const visualOffsetX = useSharedValue(0);
  const visualOffsetY = useSharedValue(0);
  const prevTarget = useRef({ x: targetX, y: targetY });

  // Flip Animation State (Start at 180 - Face Down)
  const flipRotation = useSharedValue(180);

  useEffect(() => {
    // 1 Second loading delay + Staggered flip animation
    const INITIAL_DELAY = 1000;
    const delay = INITIAL_DELAY + piece.id * 50;
    flipRotation.value = withDelay(delay, withTiming(0, { duration: 800 }));
  }, [piece.id]);

  useLayoutEffect(() => {
    const diffX = targetX - prevTarget.current.x;
    const diffY = targetY - prevTarget.current.y;

    if (Math.abs(diffX) > 0.1 || Math.abs(diffY) > 0.1) {
      visualOffsetX.value = visualOffsetX.value - diffX;
      visualOffsetY.value = visualOffsetY.value - diffY;

      visualOffsetX.value = withTiming(0, { duration: 300 });
      visualOffsetY.value = withTiming(0, { duration: 300 });
    }

    prevTarget.current = { x: targetX, y: targetY };
  }, [targetX, targetY]);

  const prevGroupId = useRef(piece.groupId);
  useEffect(() => {
    if (piece.groupId !== prevGroupId.current) {
      if (draggedGroupId.value === piece.groupId) {
        visualOffsetX.value -= dragTranslation.value.x;
        visualOffsetY.value -= dragTranslation.value.y;
        visualOffsetX.value = withTiming(0, { duration: 300 });
        visualOffsetY.value = withTiming(0, { duration: 300 });
      }
    }
    prevGroupId.current = piece.groupId;
  }, [piece.groupId]);

  const { top, left } = useMemo(
    () => ({
      top: -Math.floor(piece.id / gridSize.cols) * pieceHeight,
      left: -(piece.id % gridSize.cols) * pieceWidth,
    }),
    [piece.id, gridSize, pieceWidth, pieceHeight],
  );

  const gesture = useMemo(
    () =>
      Gesture.Pan()
        .enabled(!isGameOver)
        .onStart(() => {
          runOnJS(onDragStart)(piece.groupId);
          draggedGroupId.value = piece.groupId;
          dragTranslation.value = { x: 0, y: 0 };
        })
        .onUpdate((e) => {
          dragTranslation.value = {
            x: e.translationX * DAMPING_FACTOR,
            y: e.translationY * DAMPING_FACTOR,
          };
        })
        .onEnd((e) => {
          const finalX = targetX + e.translationX * DAMPING_FACTOR;
          const finalY = targetY + e.translationY * DAMPING_FACTOR;

          runOnJS(onDragEnd)(piece.id, finalX, finalY);

          dragTranslation.value = withTiming(
            { x: 0, y: 0 },
            { duration: 250 },
            (finished) => {
              if (finished) {
                draggedGroupId.value = null;
              }
            },
          );
        }),
    [
      piece.id,
      piece.groupId,
      targetX,
      targetY,
      onDragStart,
      onDragEnd,
      isGameOver,
      pieceWidth,
      pieceHeight,
    ],
  );

  const PIECE_GAP = isGameOver ? 0 : 0.3;
  const DRAG_SCALE = 1.05;
  const pZIndex = piece.zIndex;

  const style = useAnimatedStyle(() => {
    const isDraggingMe = draggedGroupId.value === piece.groupId;
    const tx = isDraggingMe ? dragTranslation.value.x : 0;
    const ty = isDraggingMe ? dragTranslation.value.y : 0;
    const scale = isDraggingMe ? DRAG_SCALE : 1;

    return {
      position: "absolute",
      left: 0,
      top: 0,
      width: pieceWidth,
      height: pieceHeight,
      transform: [
        { translateX: targetX + visualOffsetX.value + tx },
        { translateY: targetY + visualOffsetY.value + ty },
        { scale },
        { rotateY: `${flipRotation.value}deg` },
      ],
      zIndex: isDraggingMe ? 9999 : pZIndex,
    };
  });

  const expandTop = useSharedValue(hasNeighborTop ? PIECE_GAP : 0);
  const expandBottom = useSharedValue(hasNeighborBottom ? PIECE_GAP : 0);
  const expandLeft = useSharedValue(hasNeighborLeft ? PIECE_GAP : 0);
  const expandRight = useSharedValue(hasNeighborRight ? PIECE_GAP : 0);
  const mergeScale = useSharedValue(1);

  useEffect(() => {
    const MERGE_DURATION = 200;
    expandTop.value = withTiming(hasNeighborTop ? PIECE_GAP : 0, {
      duration: MERGE_DURATION,
    });
    expandBottom.value = withTiming(hasNeighborBottom ? PIECE_GAP : 0, {
      duration: MERGE_DURATION,
    });
    expandLeft.value = withTiming(hasNeighborLeft ? PIECE_GAP : 0, {
      duration: MERGE_DURATION,
    });
    expandRight.value = withTiming(hasNeighborRight ? PIECE_GAP : 0, {
      duration: MERGE_DURATION,
    });
  }, [
    hasNeighborTop,
    hasNeighborBottom,
    hasNeighborLeft,
    hasNeighborRight,
    PIECE_GAP,
  ]);

  const pieceStyle = useAnimatedStyle(() => {
    const borderW = isGameOver ? 0 : 2;

    return {
      position: "absolute" as const,
      top: PIECE_GAP - expandTop.value,
      left: PIECE_GAP - expandLeft.value,
      width: pieceWidth - PIECE_GAP * 2 + expandLeft.value + expandRight.value,
      height:
        pieceHeight - PIECE_GAP * 2 + expandTop.value + expandBottom.value,
      borderTopWidth: expandTop.value > 0 ? 0 : borderW,
      borderBottomWidth: expandBottom.value > 0 ? 0 : borderW,
      borderLeftWidth: expandLeft.value > 0 ? 0 : borderW,
      borderRightWidth: expandRight.value > 0 ? 0 : borderW,
      borderColor: "#ffffff",
      borderTopLeftRadius:
        hasNeighborTop || hasNeighborLeft || isGameOver ? 0 : 4,
      borderTopRightRadius:
        hasNeighborTop || hasNeighborRight || isGameOver ? 0 : 4,
      borderBottomLeftRadius:
        hasNeighborBottom || hasNeighborLeft || isGameOver ? 0 : 4,
      borderBottomRightRadius:
        hasNeighborBottom || hasNeighborRight || isGameOver ? 0 : 4,
      overflow: "hidden" as const,
      transform: [{ scale: mergeScale.value }],
    };
  });

  // Animated style for image offset
  const imageStyle = useAnimatedStyle(() => {
    return {
      width: gridSize.cols * pieceWidth,
      height: gridSize.rows * pieceHeight,
      transform: [
        { translateX: left - PIECE_GAP - expandLeft.value },
        { translateY: top - PIECE_GAP - expandTop.value },
      ],
      // Hide Front Face when rotated past 90 degrees
      opacity: flipRotation.value <= 90 ? 1 : 0,
    };
  });

  const backFaceStyle = useAnimatedStyle(() => {
    return {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: COLORS.textSecondary,
      justifyContent: "center",
      alignItems: "center",
      transform: [{ rotateY: "180deg" }],
      // Hide Back Face when rotated less than 90 degrees (facing away)
      opacity: flipRotation.value > 90 ? 1 : 0,
    };
  });

  return (
    <GestureDetector gesture={gesture}>
      <Animated.View style={style}>
        <Animated.View style={pieceStyle}>
          {/* Front Face (Expo Image for Performance/Caching) */}
          <Animated.View style={imageStyle}>
            <Image
              source={imageSource}
              style={{ width: "100%", height: "100%" }}
              contentFit="fill"
              cachePolicy="memory-disk"
            />
          </Animated.View>

          {/* Back Face (Icon & Color) */}
          <Animated.View style={backFaceStyle}>
            <Image
              source={require("@/src/assets/images/splash-icon.png")}
              style={{ width: "50%", height: "50%" }}
              contentFit="contain"
            />
          </Animated.View>
        </Animated.View>
      </Animated.View>
    </GestureDetector>
  );
};

export default React.memo(JigsawPiece);
</file>

<file path="src/modules/jigsaw/jigsawStore.ts">
import { create } from "zustand";
import { GridSize } from "../../types";

export type JigsawPiece = {
  id: number;
  currentCol: number;
  currentRow: number;
  correctRow: number;
  correctCol: number;
  groupId: string;
  zIndex: number;
  isLocked: boolean;
};

export type GameStatus = "playing" | "won";

interface JigsawState {
  pieces: Record<number, JigsawPiece>;
  gridSize: GridSize;
  isInitialized: boolean;
  maxZIndex: number;
  status: GameStatus;
  isHapticEnabled: boolean;
  moves: number;
}

interface JigsawActions {
  initializeLevel: (gridSize: GridSize) => void;
  moveGroupToGrid: (
    anchorId: number,
    targetRow: number,
    targetCol: number,
  ) => { merged: boolean };
  bringGroupToFront: (groupId: string) => void;
  resetGame: () => void;
}

interface JigsawStore extends JigsawState {
  actions: JigsawActions;
}

const initialState: JigsawState = {
  pieces: {},
  gridSize: { cols: 3, rows: 4 },
  isInitialized: false,
  maxZIndex: 1,
  status: "playing",
  isHapticEnabled: true,
  moves: 0,
};

// Helper: Shuffle an array
const shuffle = <T>(array: T[]): T[] => {
  return array.sort(() => Math.random() - 0.5);
};

// Helper: Find nearest valid shift for a group to avoid collision
const findNearestEmptySlotForGroup = (
  group: JigsawPiece[],
  pieces: Record<number, JigsawPiece>,
  gridSize: GridSize,
  occupiedSlots: Set<string>,
  preferSourceRow?: number, // Ä°tme yÃ¶nÃ¼nÃ¼ belirlemek iÃ§in
  preferSourceCol?: number,
): { dr: number; dc: number } | null => {
  const queue: { dr: number; dc: number }[] = [{ dr: 0, dc: 0 }];
  const visited = new Set<string>(["0,0"]);

  // Arama yÃ¶nlerini "kaynak boÅŸluÄŸa" gÃ¶re Ã¶nceliklendirebiliriz
  const directions = [
    { dr: -1, dc: 0 },
    { dr: 1, dc: 0 },
    { dr: 0, dc: -1 },
    { dr: 0, dc: 1 },
    { dr: -1, dc: -1 },
    { dr: -1, dc: 1 },
    { dr: 1, dc: -1 },
    { dr: 1, dc: 1 },
  ];

  // EÄŸer bir tercih varsa (itme yÃ¶nÃ¼), yÃ¶nleri ona gÃ¶re sÄ±rala
  if (preferSourceRow !== undefined) {
    directions.sort((a, b) => {
      // Basit bir mesafe/yÃ¶n Ã¶nceliÄŸi mantÄ±ÄŸÄ±
      return 0; // Åimdilik standart BFS
    });
  }

  while (queue.length > 0) {
    const { dr, dc } = queue.shift()!;

    if (dr !== 0 || dc !== 0) {
      let isValid = true;
      for (const p of group) {
        const nr = p.currentRow + dr;
        const nc = p.currentCol + dc;

        // Check bounds and occupancy (occupiedSlots contains all simulated positions)
        if (
          nr < 0 ||
          nr >= gridSize.rows ||
          nc < 0 ||
          nc >= gridSize.cols ||
          occupiedSlots.has(`${nr},${nc}`)
        ) {
          isValid = false;
          break;
        }
      }
      if (isValid) return { dr, dc };
    }

    for (const d of directions) {
      const next = { dr: dr + d.dr, dc: dc + d.dc };
      const key = `${next.dr},${next.dc}`;
      if (
        !visited.has(key) &&
        Math.abs(next.dr) < gridSize.rows &&
        Math.abs(next.dc) < gridSize.cols
      ) {
        visited.add(key);
        queue.push(next);
      }
    }
  }
  return null;
};
// Helper: Build a spatial map for O(1) lookups
const buildPositionMap = (pieces: Record<number, JigsawPiece>) => {
  const map = new Map<string, JigsawPiece>();
  for (const p of Object.values(pieces)) {
    map.set(`${p.currentRow},${p.currentCol}`, p);
  }
  return map;
};

// Helper: Check for adjacency and return mergeable neighbor
const getMergeableNeighbor = (
  p: JigsawPiece,
  posMap: Map<string, JigsawPiece>,
  currentGroupId: string,
) => {
  const neighbors = [
    { r: p.currentRow - 1, c: p.currentCol, dr: -1, dc: 0 },
    { r: p.currentRow + 1, c: p.currentCol, dr: 1, dc: 0 },
    { r: p.currentRow, c: p.currentCol - 1, dr: 0, dc: -1 },
    { r: p.currentRow, c: p.currentCol + 1, dr: 0, dc: 1 },
  ];

  for (const n of neighbors) {
    const neighborPiece = posMap.get(`${n.r},${n.c}`);

    if (neighborPiece && neighborPiece.groupId !== currentGroupId) {
      if (
        neighborPiece.correctRow === p.correctRow + n.dr &&
        neighborPiece.correctCol === p.correctCol + n.dc
      ) {
        return neighborPiece;
      }
    }
  }
  return null;
};

export const useJigsawStore = create<JigsawStore>((set, get) => ({
  ...initialState,

  actions: {
    initializeLevel: (rawGridSize) => {
      console.log("Store: initializeLevel called with:", rawGridSize);

      // Handle both object and legacy number format
      let gridSize = rawGridSize;
      if (typeof rawGridSize === "number") {
        gridSize = { cols: rawGridSize, rows: rawGridSize };
      }

      const totalPieces = gridSize.cols * gridSize.rows;
      console.log("Store: totalPieces to create:", totalPieces);
      const pieces: Record<number, JigsawPiece> = {};

      const allSlots: { row: number; col: number }[] = [];
      for (let r = 0; r < gridSize.rows; r++) {
        for (let c = 0; c < gridSize.cols; c++) {
          allSlots.push({ row: r, col: c });
        }
      }

      const shuffledSlots = shuffle([...allSlots]);

      for (let i = 0; i < totalPieces; i++) {
        const correctRow = Math.floor(i / gridSize.cols);
        const correctCol = i % gridSize.cols;
        const initialPos = shuffledSlots[i];

        pieces[i] = {
          id: i,
          currentCol: initialPos.col,
          currentRow: initialPos.row,
          correctRow,
          correctCol,
          zIndex: 1,
          isLocked: false,
          groupId: `group-${i}`,
        };
      }

      // 4. Initial Auto-Merge (Recursive) with Optimization
      let mergedSomething = true;
      let iteration = 0;
      const MAX_ITERATIONS = 10;

      while (mergedSomething && iteration < MAX_ITERATIONS) {
        mergedSomething = false;
        iteration++;
        const posMap = buildPositionMap(pieces);
        const allPieces = Object.values(pieces);

        for (const p of allPieces) {
          const neighbor = getMergeableNeighbor(p, posMap, p.groupId);

          if (neighbor) {
            const g1 = p.groupId;
            const g2 = neighbor.groupId;

            if (g1 !== g2) {
              // Deterministic Merge: Merge LARGER -> SMALLER ID
              let targetGroupId, sourceGroupId;
              if (g1 < g2) {
                targetGroupId = g1;
                sourceGroupId = g2;
              } else {
                targetGroupId = g2;
                sourceGroupId = g1;
              }

              const sourceMembers = allPieces.filter(
                (m) => m.groupId === sourceGroupId,
              );
              if (sourceMembers.length > 0) {
                sourceMembers.forEach((m) => {
                  pieces[m.id] = { ...pieces[m.id], groupId: targetGroupId };
                });
                mergedSomething = true;
              }
            }
          }
        }
      }
      if (iteration >= MAX_ITERATIONS)
        console.warn("Initialize loop maxed out");

      set({
        ...initialState,
        pieces,
        gridSize,
        isInitialized: true,
        maxZIndex: 1,
        status: "playing",
      });
    },

    moveGroupToGrid: (anchorId, targetRow, targetCol) => {
      const state = get();
      if (state.status === "won") return { merged: false };

      const pieces = { ...state.pieces };
      const anchorPiece = pieces[anchorId];
      if (!anchorPiece) return { merged: false };

      let draggedGroupId = anchorPiece.groupId;
      const allPiecesArr = Object.values(pieces);
      const groupPieces = allPiecesArr.filter(
        (p) => p.groupId === draggedGroupId,
      );

      // 1. Calculate Target Footprint
      const targetFootprint = groupPieces.map((p) => ({
        id: p.id,
        row: targetRow + (p.currentRow - anchorPiece.currentRow),
        col: targetCol + (p.currentCol - anchorPiece.currentCol),
      }));

      // 2. Bounds Check
      if (
        targetFootprint.some(
          (m) =>
            m.row < 0 ||
            m.row >= state.gridSize.rows ||
            m.col < 0 ||
            m.col >= state.gridSize.cols,
        )
      ) {
        return { merged: false };
      }

      // 3. Optimized Spatial Checks
      // Build quick lookup for ALL pieces
      // We need to check collisions against "everything else"
      const occupiedSlots = new Set<string>();
      allPiecesArr.forEach((p) => {
        if (p.groupId !== draggedGroupId) {
          occupiedSlots.add(`${p.currentRow},${p.currentCol}`);
        }
      });

      const incomingSlots = new Set<string>();
      targetFootprint.forEach((f) => {
        incomingSlots.add(`${f.row},${f.col}`);
      });

      // 5. Find Victim Pieces (Efficiently)
      const victimPieces: JigsawPiece[] = [];
      allPiecesArr.forEach((p) => {
        if (
          p.groupId !== draggedGroupId &&
          incomingSlots.has(`${p.currentRow},${p.currentCol}`)
        ) {
          victimPieces.push(p);
        }
      });

      // 6. SPLIT & SCATTER LOGIC
      const victimMoves: Map<number, { row: number; col: number }> = new Map();
      const simulatedOccupied = new Set(incomingSlots);

      // Add non-involved pieces to simulated occupied
      allPiecesArr.forEach((p) => {
        if (
          p.groupId !== draggedGroupId &&
          !incomingSlots.has(`${p.currentRow},${p.currentCol}`)
        ) {
          // Not in target zone (already handled by incoming) and not victim (will move)
          // Wait, victim pieces ARE currently at `p.currentRow`.
          // If p is NOT victim and NOT dragged group...
          const isVictim = victimPieces.some((v) => v.id === p.id);
          if (!isVictim) {
            simulatedOccupied.add(`${p.currentRow},${p.currentCol}`);
          }
        }
      });
      // Correct logic: simulatedOccupied should contain:
      // 1. Where dragged pieces WILL be (incomingSlots)
      // 2. Where other pieces ARE (that aren't moving)

      const groupsToCheck = new Set<string>();
      groupsToCheck.add(draggedGroupId);

      // Process victims
      for (const p of victimPieces) {
        const shift = findNearestEmptySlotForGroup(
          [p],
          pieces,
          state.gridSize,
          simulatedOccupied,
          p.currentRow,
          p.currentCol,
        );

        if (shift) {
          const newRow = p.currentRow + shift.dr;
          const newCol = p.currentCol + shift.dc;
          victimMoves.set(p.id, { row: newRow, col: newCol });
          simulatedOccupied.add(`${newRow},${newCol}`);
        } else {
          return { merged: false }; // No space for victim
        }
      }

      // 7. Apply Changes (Atomic)
      const newMaxZIndex = state.maxZIndex + 10;

      // Update Dragged Group
      targetFootprint.forEach((m) => {
        pieces[m.id] = {
          ...pieces[m.id],
          currentRow: m.row,
          currentCol: m.col,
          zIndex: newMaxZIndex,
        };
      });

      // Update Victims
      victimMoves.forEach((pos, pId) => {
        const newGroupId = `group-split-${Date.now()}-${pId}`;
        pieces[pId] = {
          ...pieces[pId],
          currentRow: pos.row,
          currentCol: pos.col,
          groupId: newGroupId,
          zIndex: state.maxZIndex + 1,
        };
        groupsToCheck.add(newGroupId);
      });

      // 7b. FRACTURE CHECK (Optimized)
      const affectedGroupIds = new Set<string>();
      victimPieces.forEach((vp) => affectedGroupIds.add(vp.groupId));

      affectedGroupIds.forEach((groupId) => {
        const survivors = Object.values(pieces).filter(
          (p) => p.groupId === groupId,
        );
        if (survivors.length <= 1) return;

        // BFS for connectivity
        const visited = new Set<number>();
        const components: JigsawPiece[][] = [];

        for (const startPiece of survivors) {
          if (visited.has(startPiece.id)) continue;
          const component: JigsawPiece[] = [];
          const queue = [startPiece];
          visited.add(startPiece.id);

          while (queue.length > 0) {
            const curr = queue.shift()!;
            component.push(curr);

            // Check potential neighbors within survivors
            const neighbors = survivors.filter((n) => {
              if (visited.has(n.id)) return false;
              return (
                Math.abs(n.currentRow - curr.currentRow) +
                  Math.abs(n.currentCol - curr.currentCol) ===
                1
              );
            });

            for (const n of neighbors) {
              visited.add(n.id);
              queue.push(n);
            }
          }
          components.push(component);
        }

        if (components.length > 1) {
          for (let i = 1; i < components.length; i++) {
            const newGroupId = `fracture-${Date.now()}-${groupId}-${i}`;
            components[i].forEach((p) => {
              pieces[p.id] = { ...pieces[p.id], groupId: newGroupId };
            });
          }
        }
      });

      // 8. OPTIMIZED MERGE LOGIC (O(N) Lookups)
      let didMerge = false;
      const processedGroups = new Set<string>();
      const queue = Array.from(groupsToCheck);

      // Re-build "allPiecesArr" and "posMap" because pieces have moved/fractured
      let currentAllPieces = Object.values(pieces);

      // OPTIMIZATION: Incremental posMap updates or rebuild only when dirty?
      // Since map build is fast for <100 pieces, rebuilding is safer for correctness.
      let posMap = buildPositionMap(pieces);

      while (queue.length > 0) {
        const currentGroupId = queue.shift()!;
        if (processedGroups.has(currentGroupId)) continue;

        // Get fresh members from current pieces state
        const members = currentAllPieces.filter(
          (p) => p.groupId === currentGroupId,
        );
        if (members.length === 0) continue;

        let mergedThisRound = false;

        for (const p of members) {
          const neighborPiece = getMergeableNeighbor(p, posMap, currentGroupId);

          if (neighborPiece) {
            const targetGroupId = neighborPiece.groupId;

            // MERGE
            members.forEach((m) => {
              pieces[m.id] = { ...pieces[m.id], groupId: targetGroupId };
            });

            didMerge = true;
            mergedThisRound = true;

            // Refresh data for next iterations
            // Since we modified pieces, we must rebuild list and map to see new groupIds
            currentAllPieces = Object.values(pieces);
            posMap = buildPositionMap(pieces);

            queue.push(targetGroupId);
            break; // Break member loop
          }
        }

        if (!mergedThisRound) {
          processedGroups.add(currentGroupId);
        }
      }

      // 9. Win Condition Check
      const uniqueGroups = new Set(Object.values(pieces).map((p) => p.groupId));
      const status = uniqueGroups.size === 1 ? "won" : "playing";

      // Increment move count
      const newMoves = get().moves + 1;

      set({
        pieces,
        maxZIndex: newMaxZIndex,
        status,
        moves: newMoves,
      });

      return { merged: didMerge };
    },

    bringGroupToFront: (groupId) => {
      set((state) => {
        if (state.status === "won") return {};
        const newPieces = { ...state.pieces };
        let changed = false;

        Object.values(newPieces).forEach((p) => {
          if (p.groupId === groupId) {
            // IMMUTABLE UPDATE
            newPieces[p.id] = { ...p, zIndex: state.maxZIndex + 1 };
            changed = true;
          }
        });

        if (!changed) return {};

        return { pieces: newPieces, maxZIndex: state.maxZIndex + 1 };
      });
    },

    resetGame: () => {
      set(initialState);
    },
  },
}));
</file>

<file path="src/services/adManager.ts">
import { Platform } from "react-native";
import { AD_CONFIG } from "../constants/gameConfig";
import { useAdStore } from "../store/adStore";

// ==========================================
// CHECK IF ADMOB IS AVAILABLE
// ==========================================

let isAdMobAvailable = false;
let InterstitialAd: any = null;
let RewardedAd: any = null;
let AdEventType: any = null;
let RewardedAdEventType: any = null;
let TestIds: any = null;

try {
  const admob = require("react-native-google-mobile-ads");
  InterstitialAd = admob.InterstitialAd;
  RewardedAd = admob.RewardedAd;
  AdEventType = admob.AdEventType;
  RewardedAdEventType = admob.RewardedAdEventType;
  TestIds = admob.TestIds;
  isAdMobAvailable = true;
  console.log("ğŸ“º AdMob module loaded");
} catch (error) {
  console.log("ğŸ“º AdMob not available (Expo Go or not configured)");
  isAdMobAvailable = false;
}

// ==========================================
// AD UNIT IDS
// ==========================================

const getInterstitialId = () => {
  if (__DEV__ && TestIds) return TestIds.INTERSTITIAL;
  return Platform.OS === "ios"
    ? AD_CONFIG.interstitial.ios
    : AD_CONFIG.interstitial.android;
};

const getRewardedId = () => {
  if (__DEV__ && TestIds) return TestIds.REWARDED;
  return Platform.OS === "ios"
    ? AD_CONFIG.rewarded.ios
    : AD_CONFIG.rewarded.android;
};

// ==========================================
// AD INSTANCES
// ==========================================

let interstitialAd: any = null;
let rewardedAd: any = null;
let isInterstitialLoaded = false;
let isRewardedLoaded = false;

// ==========================================
// INTERSTITIAL ADS
// ==========================================

export const loadInterstitial = () => {
  if (!isAdMobAvailable || !InterstitialAd) {
    console.log("ğŸ“º AdMob not available, skipping interstitial load");
    return;
  }

  try {
    interstitialAd = InterstitialAd.createForAdRequest(getInterstitialId());

    interstitialAd.addAdEventListener(AdEventType.LOADED, () => {
      isInterstitialLoaded = true;
      useAdStore.getState().actions.setInterstitialReady(true);
      console.log("ğŸ“º Interstitial loaded");
    });

    interstitialAd.addAdEventListener(AdEventType.CLOSED, () => {
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
      loadInterstitial(); // Preload next
    });

    interstitialAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("ğŸ“º Interstitial error:", error);
      isInterstitialLoaded = false;
      useAdStore.getState().actions.setInterstitialReady(false);
    });

    interstitialAd.load();
  } catch (error) {
    console.log("ğŸ“º Interstitial init error:", error);
  }
};

export const showInterstitial = async (): Promise<boolean> => {
  if (!isAdMobAvailable || !isInterstitialLoaded || !interstitialAd) {
    console.log("ğŸ“º Interstitial not ready");
    return false;
  }

  return new Promise((resolve) => {
    try {
      interstitialAd.show();
      useAdStore.getState().actions.markInterstitialShown();
      resolve(true);
    } catch (error) {
      console.log("ğŸ“º Interstitial show error:", error);
      resolve(false);
    }
  });
};

// ==========================================
// REWARDED ADS
// ==========================================

export const loadRewarded = () => {
  if (!isAdMobAvailable || !RewardedAd) {
    console.log("ğŸ“º AdMob not available, skipping rewarded load");
    return;
  }

  try {
    rewardedAd = RewardedAd.createForAdRequest(getRewardedId());

    rewardedAd.addAdEventListener(RewardedAdEventType.LOADED, () => {
      isRewardedLoaded = true;
      useAdStore.getState().actions.setRewardedReady(true);
      console.log("ğŸ Rewarded loaded");
    });

    rewardedAd.addAdEventListener(RewardedAdEventType.EARNED_REWARD, () => {
      console.log("ğŸ Reward earned");
    });

    rewardedAd.addAdEventListener(AdEventType.CLOSED, () => {
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
      loadRewarded(); // Preload next
    });

    rewardedAd.addAdEventListener(AdEventType.ERROR, (error: any) => {
      console.log("ğŸ Rewarded error:", error);
      isRewardedLoaded = false;
      useAdStore.getState().actions.setRewardedReady(false);
    });

    rewardedAd.load();
  } catch (error) {
    console.log("ğŸ Rewarded init error:", error);
  }
};

export const showRewarded = (): Promise<boolean> => {
  if (!isAdMobAvailable || !isRewardedLoaded || !rewardedAd) {
    console.log("ğŸ Rewarded not ready");
    return Promise.resolve(false);
  }

  return new Promise((resolve) => {
    const unsubscribeReward = rewardedAd.addAdEventListener(
      RewardedAdEventType.EARNED_REWARD,
      () => {
        unsubscribeReward();
        useAdStore.getState().actions.markRewardedShown();
        resolve(true);
      },
    );

    const unsubscribeClose = rewardedAd.addAdEventListener(
      AdEventType.CLOSED,
      () => {
        unsubscribeClose();
      },
    );

    const unsubscribeError = rewardedAd.addAdEventListener(
      AdEventType.ERROR,
      () => {
        unsubscribeError();
        resolve(false);
      },
    );

    try {
      rewardedAd.show();
    } catch (error) {
      console.log("ğŸ Rewarded show error:", error);
      resolve(false);
    }
  });
};

// ==========================================
// INITIALIZATION
// ==========================================

export const initializeAds = () => {
  if (!isAdMobAvailable) {
    console.log("ğŸ“º AdMob not available, skipping initialization");
    return;
  }

  console.log("ğŸ“º Initializing ads...");
  loadInterstitial();
  loadRewarded();
};

export const isInterstitialReady = () =>
  isAdMobAvailable && isInterstitialLoaded;
export const isRewardedReady = () => isAdMobAvailable && isRewardedLoaded;
</file>

<file path="src/store/dataStore.ts">
import { create } from "zustand";
import { fetchChapters, fetchLevels } from "../services/dataService";
import { Chapter, Level } from "../types";

interface DataState {
  chapters: Chapter[];
  levelsCache: Record<number, Level[]>; // chapterId -> Level[]
  isLoading: boolean;
}

interface DataActions {
  getChapters: () => Promise<Chapter[]>;
  getLevels: (chapterId: number) => Promise<Level[]>;
  getChapterById: (id: number) => Chapter | undefined;
  getLevelById: (
    chapterId: number,
    levelId: number,
  ) => Promise<Level | undefined>;
}

interface DataStore extends DataState {
  actions: DataActions;
}

export const useDataStore = create<DataStore>((set, get) => ({
  chapters: [],
  levelsCache: {},
  isLoading: false,

  actions: {
    getChapters: async () => {
      const { chapters } = get();
      if (chapters.length > 0) return chapters;

      set({ isLoading: true });
      const fetchedChapters = await fetchChapters();

      set({ chapters: fetchedChapters, isLoading: false });
      return fetchedChapters;
    },

    getLevels: async (chapterId: number) => {
      const { levelsCache } = get();
      if (levelsCache[chapterId]) return levelsCache[chapterId];
      console.log(levelsCache[chapterId]);

      set({ isLoading: true });
      const fetchedLevels = await fetchLevels(chapterId);
      set((state) => ({
        levelsCache: { ...state.levelsCache, [chapterId]: fetchedLevels },
        isLoading: false,
      }));
      return fetchedLevels;
    },

    getChapterById: (id: number) => {
      return get().chapters.find((c) => c.id === id);
    },

    getLevelById: async (chapterId: number, levelId: number) => {
      const levels = await get().actions.getLevels(chapterId);
      return levels.find((l) => l.id === levelId);
    },
  },
}));

export const useChapters = () => useDataStore((state) => state.chapters);
export const useDataActions = () => useDataStore((state) => state.actions);
export const useIsDataLoading = () => useDataStore((state) => state.isLoading);
</file>

<file path="src/store/gameStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { STORAGE_KEYS } from "../constants/gameConfig";
import { GridSize } from "../types";
import { isSolved, performMove, shuffleGrid } from "../utils/puzzleLogic";

interface GameState {
  currentGrid: number[];
  emptySlotIndex: number;
  moveCount: number;
  hintsUsed: number;
  isSolved: boolean;
  gridSize: GridSize;
  isInitialized: boolean;
  hintedTiles: number[];
}

interface GameActions {
  initializeGame: (gridSize: GridSize) => void;
  loadLevelState: (
    chapterId: number,
    levelId: number,
    gridSize: GridSize,
  ) => Promise<boolean>;
  saveLevelState: (chapterId: number, levelId: number) => Promise<void>;
  clearLevelState: (chapterId: number, levelId: number) => Promise<void>;
  prepareGame: () => void;
  moveTile: (index: number) => boolean;
  resetGame: () => void;
  useHint: () => void;
}

interface GameStore extends GameState {
  actions: GameActions;
}

const initialState: GameState = {
  currentGrid: [],
  emptySlotIndex: -1,
  moveCount: 0,
  hintsUsed: 0,
  isSolved: false,
  gridSize: { cols: 3, rows: 3 },
  isInitialized: false,
  hintedTiles: [],
};

const getLevelStateKey = (chapterId: number, levelId: number) =>
  `${STORAGE_KEYS.LEVEL_STATE}_${chapterId}_${levelId}`;

export const useGameStore = create<GameStore>((set, get) => ({
  ...initialState,

  actions: {
    initializeGame: (gridSize: GridSize) => {
      const { grid, emptyIndex } = shuffleGrid(gridSize);
      set({
        currentGrid: grid,
        emptySlotIndex: emptyIndex,
        moveCount: 0,
        isSolved: false,
        gridSize,
        isInitialized: true,
        hintedTiles: [],
      });
    },

    loadLevelState: async (
      chapterId: number,
      levelId: number,
      gridSize: GridSize,
    ) => {
      try {
        const key = getLevelStateKey(chapterId, levelId);
        const stored = await AsyncStorage.getItem(key);
        if (stored) {
          const data = JSON.parse(stored);
          const totalTiles = gridSize.cols * gridSize.rows;
          // Validate stored grid matches current level dimensions
          if (data.grid.length === totalTiles) {
            set({
              currentGrid: data.grid,
              emptySlotIndex: data.emptyIndex,
              moveCount: data.moves,
              isSolved: isSolved(data.grid),
              gridSize,
              isInitialized: true,
              hintedTiles: data.hintedTiles || [],
            });
            return true;
          }
        }
      } catch (e) {
        console.error("Level state yÃ¼klenirken hata:", e);
      }
      return false;
    },

    saveLevelState: async (chapterId: number, levelId: number) => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return;

      try {
        const key = getLevelStateKey(chapterId, levelId);
        const data = {
          grid: state.currentGrid,
          emptyIndex: state.emptySlotIndex,
          moves: state.moveCount,
          hintedTiles: state.hintedTiles,
        };
        await AsyncStorage.setItem(key, JSON.stringify(data));
      } catch (e) {
        console.error("Level state kaydedilirken hata:", e);
      }
    },

    clearLevelState: async (chapterId: number, levelId: number) => {
      try {
        const key = getLevelStateKey(chapterId, levelId);
        await AsyncStorage.removeItem(key);
      } catch (e) {
        console.error("Level state silinirken hata:", e);
      }
    },

    prepareGame: () => {
      set({
        isSolved: false,
        isInitialized: false,
        moveCount: 0,
        hintedTiles: [],
        emptySlotIndex: -1,
        currentGrid: [],
      });
    },

    moveTile: (index: number) => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return false;

      const result = performMove(
        state.currentGrid,
        index,
        state.emptySlotIndex,
        state.gridSize,
      );

      if (result.moved) {
        const solved = isSolved(result.grid);
        set({
          currentGrid: result.grid,
          emptySlotIndex: result.emptyIndex,
          moveCount: state.moveCount + 1,
          isSolved: solved,
        });
      }

      return result.moved;
    },

    resetGame: () => {
      const state = get();
      if (!state.isInitialized) return;

      const { grid, emptyIndex } = shuffleGrid(state.gridSize);
      set({
        currentGrid: grid,
        emptySlotIndex: emptyIndex,
        moveCount: 0,
        isSolved: false,
        hintedTiles: [],
      });
    },

    useHint: () => {
      const state = get();
      if (!state.isInitialized || state.isSolved) return;

      const grid = [...state.currentGrid];
      const emptyTileValue = state.gridSize.cols * state.gridSize.rows - 1;

      // Find all wrong tiles - separate hinted and non-hinted
      const wrongTilesNotHinted: number[] = [];
      const wrongTilesHinted: number[] = [];

      for (let i = 0; i < grid.length; i++) {
        if (grid[i] !== i && i !== emptyTileValue) {
          const tileValue = i;
          if (state.hintedTiles.includes(tileValue)) {
            wrongTilesHinted.push(i);
          } else {
            wrongTilesNotHinted.push(i);
          }
        }
      }

      // Prefer non-hinted tiles, fallback to hinted tiles
      const wrongTiles =
        wrongTilesNotHinted.length > 0 ? wrongTilesNotHinted : wrongTilesHinted;

      if (wrongTiles.length === 0) return;

      // Randomly pick one wrong tile
      const targetIndex =
        wrongTiles[Math.floor(Math.random() * wrongTiles.length)];
      const tileValue = targetIndex;
      const currentIndex = grid.indexOf(tileValue);

      [grid[targetIndex], grid[currentIndex]] = [
        grid[currentIndex],
        grid[targetIndex],
      ];

      let newEmptyIndex = state.emptySlotIndex;
      if (targetIndex === state.emptySlotIndex) {
        newEmptyIndex = currentIndex;
      } else if (currentIndex === state.emptySlotIndex) {
        newEmptyIndex = targetIndex;
      }

      // Only add to hintedTiles if it's not already there
      const newHintedTiles = state.hintedTiles.includes(tileValue)
        ? state.hintedTiles
        : [...state.hintedTiles, tileValue];

      set({
        currentGrid: grid,
        emptySlotIndex: newEmptyIndex,
        hintedTiles: newHintedTiles,
        hintsUsed: state.hintsUsed + 1,
        isSolved: isSolved(grid),
      });
    },
  },
}));

export const useGameActions = () => useGameStore((state) => state.actions);
</file>

<file path="src/store/progressStore.ts">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { doc, getDoc, setDoc } from "firebase/firestore";
import { create } from "zustand";
import { auth, db } from "../../firebaseConfig";
import {
  calculateStars,
  LEVELS_PER_CHAPTER,
  STORAGE_KEYS,
} from "../constants/gameConfig";
import { GridSize, LevelProgress, UserProgress } from "../types";

interface ProgressState {
  progress: UserProgress;
  isLoaded: boolean;
  isLoading: boolean;
}

interface ProgressActions {
  loadProgress: () => Promise<void>;
  saveProgress: () => Promise<void>;
  completeLevel: (
    chapterId: number,
    levelId: number,
    moves: number,
    gridSize: GridSize,
  ) => void;
  setLastPlayed: (chapterId: number, levelId: number) => void;
  isLevelUnlocked: (chapterId: number, levelId: number) => boolean;
  isChapterUnlocked: (chapterId: number) => boolean;
  getLevelProgress: (
    chapterId: number,
    levelId: number,
  ) => LevelProgress | null;
  getChapterProgress: (chapterId: number) => {
    completed: number;
    total: number;
    stars: number;
  };
  getLastPlayed: () => { chapterId: number; levelId: number } | null;
  getNextPlayableLevel: () => { chapterId: number; levelId: number };
}

interface ProgressStore extends ProgressState {
  actions: ProgressActions;
}

const createInitialProgress = (): UserProgress => ({
  unlockedChapters: [1],
  completedLevels: {},
  totalStars: 0,
  totalCoins: 0,
  lastPlayed: undefined,
});

const getLevelKey = (chapterId: number, levelId: number): string =>
  `${chapterId}-${levelId}`;

let loadingPromise: Promise<void> | null = null;

export const useProgressStore = create<ProgressStore>((set, get) => ({
  progress: createInitialProgress(),
  isLoaded: false,
  isLoading: false,

  actions: {
    loadProgress: async () => {
      const { isLoaded, isLoading } = get();

      // Prevent duplicate loads
      if (isLoaded) return;

      // If already loading, we could return a stored promise, but for now just returning if in progress is safer to avoid loops,
      // though typically we want to wait.
      // Better pattern: Store the active promise.
      if (isLoading) {
        // If we had a mechanism to return the active promise, we would.
        // For now, if loading, just wait a bit or assume it will finish?
        // Actually, if we return early, the component awaiting this might proceed before data is ready.
        // Let's add 'loadingPromise' to state/module scope or just keep it simple:
        // If loading/loaded, do nothing?
        // But the caller expects to await completion.
        // A simple class-level variable outside store can hold the promise.
        return loadingPromise || Promise.resolve();
      }

      set({ isLoading: true });

      loadingPromise = (async () => {
        try {
          const stored = await AsyncStorage.getItem(STORAGE_KEYS.USER_PROGRESS);
          if (stored) {
            set({ progress: JSON.parse(stored) }); // Don't set isLoaded yet, wait for cloud? No, show local asap.
          }

          const currentUser = auth?.currentUser;
          if (currentUser) {
            console.log("ğŸ” Loading progress for user:", currentUser.uid);
            const userDoc = await getDoc(doc(db, "users", currentUser.uid));
            if (userDoc.exists()) {
              const cloudData = userDoc.data();
              // ... cloud parsing logic ...
              // Helper defined inline or outside.
              // To minimize diff, we'll keep inline but abbreviated in replacement if not changing.
              // Actually we need to copy the helper or move it out.
              // Moving helper out of function scope is cleaner.

              const convertFlatToNested = (flatData: any): any => {
                const result: any = {};
                for (const key in flatData) {
                  if (key.startsWith("progress.")) {
                    const parts = key.split(".");
                    let current = result;
                    for (let i = 0; i < parts.length - 1; i++) {
                      const part = parts[i];
                      if (!current[part]) current[part] = {};
                      current = current[part];
                    }
                    current[parts[parts.length - 1]] = flatData[key];
                  } else if (key !== "lastUpdated") {
                    result[key] = flatData[key];
                  }
                }
                return result;
              };

              const nestedData = convertFlatToNested(cloudData);

              const cloudProgress: UserProgress = {
                completedLevels: nestedData?.progress?.completedLevels || {},
                totalStars: nestedData?.progress?.totalStars || 0,
                totalCoins: nestedData?.progress?.totalCoins || 0,
                unlockedChapters: nestedData?.progress?.unlockedChapters || [1],
                lastPlayed: nestedData?.progress?.lastPlayed,
              };

              if (
                cloudProgress.completedLevels &&
                Object.keys(cloudProgress.completedLevels).length > 0
              ) {
                console.log("âœ… Setting cloud progress to state");
                set({ progress: cloudProgress });
                await AsyncStorage.setItem(
                  STORAGE_KEYS.USER_PROGRESS,
                  JSON.stringify(cloudProgress),
                );
              }
            }
          }
          set({ isLoaded: true, isLoading: false });
        } catch (error) {
          console.error("Progress yÃ¼kleme hatasÄ±:", error);
          set({ isLoaded: true, isLoading: false });
        } finally {
          loadingPromise = null;
        }
      })();

      return loadingPromise;
    },

    // saveProgress removed - dangerous as it overwrites entire object

    completeLevel: async (
      chapterId: number,
      levelId: number,
      moves: number,
      gridSize: GridSize,
    ) => {
      const { progress } = get();
      const levelKey = getLevelKey(chapterId, levelId);
      const stars = calculateStars(moves, gridSize);
      const existingProgress = progress.completedLevels[levelKey];

      const newLevelProgress: LevelProgress = {
        completed: true,
        bestMoves: existingProgress
          ? Math.min(existingProgress.bestMoves, moves)
          : moves,
        stars: existingProgress
          ? Math.max(existingProgress.stars, stars)
          : stars,
      };

      const starDiff = newLevelProgress.stars - (existingProgress?.stars || 0);

      let newChapterUnlocked = false;
      let nextChapterId = chapterId + 1;

      // Coin Logic: Every 4 UNIQUE levels completed = 1 Coin
      const wasBrandNewLevel = !existingProgress || !existingProgress.completed;
      const currentCompletedCount = Object.values(
        progress.completedLevels,
      ).filter((l) => l.completed).length;

      let coinBonus = 0;
      if (wasBrandNewLevel) {
        // We just completed a new level.
        const newTotalCompleted = currentCompletedCount + 1;
        if (newTotalCompleted % 4 === 0) {
          coinBonus = 1;
        }
      }

      let newProgress = {
        ...progress,
        completedLevels: {
          ...progress.completedLevels,
          [levelKey]: newLevelProgress,
        },
        totalStars: progress.totalStars + starDiff,
        totalCoins: (progress.totalCoins || 0) + coinBonus,
      };

      if (
        levelId === LEVELS_PER_CHAPTER &&
        !progress.unlockedChapters.includes(nextChapterId)
      ) {
        newProgress.unlockedChapters = [
          ...newProgress.unlockedChapters,
          nextChapterId,
        ].sort((a, b) => a - b);
        newChapterUnlocked = true;
      }

      // Update Local State
      set({ progress: newProgress });
      // Update Local Storage
      await AsyncStorage.setItem(
        STORAGE_KEYS.USER_PROGRESS,
        JSON.stringify(newProgress),
      );

      // Update Cloud with proper nested structure
      const user = auth.currentUser;

      if (user) {
        try {
          // Build proper nested structure instead of dot notation
          const cloudUpdate = {
            progress: {
              completedLevels: {
                [levelKey]: newLevelProgress,
              },
              totalStars: newProgress.totalStars,
              totalCoins: newProgress.totalCoins,
              unlockedChapters: newProgress.unlockedChapters,
            },
            lastUpdated: new Date().toISOString(),
          };

          console.log("ğŸ’¾ Saving to cloud:", levelKey, newLevelProgress);

          // Use setDoc with merge to update nested fields properly
          await setDoc(doc(db, "users", user.uid), cloudUpdate, {
            merge: true,
          });
        } catch (e) {
          console.error("Cloud level save error:", e);
          // Queue for offline sync
          const { queueProgressUpdate } = await import("../services/syncQueue");
          await queueProgressUpdate(
            chapterId,
            levelId,
            newLevelProgress.bestMoves,
            newLevelProgress.stars,
          );
        }
      }
    },

    setLastPlayed: async (chapterId: number, levelId: number) => {
      const { progress } = get();
      const lastPlayed = { chapterId, levelId };
      const newProgress = { ...progress, lastPlayed };

      set({ progress: newProgress });
      await AsyncStorage.setItem(
        STORAGE_KEYS.USER_PROGRESS,
        JSON.stringify(newProgress),
      );

      const user = auth.currentUser;
      if (user) {
        try {
          await setDoc(
            doc(db, "users", user.uid),
            {
              progress: {
                lastPlayed: lastPlayed,
              },
              lastUpdated: new Date().toISOString(),
            },
            { merge: true },
          );
        } catch (e) {
          console.error("Last played save error:", e);
        }
      }
    },

    isLevelUnlocked: (chapterId: number, levelId: number) => {
      const { progress } = get();
      if (!progress.unlockedChapters.includes(chapterId)) return false;
      if (levelId === 1) return true;
      const prevLevelKey = getLevelKey(chapterId, levelId - 1);
      return progress.completedLevels[prevLevelKey]?.completed ?? false;
    },

    isChapterUnlocked: (chapterId: number) => {
      return get().progress.unlockedChapters.includes(chapterId);
    },

    getLevelProgress: (chapterId: number, levelId: number) => {
      return (
        get().progress.completedLevels[getLevelKey(chapterId, levelId)] ?? null
      );
    },

    getChapterProgress: (chapterId: number) => {
      const { progress } = get();
      let completed = 0;
      let stars = 0;

      for (let i = 1; i <= LEVELS_PER_CHAPTER; i++) {
        const levelProgress =
          progress.completedLevels[getLevelKey(chapterId, i)];
        if (levelProgress?.completed) {
          completed++;
          stars += levelProgress.stars;
        }
      }

      return { completed, total: LEVELS_PER_CHAPTER, stars };
    },

    getLastPlayed: () => {
      const { progress } = get();
      return progress.lastPlayed ?? null;
    },

    // Kept for interface compatibility but warns
    saveProgress: async () => {
      console.warn(
        "Generic saveProgress is deprecated to prevent data loss. Use granular actions.",
      );
    },

    getNextPlayableLevel: () => {
      const { progress } = get();
      const lastPlayed = progress.lastPlayed;

      // 1. No history -> Start 1-1
      if (!lastPlayed) {
        return { chapterId: 1, levelId: 1 };
      }

      // 2. Check if the last played level is completed
      const levelKey = getLevelKey(lastPlayed.chapterId, lastPlayed.levelId);
      const isCompleted = progress.completedLevels[levelKey]?.completed;

      if (!isCompleted) {
        // Stay on this level
        return lastPlayed;
      }

      // 3. Logic for Next Level
      // Current level completed, so move to next.
      let nextChapter = lastPlayed.chapterId;
      let nextLevel = lastPlayed.levelId + 1;

      // Check Chapter Boundary
      if (nextLevel > LEVELS_PER_CHAPTER) {
        nextChapter++;
        nextLevel = 1;
      }

      // We don't check TOTAL_CHAPTERS here; let the UI handle "Coming Soon" or valid check if needed.
      // But typically we just return valid coordinates.

      return { chapterId: nextChapter, levelId: nextLevel };
    },
  },
}));

export const useProgressActions = () =>
  useProgressStore((state) => state.actions);
export const useTotalStars = () =>
  useProgressStore((state) => state.progress.totalStars);
export const useTotalCoins = () =>
  useProgressStore((state) => state.progress.totalCoins || 0);
export const useLastPlayed = () =>
  useProgressStore((state) => state.progress.lastPlayed);
</file>

<file path="app/chapters.tsx">
import { Image } from "expo-image";
import { Stack, useRouter } from "expo-router";
import React from "react";
import {
  ActivityIndicator,
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, { FadeInDown } from "react-native-reanimated";
import ChapterNativeAd from "../src/components/ChapterNativeAd";
import {
  BOARD_PADDING,
  COLORS,
  getGridColumns,
} from "../src/constants/gameConfig";
import { useAdActions } from "../src/store/adStore";
import {
  useChapters,
  useDataActions,
  useIsDataLoading,
} from "../src/store/dataStore";
import { useProgressActions, useTotalStars } from "../src/store/progressStore";
import { Chapter } from "../src/types";

interface ChapterCardProps {
  chapter: Chapter;
  index: number;
  isUnlocked: boolean;
  progress: { completed: number; total: number; stars: number };
  cardWidth: number;
  onPress: () => void;
}

const ChapterCard: React.FC<ChapterCardProps> = ({
  chapter,
  index,
  isUnlocked,
  progress,
  cardWidth,
  onPress,
}) => {
  const progressPercent = (progress.completed / progress.total) * 100;

  return (
    <Animated.View
      entering={FadeInDown.delay(index * 40).springify()}
      style={{ width: cardWidth }}
    >
      <TouchableOpacity
        style={[styles.card, !isUnlocked && styles.cardLocked]}
        onPress={onPress}
        disabled={!isUnlocked}
        activeOpacity={0.7}
      >
        {/* Thumbnail Section */}
        <View style={styles.thumbnailArea}>
          <Image
            source={chapter.thumbnail}
            style={styles.thumbnail}
            contentFit="cover"
          />
          <View style={styles.overlay} />
          <View style={styles.idBadge}>
            <Text style={styles.idBadgeTxt}>{chapter.id}</Text>
          </View>
          {!isUnlocked && (
            <View style={styles.lockedArea}>
              <Text style={styles.lockIc}>ğŸ”’</Text>
            </View>
          )}
        </View>

        {/* Content Section */}
        <View style={styles.infoArea}>
          <Text style={styles.name} numberOfLines={1}>
            {chapter.name}
          </Text>
          <View style={styles.progressRow}>
            <View style={styles.barBg}>
              <View
                style={[styles.barFill, { width: `${progressPercent}%` }]}
              />
            </View>
            <Text style={styles.progressStats}>
              {progress.completed}/{progress.total}
            </Text>
          </View>
          <View style={styles.starInfo}>
            <Text style={styles.starIc}>â˜…</Text>
            <Text style={styles.starVal}>{progress.stars}</Text>
          </View>
        </View>
      </TouchableOpacity>
    </Animated.View>
  );
};

export default function ChaptersScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const totalStars = useTotalStars();
  const progressActions = useProgressActions();
  const chapters = useChapters();
  const { getChapters } = useDataActions();
  const isLoading = useIsDataLoading();
  const adActions = useAdActions();

  React.useEffect(() => {
    getChapters();
  }, []);

  const numColumns = getGridColumns(width);
  const padding = BOARD_PADDING;
  const gap = 15;
  const cardWidth = (width - padding * 2 - gap * (numColumns - 1)) / numColumns;

  // Create rows of chapters with ads inserted at appropriate positions
  const listData = React.useMemo(() => {
    const rows: Array<{ type: "row" | "ad"; items?: Chapter[]; id: string }> =
      [];
    let currentRow: Chapter[] = [];

    chapters.forEach((chapter, index) => {
      currentRow.push(chapter);

      // When row is full or it's the last chapter
      if (currentRow.length === numColumns || index === chapters.length - 1) {
        rows.push({
          type: "row",
          items: [...currentRow],
          id: `row-${rows.length}`,
        });
        currentRow = [];
      }

      // Add ad after every 4th chapter
      if (adActions.shouldShowNativeAdAtIndex(index)) {
        rows.push({
          type: "ad",
          id: `ad-${index}`,
        });
      }
    });

    return rows;
  }, [chapters, numColumns, adActions]);

  if (isLoading && chapters.length === 0) {
    return (
      <View style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: "BÃ¶lÃ¼mler",
          headerStyle: { backgroundColor: COLORS.background },
          headerTintColor: COLORS.textPrimary,
          headerShadowVisible: false,
          headerRight: () => (
            <View style={styles.headerStars}>
              <Text style={styles.headerStarIcon}>â˜…</Text>
              <Text style={styles.headerStarText}>{totalStars}</Text>
            </View>
          ),
        }}
      />

      <FlatList
        data={listData}
        renderItem={({ item }) => {
          if (item.type === "ad") {
            return <ChapterNativeAd index={parseInt(item.id.split("-")[1])} />;
          }

          // Render row of chapters
          return (
            <View style={[styles.chapterRow, { gap }]}>
              {item.items?.map((chapter, idx) => (
                <ChapterCard
                  key={chapter.id}
                  chapter={chapter}
                  index={chapters.indexOf(chapter)}
                  isUnlocked={progressActions.isChapterUnlocked(chapter.id)}
                  progress={progressActions.getChapterProgress(chapter.id)}
                  cardWidth={cardWidth}
                  onPress={() => router.push(`/levels/${chapter.id}`)}
                />
              ))}
            </View>
          );
        }}
        keyExtractor={(item) => item.id}
        contentContainerStyle={[styles.listContent, { padding }]}
        ItemSeparatorComponent={() => <View style={{ height: gap }} />}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background },
  centered: { justifyContent: "center", alignItems: "center" },
  chapterRow: {
    flexDirection: "row",
    justifyContent: "flex-start",
  },
  headerStars: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.surface,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  headerStarIcon: { fontSize: 16, color: COLORS.starFilled },
  headerStarText: {
    fontSize: 15,
    fontWeight: "800",
    color: COLORS.primary,
  },
  listContent: { paddingBottom: 40 },
  card: {
    backgroundColor: COLORS.surface,
    borderRadius: 20,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  cardLocked: { opacity: 0.6 },
  thumbnailArea: { aspectRatio: 1.5, position: "relative" },
  thumbnail: { width: "100%", height: "100%" },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.2)",
  },
  idBadge: {
    position: "absolute",
    top: 10,
    left: 10,
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: COLORS.background,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: COLORS.border,
  },
  idBadgeTxt: { color: COLORS.textPrimary, fontWeight: "900", fontSize: 13 },
  lockedArea: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.6)",
    justifyContent: "center",
    alignItems: "center",
  },
  lockIc: { fontSize: 32 },
  infoArea: { padding: 15, gap: 10 },
  name: { fontSize: 18, fontWeight: "800", color: COLORS.textPrimary },
  progressRow: { flexDirection: "row", alignItems: "center", gap: 10 },
  barBg: {
    flex: 1,
    height: 6,
    backgroundColor: "#e0e0e0",
    borderRadius: 3,
    overflow: "hidden",
  },
  barFill: { height: "100%", backgroundColor: COLORS.accent },
  progressStats: {
    fontSize: 11,
    color: COLORS.textSecondary,
    fontWeight: "700",
  },
  starInfo: { flexDirection: "row", alignItems: "center", gap: 5 },
  starIc: { fontSize: 14, color: COLORS.starFilled },
  starVal: { fontSize: 14, color: COLORS.textPrimary, fontWeight: "700" },
});
</file>

<file path="src/components/DevPanel.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useRouter } from "expo-router";
import { doc, writeBatch } from "firebase/firestore";
import { getDownloadURL, getStorage, ref } from "firebase/storage";
import React, { useState } from "react";
import {
  Alert,
  Modal,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { db } from "../../firebaseConfig";
import { COLORS, getGridSizeForLevel } from "../constants/gameConfig";
import { useGameStore } from "../store/gameStore";
import { useHintActions } from "../store/hintStore";
import { useProgressActions } from "../store/progressStore";
import { createSolvedGrid } from "../utils/puzzleLogic";

const uploadLevelsToFirebase = async (targetChapterId: string) => {
  const storage = getStorage();
  const batch = writeBatch(db);

  const FILE_EXTENSION = ".jpg";
  const FOLDER_NAME = `chapter-${targetChapterId}-levels`; // Dynamic folder name

  try {
    console.log(
      `â³ Level yÃ¼klemesi baÅŸlÄ±yor... Chapter: ${targetChapterId}, Folder: ${FOLDER_NAME}`,
    );

    const promises = Array.from({ length: 24 }, (_, i) => i + 1).map(
      async (levelId) => {
        // 1. Storage path: "chapter-1-levels/level-1.jpg"
        const fileName = `level-${levelId}${FILE_EXTENSION}`;
        const storageRef = ref(storage, `${FOLDER_NAME}/${fileName}`);

        let downloadUrl = "";
        try {
          downloadUrl = await getDownloadURL(storageRef);
          console.log(`âœ… Level ${levelId} resmi bulundu`);
        } catch (err) {
          console.error(`âŒ Level ${levelId} resmi YOK: ${fileName}`);
          downloadUrl = "https://via.placeholder.com/500";
        }

        // 2. Prepare Data
        const gridSize = getGridSizeForLevel(levelId);
        const levelData = {
          id: levelId,
          chapterId: Number(targetChapterId),
          gridSize: gridSize,
          imageSource: { uri: downloadUrl },
          moves: 0, // Reset logic or default
          stars: 0,
        };

        // 3. Firestore Ref: chapters/{id}/levels/{levelId}
        const levelDocRef = doc(
          db,
          "chapters",
          targetChapterId,
          "levels",
          levelId.toString(),
        );
        batch.set(levelDocRef, levelData, { merge: true });
      },
    );

    // Wait for all
    await Promise.all(promises);

    // Commit batch
    await batch.commit();

    alert(`Chapter ${targetChapterId} iÃ§in 24 level yÃ¼klendi! ğŸš€`);
  } catch (error) {
    console.error("Level Upload HatasÄ±:", error);
    alert("Hata oluÅŸtu, konsola bak.");
  }
};

const DevPanel: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [chapterId, setChapterId] = useState("1");
  const [levelId, setLevelId] = useState("1");
  const router = useRouter();
  const gameStore = useGameStore();
  const hintActions = useHintActions();
  const progressActions = useProgressActions();

  const goToLevel = () => {
    const cId = parseInt(chapterId) || 1;
    const lId = parseInt(levelId) || 1;
    router.push(`/game/${cId}/${lId}`);
    setIsOpen(false);
  };

  const solveGame = () => {
    const { gridSize } = gameStore;
    if (gridSize && gridSize.cols > 0 && gridSize.rows > 0) {
      const solvedGrid = createSolvedGrid(gridSize);
      const emptyIndex = gridSize.cols * gridSize.rows - 1;
      useGameStore.setState({
        currentGrid: solvedGrid,
        emptySlotIndex: emptyIndex,
        isSolved: true,
      });

      // Reset isSolved after win modal triggers to prevent ghost wins
      setTimeout(() => {
        useGameStore.setState({ isSolved: false });
      }, 100);
    }
    setIsOpen(false);
  };

  const addHints = () => {
    hintActions.addHints(1000);
    setIsOpen(false);
  };

  const clearStorage = async () => {
    Alert.alert(
      "TÃ¼m Veriyi Sil",
      "AsyncStorage'daki TÃœM veriler silinecek (progress, hints, level states). Emin misiniz?",
      [
        { text: "Ä°ptal", style: "cancel" },
        {
          text: "Sil",
          style: "destructive",
          onPress: async () => {
            try {
              await AsyncStorage.clear();
              Alert.alert(
                "BaÅŸarÄ±lÄ±",
                "TÃ¼m veriler silindi. Uygulama yeniden baÅŸlatÄ±lÄ±yor...",
              );
              setIsOpen(false);
              // Reload app
              setTimeout(() => {
                router.replace("/");
              }, 500);
            } catch (error) {
              Alert.alert("Hata", "Veri silinirken hata oluÅŸtu: " + error);
            }
          },
        },
      ],
    );
  };

  return (
    <>
      <TouchableOpacity
        style={styles.floatingButton}
        onPress={() => setIsOpen(true)}
        activeOpacity={0.8}
      >
        <Text style={styles.floatingButtonText}>ğŸ› </Text>
      </TouchableOpacity>

      <Modal visible={isOpen} transparent animationType="fade">
        <View style={styles.overlay}>
          <View style={styles.panel}>
            <Text style={styles.title}>Dev Panel</Text>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Level'e Git</Text>
              <View style={styles.inputRow}>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>BÃ¶lÃ¼m</Text>
                  <TextInput
                    style={styles.input}
                    value={chapterId}
                    onChangeText={setChapterId}
                    keyboardType="number-pad"
                    placeholder="1-20"
                    placeholderTextColor={COLORS.textMuted}
                  />
                </View>
                <View style={styles.inputGroup}>
                  <Text style={styles.inputLabel}>Level</Text>
                  <TextInput
                    style={styles.input}
                    value={levelId}
                    onChangeText={setLevelId}
                    keyboardType="number-pad"
                    placeholder="1-24"
                    placeholderTextColor={COLORS.textMuted}
                  />
                </View>
              </View>
              <TouchableOpacity
                style={styles.button}
                onPress={goToLevel}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>Git</Text>
              </TouchableOpacity>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>HÄ±zlÄ± Aksiyonlar</Text>
              <TouchableOpacity
                style={[styles.button, styles.solveButton]}
                onPress={solveGame}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ¯ Puzzle'Ä± Ã‡Ã¶z</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.hintButton]}
                onPress={addHints}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ’¡ +10 Hamle HakkÄ±</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.clearButton]}
                onPress={clearStorage}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>ğŸ—‘ï¸ Storage Temizle</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.clearButton]}
                onPress={() => uploadLevelsToFirebase(chapterId)}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>Firebase'a YÃ¼kle (Levels)</Text>
              </TouchableOpacity>
            </View>

            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setIsOpen(false)}
              activeOpacity={0.8}
            >
              <Text style={styles.closeButtonText}>Kapat</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </>
  );
};

const styles = StyleSheet.create({
  floatingButton: {
    position: "absolute",
    bottom: 100,
    right: 16,
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: "#ef4444",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 9999,
    elevation: 10,
  },
  floatingButtonText: { fontSize: 20 },
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  panel: {
    backgroundColor: COLORS.surface,
    borderRadius: 16,
    padding: 24,
    width: "100%",
    maxWidth: 320,
    borderWidth: 2,
    borderColor: COLORS.border,
  },
  title: {
    fontSize: 20,
    fontWeight: "700",
    color: COLORS.primaryText,
    textAlign: "center",
    marginBottom: 20,
  },
  section: { marginBottom: 20, gap: 10 },
  sectionTitle: {
    fontSize: 14,
    fontWeight: "600",
    color: COLORS.textSecondary,
    marginBottom: 8,
  },
  inputRow: { flexDirection: "row", gap: 12 },
  inputGroup: { flex: 1 },
  inputLabel: { fontSize: 12, color: COLORS.textMuted, marginBottom: 4 },
  input: {
    backgroundColor: COLORS.background,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    color: COLORS.textPrimary,
    fontSize: 16,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  button: {
    backgroundColor: COLORS.primary,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: "center",
  },
  solveButton: { backgroundColor: "#22c55e" },
  hintButton: { backgroundColor: COLORS.accent },
  clearButton: { backgroundColor: "#ef4444" },
  migrateButton: { backgroundColor: "#6366f1" },
  buttonText: { color: COLORS.textPrimary, fontSize: 14, fontWeight: "600" },
  closeButton: { paddingVertical: 12, alignItems: "center" },
  closeButtonText: { color: COLORS.textMuted, fontSize: 14 },
});

export default DevPanel;
</file>

<file path="src/components/WinModal.tsx">
import { DotLottie } from "@lottiefiles/dotlottie-react-native";
import React, { useEffect } from "react";
import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
import Animated, {
  Easing,
  FadeIn,
  ZoomIn, // Changed from SlideInDown
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated";
import { COLORS } from "../constants/gameConfig";

interface WinModalProps {
  visible: boolean;
  moves: number;
  stars: number;
  isLastLevel: boolean;
  chapterColor?: string;
  hasNextChapter?: boolean;
  onNextLevel: () => void;
  onReplay: () => void;
  onBackToLevels: () => void;
}

const Star: React.FC<{ delay: number }> = ({ delay }) => (
  <Animated.View entering={ZoomIn.delay(delay).springify()}>
    <DotLottie
      source={require("../assets/animations/star.lottie")}
      autoplay
      loop
      style={{ width: 90, height: 90 }}
    />
  </Animated.View>
);

const WinModal: React.FC<WinModalProps> = ({
  visible,
  moves,
  stars,
  isLastLevel,
  hasNextChapter,
  chapterColor,
  onNextLevel,
  onReplay,
  onBackToLevels,
}) => {
  const accentColor = chapterColor || COLORS.primary;
  const scale = useSharedValue(1);

  useEffect(() => {
    if (visible) {
      scale.value = withRepeat(
        withSequence(
          withTiming(1.1, { duration: 500, easing: Easing.ease }),
          withTiming(1, { duration: 500, easing: Easing.ease }),
        ),
        -1,
        true,
      );
    } else {
      scale.value = 1;
    }
  }, [visible]);

  const animatedTitleStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  if (!visible) return null; // Don't render if not visible

  return (
    <View style={[StyleSheet.absoluteFill, styles.overlayWrapper]}>
      <View style={styles.overlay}>
        <Animated.View
          entering={FadeIn.duration(300)}
          style={styles.modalContainer}
        >
          <Animated.Text style={[styles.title, animatedTitleStyle]}>
            Tebrikler!
          </Animated.Text>
          <Text style={styles.subtitle}>BulmacayÄ± TamamladÄ±n</Text>

          {/* Stars Container - Only render earned stars */}
          <View style={styles.starsContainer}>
            {Array.from({ length: stars }).map((_, index) => (
              <Star key={index} delay={index * 300} />
            ))}
          </View>

          <View style={styles.statsContainer}>
            <Text style={[styles.statValue, { color: accentColor }]}>
              {moves}
            </Text>
            <Text style={styles.statLabel}>Hamle</Text>
          </View>

          <View style={styles.buttonsContainer}>
            {(!isLastLevel || hasNextChapter) && (
              <TouchableOpacity
                style={[
                  styles.button,
                  styles.primaryButton,
                  { backgroundColor: accentColor },
                ]}
                onPress={onNextLevel}
                activeOpacity={0.8}
              >
                <Text style={styles.primaryButtonText}>
                  {isLastLevel ? "Sonraki BÃ¶lÃ¼m" : "Sonraki Seviye"}
                </Text>
              </TouchableOpacity>
            )}
            <TouchableOpacity
              style={[styles.button, styles.secondaryButton]}
              onPress={onReplay}
              activeOpacity={0.8}
            >
              <Text style={styles.secondaryButtonText}>Tekrar Oyna</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.button}
              onPress={onBackToLevels}
              activeOpacity={0.8}
            >
              <Text style={styles.tertiaryButtonText}>Seviyelere DÃ¶n</Text>
            </TouchableOpacity>
          </View>
        </Animated.View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  overlayWrapper: {
    zIndex: 9999, // Ensure it sits on top of everything
    elevation: 9999, // For Android
  },
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.85)",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  modalContainer: {
    backgroundColor: COLORS.surface,
    borderRadius: 24,
    padding: 32,
    width: "100%",
    maxWidth: 340,
    alignItems: "center",
  },
  lottieContainer: {
    marginBottom: 20,
    alignItems: "center",
    justifyContent: "center",
  },
  title: {
    fontSize: 28,
    fontWeight: "700",
    color: COLORS.textPrimary,
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 15,
    color: COLORS.textSecondary,
    marginBottom: 24,
  },
  starsContainer: {
    flexDirection: "row",
    marginBottom: 24,
    gap: 8,
    justifyContent: "center", // Centered content
  },
  star: {
    fontSize: 44,
    color: COLORS.starEmpty,
  },
  starFilled: {
    color: COLORS.starFilled,
  },
  statsContainer: {
    alignItems: "center",
    marginBottom: 32,
  },
  statValue: {
    fontSize: 40,
    fontWeight: "700",
  },
  statLabel: {
    fontSize: 14,
    color: COLORS.textSecondary,
    marginTop: 2,
  },
  buttonsContainer: {
    width: "100%",
    gap: 10,
  },
  button: {
    paddingVertical: 14,
    paddingHorizontal: 24,
    borderRadius: 14,
    alignItems: "center",
  },
  primaryButton: {},
  primaryButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  secondaryButton: {
    backgroundColor: "#e0e0e0", // Light gray for secondary button
  },
  secondaryButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  tertiaryButtonText: {
    color: COLORS.textMuted,
    fontSize: 14,
  },
});

export default WinModal;
</file>

<file path="src/constants/gameConfig.ts">
import { GridSize } from "../types";

export const LEVELS_PER_CHAPTER = 24;
export const TOTAL_CHAPTERS = 20;

// SHUFFLE_MOVES logic moved to puzzleLogic dynamic calculation

export const getGridSizeForLevel = (levelIndex: number): GridSize => {
  if (levelIndex <= 8) return { cols: 3, rows: 4 };
  if (levelIndex <= 16) return { cols: 4, rows: 5 };
  return { cols: 5, rows: 6 };
};

export const normalizeGridSize = (
  size: GridSize | number | undefined,
): GridSize => {
  if (!size) return { cols: 3, rows: 4 }; // Default to 3x4
  if (typeof size === "number") {
    // Legacy mapping: N -> N cols x (N+1) rows (Vertical)
    return { cols: size, rows: size + 1 };
  }
  return size;
};

// ==========================================
// RESPONSIVE BREAKPOINTS
// ==========================================

export const BREAKPOINTS = {
  phone: 0,
  tablet: 768,
  desktop: 1024,
};

export const getDeviceType = (
  width: number,
): "phone" | "tablet" | "desktop" => {
  if (width >= BREAKPOINTS.desktop) return "desktop";
  if (width >= BREAKPOINTS.tablet) return "tablet";
  return "phone";
};

export const getResponsiveValue = <T>(
  width: number,
  values: { phone: T; tablet: T; desktop?: T },
): T => {
  const type = getDeviceType(width);
  if (type === "desktop") return values.desktop ?? values.tablet;
  if (type === "tablet") return values.tablet;
  return values.phone;
};

// ==========================================
// COLORS - Re-exported from centralized file
// ==========================================

export { COLORS } from "./colors";

// ==========================================
// LAYOUT - Re-exported from centralized file
// ==========================================

export { LAYOUT } from "./layout";

// ==========================================
// UI CONSTANTS
// ==========================================

export const BOARD_PADDING = 12; // Kept for backward compatibility, use LAYOUT.boardPadding
export const TILE_GAP = 2;
export const TILE_BORDER_RADIUS = 6;

export const getBoardSize = (screenWidth: number): number => {
  const maxBoardSize = screenWidth - BOARD_PADDING * 2;
  return maxBoardSize;
};

export const getGridColumns = (screenWidth: number): number => {
  return getResponsiveValue(screenWidth, { phone: 2, tablet: 3, desktop: 4 });
};

// ==========================================
// HINT SYSTEM
// ==========================================

export const HINT_CONFIG = {
  defaultHints: 10,
  chapterBonus: 5,
  rewardedAdHints: 10, // AdMob'da ayarlanan Ã¶dÃ¼l miktarÄ±
};

// ==========================================
// AD CONFIG
// ==========================================

// Test Ad IDs (for development)
const TEST_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-3940256099942544/1033173712",
    ios: "ca-app-pub-3940256099942544/4411468910",
  },
  rewarded: {
    android: "ca-app-pub-3940256099942544/5224354917",
    ios: "ca-app-pub-3940256099942544/1712485313",
  },
  banner: {
    android: "ca-app-pub-3940256099942544/6300978111",
    ios: "ca-app-pub-3940256099942544/2934735716",
  },
  native: {
    android: "ca-app-pub-3940256099942544/2247696110",
    ios: "ca-app-pub-3940256099942544/3986624511",
  },
};

// Production Ad IDs (for release builds)
const PROD_AD_CONFIG = {
  interstitial: {
    android: "ca-app-pub-5502183878891798/5198222798",
    ios: "ca-app-pub-5502183878891798/3827454899",
  },
  rewarded: {
    android: "ca-app-pub-5502183878891798/3109269595",
    ios: "ca-app-pub-5502183878891798/2514373229",
  },
  banner: {
    android: "ca-app-pub-5502183878891798/4422351261",
    ios: "ca-app-pub-5502183878891798/2934735716",
  },
  native: {
    android: "ca-app-pub-5502183878891798/2705944917",
    ios: "ca-app-pub-5502183878891798/8494276450",
  },
};

// Automatically switch between test and production IDs
export const AD_CONFIG = __DEV__ ? TEST_AD_CONFIG : PROD_AD_CONFIG;

// ==========================================
// STORAGE KEYS
// ==========================================

export const STORAGE_KEYS = {
  USER_PROGRESS: "@puzzle_game_progress",
  HINT_COUNT: "@puzzle_game_hints",
  LAST_PLAYED: "@puzzle_game_last_played",
  DEVICE_ID: "@puzzle_game_device_id",
  LEVEL_STATE: "@puzzle_game_level_state",
};

// CHAPTER DATA handles moved to DataStore/Service
// generateChapters ve CHAPTERS kaldÄ±rÄ±ldÄ±.

// ==========================================
// STAR RATING SYSTEM (Difficulty Based)
// ==========================================

// ==========================================
// STAR RATING SYSTEM (Dynamic Difficulty)
// ==========================================

export const calculateStars = (moves: number, gridSize: GridSize): number => {
  // Ideal moves = Number of pieces (assuming 1 drag per piece)
  const idealMoves = gridSize.cols * gridSize.rows;

  // Penalty Step = Minimum dimension of the grid (e.g. 3 for 3x4)
  const step = Math.min(gridSize.cols, gridSize.rows);

  // Logic:
  // Moves <= Ideal -> 3 Stars
  // Moves <= Ideal + Step -> 2 Stars
  // Moves > Ideal + Step -> 1 Star

  if (moves <= idealMoves) return 3;
  if (moves <= idealMoves + step) return 2;
  return 1;
};
</file>

<file path="src/types/index.ts">
import { ImageSourcePropType } from "react-native";

export type ImageSource = ImageSourcePropType | { uri: string };
export type GridSize = { cols: number; rows: number };

export interface Level {
  id: number;
  chapterId: number;
  name?: string; // Optional level name
  gridSize: GridSize;
  imageSource: ImageSource;
}

export interface Chapter {
  id: number;
  name: string;
  description: string;
  thumbnail: ImageSource;
  levels: Level[];
  color?: string;
}

export interface LevelProgress {
  completed: boolean;
  bestMoves: number;
  stars: number;
}

export interface UserProgress {
  unlockedChapters: number[];
  completedLevels: Record<string, LevelProgress>;
  totalStars: number;
  totalCoins?: number; // Added for coin system
  lastPlayed?: {
    chapterId: number;
    levelId: number;
  };
}

export interface TilePosition {
  row: number;
  col: number;
}

export interface HintState {
  count: number;
  lastUpdated: number;
}
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
</file>

<file path="app/_layout.tsx">
import AsyncStorage from "@react-native-async-storage/async-storage";
import { createAsyncStoragePersister } from "@tanstack/query-async-storage-persister";
import { QueryClient } from "@tanstack/react-query";
import { PersistQueryClientProvider } from "@tanstack/react-query-persist-client";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useCallback, useEffect, useState } from "react";
import { StyleSheet, View } from "react-native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import DevPanel from "../src/components/DevPanel";
import { COLORS } from "../src/constants/gameConfig";
import { initializeAds } from "../src/services/adManager";
import { loginWithDevice } from "../src/services/authService";
import { getDeviceId } from "../src/services/deviceService";
import { useAdActions } from "../src/store/adStore";
import { useProgressActions } from "../src/store/progressStore";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60 * 60 * 24, // 24 hours (Aggressive caching for offline)
      gcTime: 1000 * 60 * 60 * 24 * 2, // 48 hours
    },
  },
});

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});

SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [appIsReady, setAppIsReady] = useState(false);
  const progressActions = useProgressActions();
  const adActions = useAdActions();

  useEffect(() => {
    async function prepare() {
      try {
        const deviceId = await getDeviceId();
        console.log("ğŸš€ App starting with device:", deviceId);

        // CRITICAL: Login FIRST so auth.currentUser is available
        await loginWithDevice();

        // THEN load progress (which needs auth.currentUser to fetch cloud data)
        await progressActions.loadProgress();
        await adActions.loadAdState();

        // Load Game Data (Chapters)
        const { getChapters } = await import("../src/store/dataStore").then(
          (m) => m.useDataStore.getState().actions,
        );
        await getChapters();

        try {
          initializeAds();
        } catch (error) {
          console.log("ğŸ“º Ad initialization skipped:", error);
        }
      } catch (e) {
        console.warn("App init error:", e);
      } finally {
        setAppIsReady(true);
      }
    }

    prepare();
  }, []);

  // Setup sync queue listener
  useEffect(() => {
    let unsubscribe: (() => void) | undefined;

    const setupSync = async () => {
      const { setupSyncListener } = await import("../src/services/syncQueue");
      unsubscribe = setupSyncListener();
    };

    setupSync();

    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  const onLayoutRootView = useCallback(async () => {
    if (appIsReady) {
      await SplashScreen.hideAsync();
    }
  }, [appIsReady]);

  if (!appIsReady) {
    return null;
  }

  return (
    <SafeAreaProvider>
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister: asyncStoragePersister }}
      >
        <View style={styles.container} onLayout={onLayoutRootView}>
          <StatusBar style="dark" />
          <Stack
            screenOptions={{
              headerStyle: { backgroundColor: COLORS.surface },
              headerTintColor: COLORS.textPrimary, // This is now white/dark depending on colors.ts
              headerTitleStyle: {
                fontWeight: "600",
                color: COLORS.textPrimary,
              },
              contentStyle: { backgroundColor: COLORS.background },
              headerShadowVisible: false,
            }}
          />
          {__DEV__ && <DevPanel />}
        </View>
      </PersistQueryClientProvider>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: COLORS.background },
});
</file>

<file path="app/index.tsx">
import { Image } from "expo-image";
import { Stack, useRouter } from "expo-router";
import React, { useEffect, useState } from "react";
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, {
  FadeInRight,
  FadeInUp,
  ZoomIn,
} from "react-native-reanimated";
import { SafeAreaView } from "react-native-safe-area-context";
import {
  BOARD_PADDING,
  COLORS,
  getResponsiveValue,
} from "../src/constants/gameConfig";
import { useAdActions } from "../src/store/adStore";
import { useChapters, useDataActions } from "../src/store/dataStore";
import {
  useLastPlayed,
  useProgressActions,
  useTotalCoins,
  useTotalStars,
} from "../src/store/progressStore";

export default function StartScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();

  // Stores
  const totalStars = useTotalStars();
  const totalCoins = useTotalCoins();
  const lastPlayed = useLastPlayed();
  const chapters = useChapters();

  // Actions
  const { getChapters, getLevelById } = useDataActions();
  const { loadProgress } = useProgressActions();
  const { loadAdState } = useAdActions();

  const { getNextPlayableLevel } = useProgressActions();

  const [isReady, setIsReady] = useState(false);

  useEffect(() => {
    const initGame = async () => {
      // 1. Load data in parallel
      await Promise.all([loadProgress(), loadAdState(), getChapters()]);

      // 2. Ready for UI - allow interaction immediately
      setIsReady(true);

      // 3. Optimization: Non-blocking calculation & prefetch
      // We don't need to store this in state if we can calc it on click,
      // but prefetching needs it now.
      const target = getNextPlayableLevel();

      console.log("ğŸ“ Smart Navigation Target:", target);

      if (target) {
        // Fetch specific level data to get image URI
        const levelData = await getLevelById(target.chapterId, target.levelId);

        // Fire-and-forget prefetch - don't block the UI
        if (
          levelData?.imageSource &&
          typeof levelData.imageSource === "object" &&
          "uri" in levelData.imageSource &&
          levelData.imageSource.uri
        ) {
          console.log(
            "ğŸš€ Prefetching Target Level Image:",
            levelData.imageSource.uri,
          );
          Image.prefetch(levelData.imageSource.uri).catch((e) =>
            console.warn("Prefetch failed", e),
          );
        }
      }
    };

    initGame();
  }, []);

  // Calculate stats
  const totalChapterCount = chapters.length || 0;

  const buttonWidth = getResponsiveValue(width, {
    phone: "85%",
    tablet: 320 as any,
  });

  const handleContinue = async () => {
    console.time("ğŸ‘‰ Continue Button Press");
    // Always calculate fresh target to ensure accuracy
    const target = getNextPlayableLevel();
    console.log("ğŸ“ Navigating to:", target);

    // Navigate
    router.push(`/game/jigsaw/${target.chapterId}/${target.levelId}`);

    // Optimization: Yield to main thread to allow navigation animation to start
    await new Promise((resolve) => setTimeout(resolve, 0));
    console.timeEnd("ğŸ‘‰ Continue Button Press");
  };

  const handleChapters = () => {
    router.push("/chapters");
  };

  return (
    <SafeAreaView style={styles.container}>
      <Stack.Screen
        options={{
          headerShown: false,
          title: "",
          headerStyle: { backgroundColor: COLORS.background },
          headerShadowVisible: false,
        }}
      />

      <View style={styles.content}>
        {/* LOGO & TITLE ANIMATION */}
        <View style={styles.logoGroup}>
          {/* ICON (T) */}
          <Animated.View entering={ZoomIn.delay(100).springify()}>
            <Image
              source={require("../src/assets/images/splash-icon.png")}
              style={styles.logoIcon}
              contentFit="contain"
            />
          </Animated.View>

          {/* TEXT (ilo) */}
          <View style={styles.titleTextContainer}>
            <Animated.Text
              entering={FadeInRight.delay(400).springify()}
              style={styles.titleText}
            >
              i
            </Animated.Text>
            <Animated.Text
              entering={FadeInRight.delay(600).springify()}
              style={styles.titleText}
            >
              l
            </Animated.Text>
            <Animated.Text
              entering={FadeInRight.delay(800).springify()}
              style={styles.titleText}
            >
              o
            </Animated.Text>
          </View>
        </View>

        {/* Buttons - Only show when ready? Or show loading? */}
        {!isReady ? (
          <ActivityIndicator
            size="large"
            color={COLORS.primary}
            style={{ marginTop: 50 }}
          />
        ) : (
          <>
            <Animated.View
              entering={FadeInUp.delay(1000).springify()}
              style={[styles.buttonsContainer, { width: buttonWidth as any }]}
            >
              {/* Continue Button */}
              <TouchableOpacity
                style={styles.continueButton}
                onPress={handleContinue}
                activeOpacity={0.8}
              >
                <View style={styles.continueContent}>
                  <Text style={styles.continueTitle}>Devam Et</Text>
                  {lastPlayed ? (
                    <Text style={styles.continueSubtitle}>
                      KaldÄ±ÄŸÄ±nÄ±z yerden devam edin
                    </Text>
                  ) : (
                    <Text style={styles.continueSubtitle}>
                      Yeni Oyun BaÅŸlat
                    </Text>
                  )}
                </View>
                <Text style={styles.continueArrow}>â†’</Text>
              </TouchableOpacity>

              {/* Chapters Button */}
              <TouchableOpacity
                style={styles.chaptersButton}
                onPress={handleChapters}
                activeOpacity={0.8}
              >
                <Text style={styles.chaptersButtonText}>BÃ¶lÃ¼mler</Text>
                <Text style={styles.chaptersCount}>{totalChapterCount}</Text>
              </TouchableOpacity>
            </Animated.View>

            <Animated.View
              entering={FadeInUp.delay(1100)}
              style={styles.progressContainer}
            >
              <View style={styles.statBadge}>
                <Text style={styles.statIcon}>â˜…</Text>
                <Text style={styles.statValue}>{totalStars}</Text>
              </View>
              <View style={styles.statBadge}>
                <Text style={styles.statIcon}>ğŸª™</Text>
                <Text style={styles.statValue}>{totalCoins}</Text>
              </View>
            </Animated.View>
          </>
        )}
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  content: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: BOARD_PADDING,
    gap: 32,
  },
  logoGroup: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 20,
  },
  logoIcon: {
    width: 60,
    height: 60,
    marginRight: 2, // Slight gap between Icon T and ilo
  },
  titleTextContainer: {
    flexDirection: "row",
  },
  titleText: {
    fontSize: 24, // As requested
    fontWeight: "bold",
    color: COLORS.textPrimary, // Assuming 'tilo' text color matches Icon or Primary Text
    // Adjust font family if needed
  },
  progressContainer: {
    flexDirection: "row",
    gap: 16,
    justifyContent: "center",
    marginTop: 10,
  },
  statBadge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: COLORS.surface,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 20,
    gap: 8,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  statIcon: {
    fontSize: 16,
  },
  statValue: {
    fontSize: 16,
    fontWeight: "700",
    color: COLORS.textPrimary,
  },
  buttonsContainer: {
    gap: 12,
  },
  continueButton: {
    backgroundColor: COLORS.primary,
    paddingVertical: 18,
    paddingHorizontal: 24,
    borderRadius: 16,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  continueContent: {
    flex: 1,
  },
  continueTitle: {
    color: COLORS.textPrimary,
    fontSize: 18,
    fontWeight: "700",
  },
  continueSubtitle: {
    color: COLORS.textPrimary,
    fontSize: 13,
    opacity: 0.8,
    marginTop: 2,
  },
  continueArrow: {
    color: COLORS.textPrimary,
    fontSize: 24,
    fontWeight: "300",
  },
  chaptersButton: {
    backgroundColor: COLORS.surface,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 16,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  chaptersButtonText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    fontWeight: "600",
  },
  chaptersCount: {
    color: COLORS.textPrimary,
    fontSize: 14,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
  },
});
</file>

<file path="app/levels/[chapterId].tsx">
import { Stack, useLocalSearchParams, useRouter } from "expo-router";
import React, { useEffect } from "react";
import {
  ActivityIndicator,
  FlatList,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
  useWindowDimensions,
} from "react-native";
import Animated, { FadeInDown } from "react-native-reanimated";
import {
  BOARD_PADDING,
  COLORS,
  getResponsiveValue,
} from "../../src/constants/gameConfig";
import { useDataActions, useIsDataLoading } from "../../src/store/dataStore";
import { useProgressActions } from "../../src/store/progressStore";
import { Level, LevelProgress } from "../../src/types";

interface LevelCardProps {
  level: Level;
  index: number;
  isUnlocked: boolean;
  progress: LevelProgress | null;
  cardSize: number;
  chapterColor?: string;
  onPress: () => void;
}

import { Image } from "expo-image"; // Ensure this is imported at top of file

import { Ionicons } from "@expo/vector-icons"; // Add this import at the top if missing, I will check effectively by deducing or adding it.
import { useSafeAreaInsets } from "react-native-safe-area-context";

// ... existing imports

const LevelCard: React.FC<LevelCardProps> = ({
  level,
  index,
  isUnlocked,
  progress,
  cardSize,
  chapterColor,
  onPress,
}) => {
  return (
    <Animated.View
      entering={FadeInDown.delay(index * 20).springify()}
      style={{ width: cardSize, alignItems: "center" }}
    >
      <TouchableOpacity
        style={[
          styles.levelCard,
          { width: cardSize, height: cardSize },
          progress?.completed && {
            borderColor: chapterColor || COLORS.accent,
            borderWidth: 2,
          },
        ]}
        onPress={onPress}
        disabled={!isUnlocked}
        activeOpacity={0.7}
      >
        {/* Background Image */}
        <Image
          source={level.imageSource}
          style={[StyleSheet.absoluteFill, styles.cardBgImage]}
          contentFit="cover"
          transition={200}
        />

        {/* Dark Overlay for Readability (Only when locked) */}
        {!isUnlocked && (
          <View style={[StyleSheet.absoluteFill, styles.cardOverlayLocked]} />
        )}

        {isUnlocked ? (
          <View style={styles.cardContent}>
            <View style={styles.levelBadge}>
              <Text style={styles.levelNumber}>{level.id}</Text>
            </View>
          </View>
        ) : (
          <View style={styles.centeredContent}>
            <Text style={styles.lockIcon}>ğŸ”’</Text>
          </View>
        )}
      </TouchableOpacity>

      {/* Stars Row - Consistent Height for ALL cards */}
      <View style={styles.starsRowBelow}>
        {isUnlocked ? (
          [1, 2, 3].map((star) => {
            const isFilled =
              progress?.completed && star <= (progress?.stars || 0);
            return (
              <Ionicons
                key={star}
                name="star"
                size={14}
                color={isFilled ? "#fbbf24" : "#e2e8f0"} // Gold or Light Gray
                style={isFilled && styles.starShadow} // Optional shadow for filled
              />
            );
          })
        ) : (
          // Placeholder for locked levels to maintain height
          <View style={{ height: 14 }} />
        )}
      </View>
    </Animated.View>
  );
};

export default function LevelsScreen() {
  const router = useRouter();
  const { width } = useWindowDimensions();
  const { chapterId } = useLocalSearchParams<{ chapterId: string }>();
  const progressActions = useProgressActions();
  const { top } = useSafeAreaInsets();

  const { getLevels, getChapterById } = useDataActions();
  const isLoading = useIsDataLoading();
  const [levels, setLevels] = React.useState<Level[]>([]);
  const chapter = getChapterById(Number(chapterId));

  useEffect(() => {
    const loadLevels = async () => {
      const fetchedLevels = await getLevels(Number(chapterId));
      setLevels(fetchedLevels);
    };
    loadLevels();
  }, [chapterId]);

  if (isLoading && levels.length === 0) {
    return (
      <View style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={COLORS.accent} />
      </View>
    );
  }

  if (!chapter) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorText}>Kategori bulunamadÄ±</Text>
      </View>
    );
  }

  const numColumns = getResponsiveValue(width, { phone: 4, tablet: 6 });
  const padding = BOARD_PADDING;
  const gap = 10;
  const cardSize = (width - padding * 2 - gap * (numColumns - 1)) / numColumns;
  const chapterProgress = progressActions.getChapterProgress(chapter.id);

  const renderLevel = ({ item, index }: { item: Level; index: number }) => {
    const isUnlocked = progressActions.isLevelUnlocked(chapter.id, item.id);
    const progress = progressActions.getLevelProgress(chapter.id, item.id);
    return (
      <LevelCard
        level={item}
        index={index}
        isUnlocked={isUnlocked}
        progress={progress}
        cardSize={cardSize}
        chapterColor={chapter.color}
        onPress={() => router.push(`/game/jigsaw/${chapterId}/${item.id}`)}
      />
    );
  };

  return (
    <View style={[styles.container, { paddingTop: top }]}>
      <Stack.Screen
        options={{
          headerShown: false,
          title: chapter.name,
          headerStyle: { backgroundColor: COLORS.background },
          headerTintColor: COLORS.textPrimary,
          headerShadowVisible: false,
        }}
      />

      {/* Header Info (Aesthetics Update) */}
      <View style={styles.headerInfoArea}>
        <View style={styles.headerTop}>
          <View>
            <TouchableOpacity
              onPress={() => router.back()}
              style={styles.backButton}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Ionicons
                name="chevron-back-sharp"
                size={24}
                color={COLORS.textPrimary}
              />
            </TouchableOpacity>
          </View>
          <View style={styles.headerTitles}>
            <Text style={styles.headerTitle}>{chapter.name}</Text>
            <View style={styles.progressPill}>
              <Text style={styles.progressPillText}>
                {chapterProgress.completed} / {chapterProgress.total} SEVÄ°YE
              </Text>
            </View>
          </View>
          <View style={styles.starPill}>
            <Text style={styles.starPillIcon}>â˜…</Text>
            <Text style={styles.starPillText}>{chapterProgress.stars}</Text>
          </View>
        </View>
      </View>

      <FlatList
        data={levels}
        renderItem={renderLevel}
        keyExtractor={(item) => item.id.toString()}
        numColumns={numColumns}
        key={numColumns}
        contentContainerStyle={[styles.listContent, { padding }]}
        columnWrapperStyle={{ gap }}
        ItemSeparatorComponent={() => <View style={{ height: gap }} />}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  centered: {
    justifyContent: "center",
    alignItems: "center",
  },
  errorText: {
    color: COLORS.textPrimary,
    fontSize: 16,
    textAlign: "center",
    marginTop: 24,
  },
  headerInfoArea: {
    padding: BOARD_PADDING,
    paddingBottom: 20,
    backgroundColor: COLORS.background,
  },
  headerTop: {
    flexDirection: "row",
    alignItems: "center",
    gap: 15,
  },
  chapterBadge: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: COLORS.border,
  },
  chapterBadgeText: {
    fontSize: 28,
    fontWeight: "900",
    color: COLORS.textPrimary,
  },
  headerTitles: { flex: 1 },
  headerTitle: { fontSize: 24, fontWeight: "800", color: COLORS.textPrimary },
  progressPill: {
    backgroundColor: COLORS.surface,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 6,
    alignSelf: "flex-start",
    marginTop: 4,
  },
  progressPillText: {
    fontSize: 10,
    color: COLORS.textSecondary,
    fontWeight: "700",
  },
  starPill: {
    backgroundColor: COLORS.surface,
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    gap: 6,
    borderWidth: 1,
    borderColor: COLORS.border,
  },
  starPillIcon: { color: COLORS.starFilled, fontSize: 18 },
  starPillText: { color: COLORS.textPrimary, fontWeight: "800", fontSize: 16 },
  listContent: {
    paddingBottom: 40,
  },
  levelCard: {
    backgroundColor: COLORS.surface,
    borderRadius: 16,
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: COLORS.border,
    overflow: "hidden", // Important for image masking
  },
  cardBgImage: {
    opacity: 1, // Full vibrancy!
  },
  cardOverlay: {
    // Removed default dark overlay
    backgroundColor: "transparent",
  },
  cardOverlayLocked: {
    backgroundColor: "rgba(0,0,0,0.6)", // Lighter lock overlay
  },
  cardContent: {
    flex: 1,
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 8,
  },
  levelCardLocked: {
    opacity: 0.5,
  },
  levelBadge: {
    backgroundColor: "rgba(255,255,255,0.9)", // Bright badge
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
    marginTop: 4,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  levelNumber: {
    fontSize: 16,
    fontWeight: "900",
    color: COLORS.textSecondary, // Dark text on light badge
  },
  lockIcon: {
    fontSize: 24,
    marginTop: 20, // Center optically
  },
  starsRow: {
    // Old starsRow style kept just in case, but unused now
    flexDirection: "row",
    gap: 1,
    marginBottom: 4,
  },
  starsRowBelow: {
    flexDirection: "row",
    gap: 2,
    marginTop: 4,
    height: 16, // Fixed height to prevent layout shifts
    alignItems: "center",
    justifyContent: "center",
  },
  starSmall: {
    fontSize: 12,
    color: "#cbd5e1", // Light gray for empty stars (slate-300)
  },
  starFilledSmall: {
    color: "#fbbf24", // Vibrant Gold
  },
  centeredContent: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  starPlaceholder: {
    fontSize: 10,
    color: "transparent",
  },
  star: {
    fontSize: 12,
    color: "rgba(255,255,255,0.5)", // Unearned star
    textShadowColor: "black",
    textShadowRadius: 1,
  },
  starFilled: {
    color: "#fbbf24", // Vibrant Gold
    textShadowColor: "rgba(0,0,0,0.5)",
    textShadowRadius: 1,
  },
  starShadow: {
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 1,
  },
  backButton: {
    height: 50,
    width: 50,
    borderRadius: 20,
    justifyContent: "center",
    alignItems: "center",
  },
});
</file>

<file path="package.json">
{
  "name": "puzzle-game",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@lottiefiles/dotlottie-react-native": "^0.7.1",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/native": "^7.1.8",
    "@tanstack/query-async-storage-persister": "^5.90.20",
    "@tanstack/react-query": "^5.90.18",
    "@tanstack/react-query-persist-client": "^5.90.20",
    "expo": "~54.0.31",
    "expo-application": "~7.0.8",
    "expo-build-properties": "~1.0.10",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-router": "~6.0.21",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-web-browser": "~15.0.10",
    "firebase": "^12.8.0",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-google-mobile-ads": "^16.0.1",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "react-test-renderer": "19.1.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "Tilo",
    "slug": "tilo",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./src/assets/images/icon.png",
    "scheme": "tilo",
    "userInterfaceStyle": "dark",
    "assetBundlePatterns": ["**/*"],
    "newArchEnabled": true,
    "splash": {
      "image": "./src/assets/images/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#0a0a0f"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.eoist.tilo"
    },
    "android": {
      "package": "com.eoist.tilo",
      "adaptiveIcon": {
        "foregroundImage": "./src/assets/images/adaptive-icon.png",
        "backgroundColor": "#0a0a0f"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./src/assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-5502183878891798~8940999016",
          "iosAppId": "ca-app-pub-5502183878891798~3324892015"
        }
      ],
      [
        "expo-build-properties",
        {
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0"
          },
          "ios": {
            "deploymentTarget": "15.1",
            "useFrameworks": "static"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {}
    }
  }
}
</file>

</files>
